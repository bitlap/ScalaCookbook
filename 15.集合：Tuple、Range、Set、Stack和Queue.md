# 15.集合：Tuple、Range、Set、Stack和Queue

与前面的集合章节相比，本章介绍的集合类与标准的序列和映射类型略有不同。

*元组*本质上是一个序列，但与类或特质一样，它可以包含任意数量的不同类型的值，如REPL示例所示：

```scala
    scala> (1, 2.2, "a", 'a')
    val res0: (Int, Double, String, Char) = (1, 2.2, a, a)
```

当像这样只需要一个容器来容纳一系列混合类型的时候，使用元组会十分方便。15.1小节将展示元组的使用方式。

*Range*是一个等差的数值或字符序列，通常用于for循环和填充其他集合。15.2小节将介绍它们的用途。

*Set*是一个仅包含唯一元素的集合，其中唯一性是由集合包含类型的==方法确定的。由于Set只能包含唯一的元素，所以如果试图向其中添加重复的元素，Set将会忽略这个元素。Scala包含基于Set实现的可变和不可变版本，同时还提供了其他场景的实现类，比如有序的Set。15.3小节到15.5小节将涵盖这些内容。

*Queue*（队列）是一个先进先出的数据结构，*Stack*（栈）是一个后进先出的数据结构。Scala包含每种类型的可变和不可变版本的实现，们分别在15.6小节和15.7小节中展示。





## 15.1 使用元组创建异构列表

### 问题

想要创建一个包含异构元素的小集合，并且不想使用**List[Matchable]**、**List[Any]**、或者类结构来创建。



### 解决方案

像Vector和ArrayBuffer这样的集合通常包含一个*同类型*元素序列，例如Vector[Int]或ArrayBuffer[String]。元组则允许在序列中创建一个*不同类型*元素的集合。

要创建元组，只需将所需的值放在括号内，用逗号分隔。例如，下面的示例展示了如何创建包含两个、三个和四个不同类型值的元组，注释表示所代表的类型:

```scala
    (1, 1.1)           // (Int, Double)
    (1, 1.1, 'a')      // (Int, Double, Char)
    (1, 1.1, 'a', "a") // (Int, Double, Char, String)
```

元组非常适合那些需要少量混杂的异构元素集合的情况。例如，下面是一个返回两个元素元组的方法：

```scala
    // return the user name and age
    def getUserInfo(): (String, Int) =
        // do whatever you need to do to get the data and then
        // return it as a tuple
        ("johndoe", 42)
```

**(String，Int)** 类型展示了如何将元组声明为方法返回类型。具体来讲，这个是一个由**String**和**Int**两个元素组成的元祖。还可以将该返回类型声明为**Tuple2**，如下所示：

```scala
    def getUserInfo(): Tuple2[String, Int] = ("johndoe", 42)
```

无论使用哪种方法，当调用该方法时，都会创建一个元组变量：

```scala
    val userInfo = getUserInfo() // (String, Int)
```

在Scala 2中，只能使用*下划线*语法来访问元组元素：

```scala
    userInfo._1 // "johndoe"
    userInfo._2 // 42
```

但在Scala 3中，也可以通过索引号访问元素，就像使用其他序列一样：

```scala
    userInfo(0) // "johndoe"
    userInfo(1) // 42
```

从元组创建变量的另一种常见方法是使用模式匹配将元组值解构为变量。下面示例将“**johndoe**”和**42**分别绑定到变量**name**和**age**：

```scala
    val (name, age) = getUserInfo()
    name // "johndoe"
    age  // 42
```

由于在Scala 3中元组更像列表，所以也有几种常用的集合方法：

```scala
    val t = (1, 2.2, "yo")
    t.size     // 3
    t.head     // Int = 1
    t.tail     // (Double, String) = (2.2,yo)
    t.drop(1)  // (Double, String) = (2.2,yo)
```

还可以连接两个元组：

```scala
    val t = (1, "a") ++ (3.3, 'd') // (Int, String, Double, Char) = (1,a,3.3,d)
```

在两个元素的元组中，还可以使用**swap**方法：

```scala
    val t = (1, 2.2) // (Int, Double) = (1,2.2)
    t.swap           // (Double, Int) = (2.2,1)
```

然而，可以想象，很难在一个元组上实现所有标准的集合方法，因为元组可以包含混合的类型，如**Int**、**Double**和**String**。因此，只有一些有限的方法可以使用。



### 讨论

Scala 3中的元组构建在异构列表（HList）结构上，该结构最初由Miles Sabin在其shapeless库（ *https://oreil.ly/WGFa3* ）中基于Scala 2创建。**HList**是一个非常有趣的结构，因为它是序列和类（或至少是record类型）之间的交叉。

#### 元组就像列表

理论上，可以使用隐式或显式类型创建异构元素的序列：

```scala
    val xs = List(1, 2.2, "a", 'b')            // List[Matchable] = List(1, 2.2, a, b)
    val xs: List[Any] = List(1, 2.2, "a", 'b') // List[Any] = List(1, 2.2, a, b)
```

但是，这样会产生丢失类型信息的问题。相反，元组保留了这些细节：

```scala
    (1, 2.2, "a", 'b') // (Int, Double, String, Char) = (1,2.2,a,b)
```

有一个重要的事情是，在Scala 3中，还可以使用以下 __:*__ 语法创建元组：

```scala
    1 *: "a" *: 2.2 *: EmptyTuple // (Int, String, Double) = (1,a,2.2)
```

有点类似于像这样创建一个列表：

```scala
    1 :: 2 :: Nil // List[Int] = List(1, 2)
```

了解 __*:__ 语法很重要，因为在REPL中使用元组时，会在输出中看到它：

```scala
    scala> val z = (1,2).zip("a", "b")
    val z: (Int, String) *:
      scala.Tuple.Zip[Int *: scala.Tuple$package.EmptyTuple.type, String *:
      scala.Tuple$package.EmptyTuple.type] = ((1,a),(2,b))

    scala> z
    val res0: (Int, String) *: (Int, String) *: EmptyTuple = ((1,a),(2,b))
```

输出的最后一行可以理解为“**res0**是一个元组变量，由一个 **(Int，String)** 元组和另一个 **(Int，String)** 元组组成。”可以看出**res0**是一个元组，因为它由元组类型组成，元组类型用 __*:__ 符号连接在一起，并以**EmptyTuple**结尾。



#### 元组和类

在某些情况下使用元组很方便，因为它们可以替代类，如**getUserInfo**方法所示，该方法返回元组而不是类。与其他Scala功能（如类型推断、并集和交集类型）一样，元组是一种让Scala感觉像一种动态语言的功能。

与类相关的另一个用途是，可以将简单的case类转换为元组，如下所示：

```scala
    // [1] create a case class and instance of it
    case class Stock(symbol: String, price: Double)
    val aapl = Stock("AAPL", 123.45)

    // [2] create a tuple from the case class
    val t = Tuple.fromProductTyped(aapl) // (String, Double) = (AAPL,123.45)
```

将case类转换为元组的好处是，可以编写一个通用的方法来接受任何 **(String, Double)** 类型的元组：

```scala
    def handleTuple(t: (String, Double)): Unit =
        println(s"String: ${t(0)}, Double: ${t(1)}")
```

虽然这是一个简单的例子，但当涉及到泛型编程时，该技术具有显著的优势。请参阅博客文章“Tuples Bring Generic Programming to Scala 3”（ *https://oreil.ly/c2iMJ* )有关在**case**类和元组之间转换的更多详细信息。



#### 元组和Map

最后，还可以使用两个元素的元组来创建**Map**。这种语法并不常用，但当遇到它时，简单了解下这个可能会有所帮助：

```scala
    val m = Map(
        (1, "a"),
        (2, "b")
    )
```

在相关内容中，还可以使用箭头语法创建两个元素的元组：

```scala
    1 -> "a" // (Int, String) = (1,a)
```

这与创建**Map**时通常使用的箭头语法的作用相同：

```scala
    val m = Map(
        1 -> "a",
        2 -> "b"
    )
```



### 另见

* 博客文章“Tuples Bring Generic Programming to Scala 3”（ *https://oreil.ly/c2iMJ* )有关在**case**类和元组之间转换的更多详细信息。

* *The Type Astronaut’s Guide to Shapeless* （ *https://oreil.ly/3qeRJ* ）以HTML和PDF格式免费提供，描述了由Miles Sabin创建的原始**HList**的使用。





## 15.2 创建Range

### 问题

需要创建一个值范围，例如在**for**循环中，或者从一个值范围中创建一个数值或字符的序列，通常用于测试目的。



### 解决方案





### 讨论





- [ ] 
- [ ]  15.2 Creating Ranges 449
- [ ]  15.3 Creating a Set and Adding Elements to It 453
- [ ]  15.4 Deleting Elements from Sets 455
- [ ]  15.5 Storing Values in a Set in Sorted Order 457
- [ ]  15.6 Creating and Using a Stack 458
- [ ]  15.7 Creating and Using a Queue 462


