# 17. 使用sbt构建项目

虽然你可以使用Ant、Maven和Gradle等工具来构建你的Scala项目，但sbt —— 原名为 *Simple Build Tool* —— 是Scala应用事实上的构建工具。sbt使基本的构建和依赖管理任务变得简单，并让你使用Scala语言本身来克服更困难的任务。

sbt使用与Maven相同的目录结构，和Maven一样，它采用了“惯例大于配置”的方法，使基本项目的构建过程变得异常简单。因为它提供了一个众所周知的标准构建过程，如果你在一个用sbt构建的Scala项目上工作，你可以很容易转移到另一个也用sbt的项目。项目的目录结构将是相同的，而且你会知道你应该看看 *build.sbt* 文件和可选的 *project/*.sbt* 文件，观察构建过程是如何配置的。

从1.3.0版本开始，sbt开始使用Coursier（ *https://get-coursier.io* ）进行类库管理，Coursier网站将这项任务称为 *工件获取（artifact fetching）*。在1.3.0之前，sbt使用Apache Ivy来完成这项任务，但Coursier旨在成为一个更快的替代品。当你在 *build.sbt* 文件中指定 *拓管的依赖关系（managed dependencies）* 时，Coursier是一个为你检索JAR文件的工具。

除了处理托管的依赖关系外，你还可以将 *非托管的依赖关系（unmanaged dependencies）* —— 普通的旧JAR文件放在项目的lib文件夹中，sbt会自动找到它们。

能够支持这个项目是我的荣幸。由于所有的这些特性，你只需付出很少的努力，sbt就可以让你建立包含Scala和Java代码、单元测试以及托管和非托管依赖的项目。

## sbt的功能

简而言之，sbt的主要功能是：
- 它使用Maven的标准目录结构，因此很容易构建标准的Scala项目，也很容易在不同的sbt项目之间移动。
- 小项目只需要很少的配置。
- 构建定义文件使用Scala DSL，所以你能使用Scala代码来构建Scala项目。
- sbt支持在同一个项目中编译Scala和Java源代码文件。
- 它同时支持托管和非托管的依赖关系。
- 你可以使用多种测试框架，包括ScalaTest（ *https://www.scalatest.org* ）、ScalaCheck（ *https://www.scalacheck.org* ）和MUnit（ *https://scala meta.org/munit* ），JUnit也有一个插件支持。
- 源代码可以在交互式或批量模式下进行编译。
- 支持连续编译和测试。
- 支持增量编译和测试（只有改变的源代码文件被重新编译）。
- 支持多个子项目。
- 能够打包和发布JAR文件。
- 生成和打包项目文档。
- 与IntelliJ IDEA和VS Code简单集成。
- 你可以在sbt中启动Scala REPL，所有项目的类和依赖关系都会自动在classpath上可用。
- 并行任务和测试执行。

## 理解sbt的理念

使用sbt有助于理解它的关键概念。首先要知道的是，sbt是一个构建工具 —— 它是用来构建Scala项目的。你可以使用Ant、Maven、Gradle和Mill（ *https://oreil.ly/8sLBz* ）等其他工具来构建Scala项目，但sbt是第一个Scala构建工具，而且它仍然被广泛使用。

## 目录结构

第二件要知道的事是，sbt使用的目录结构与Maven相同，所以一个有一个非托管依赖（JAR文件）、一个源代码文件和一个测试文件的简单项目就有这样的目录结构：
```
    .
    |-- build.sbt
    |-- lib
        |-- my-library.jar
    |-- project
    |   `-- build.properties
    `-- src
        |-- main
        |   `-- scala
        |       `-- example
        |           `-- Hello.scala
        `-- test
            `-- scala
                `-- example
                    `-- HelloTest.scala
```


如图所示，Scala源代码文件放在 *src/main/scala* 目录下，测试文件放在 *src/test/scala* 目录下。如果你想在项目中包含Java源代码文件，它们将被放在 *src/main/java* 和 *src/test/java* 目录下。如前所述，*lib* 目录下的JAR文件将在编译、测试和构建项目时自动作为依赖项使用。

### 配置文件不是必须的，但是...     -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;严格来说，对于一个极其简单的项目，*build.properties* 甚至 *build.sbt* 文件都不是必要的，但作为一个实际问题，你会在每个严肃的项目中看到它们。

## build.sbt

接下来要知道的是，项目的大部分配置信息都在一个名为 *build.sbt* 的文件中，它属于项目的根目录。关于 *build.sbt* 需要知道的事情包括：
- 它由键/值对形式的设置（**name := MyProject** ）和用sbt的自定义DSL编写的Scala代码组成。
- 大多数项目开始时至少有三个设置：项目名称、项目版本和用于编译项目的Scala版本。这些都是用名为 **name**、**version** 和 **scalaVersion** 的键指定的。
- 小项目可能只包括一些设置，而大项目可能包括几十行的设置和Scala代码。
- 托管的依赖关系也在这个文件中，用 **libraryDependencies** 键指定。

作为最后一点的预览，**libraryDependencies** 设置看起来像这样：
```
    libraryDependencies ++= Seq(
        "org.typelevel" %% "cats-core" % "2.6.0",
        "org.typelevel" %% "cats-effect" % "3.1.0"
    )
```

请注意，这只是正常的Scala代码。

## 其他注意事项

关于sbt，需要了解的其他几件事是：
- 你可以在一个sbt项目中包含多个项目。我在博文“How to Create an sbt Project with Subprojects”（ *https://oreil.ly/VR334* ）中展示了这一点。
- 你可以在 *build.sbt* 文件中添加你自己的导入语句，以便在构建中使用你自己的类。这些包是默认导入的：
```
    — sbt.*
    — sbt.Keys.* 
    — Process.*
```

作为最后的说明，本章中所有的示例都是用sbt1.5.1版本测试的。

## 17.1 为sbt创建一个项目目录结构

### 问题

你要创建一个新的Scala/sbt项目所需的初始文件和目录。

### 解决方案

使用shell脚本或 **sbt new** 命令来创建新项目。这里展示了这两种方法。

#### 方法1：使用一个shell脚本

sbt使用与Maven相同的目录结构，所以如果你使用的是Unix系统，可以用shell脚本生成一个兼容的结构。例如，下面的shell脚本可以为大多数项目创建初始的文件和目录集：
```
    #!/bin/sh
    mkdir -p src/{main,test}/{java,resources,scala}
    mkdir project
    
    # create an initial build.sbt file
    echo 'name := "MyProject"
    version := "0.1"
    scalaVersion := "3.0.0"
    
    // libraryDependencies ++= Seq(
    //     "org.scalatest" %% "scalatest" % "3.2.3" % "test"
    // )
    ' > build.sbt
    
    # create a project/build.properties file with the desired sbt version
    echo 'sbt.version=1.5.1' > project/build.properties
```

只要在Unix系统上把这段代码保存为shell脚本，使其可执行，并在一个新的项目目录下运行它，以创建所有sbt需要的子目录和文件。例如，假设这个脚本在你的路径上，并被命名为 *mkdirs4sbt*，这个过程看起来像这样：
```
    /Users/Al/Projects> mkdir MyNewProject 
    /Users/Al/Projects> cd MyNewProject 
    /Users/Al/Projects/MyNewProject> mkdirs4sbt
```

如果你在系统中安装了tree命令，并在当前目录下运行它，你会看到这些命令会创建这些文件和目录：
```
    $ tree .
    .
    ├── build.sbt
    ├── project
    │   └── build.properties 
    └── src
        ├── main
        |   ├── java
        │   ├── resources
        │   └── scala
        └── test
            ├── java
            ├── resources
            └── scala
```

正如shell脚本所暗示的，*build.sbt* 文件有这些内容：
```
    name := "MyProject"
    version := "0.1"
    scalaVersion := "3.0.0"
    // libraryDependencies ++= Seq(
    //     "org.scalatest" %% "scalatest" % "3.2.3" % "test"
    // )
```

前三行设置了键/值对，你在每个sbt项目中都会用到：
- **name** 声明你的项目的名称。
- **version** 设置项目的版本级别。
- **scalaVersion** 设置用于编译的Scala版本。

在这之后，**libraryDependencies** 一行声明了项目的所有依赖。因为我在大多数项目中都使用ScalaTest，所以我把它放在这里。


我还将 **libraryDependencies** 声明为 **Seq** ，因为我的项目中通常有不止一个依赖。如果你只添加一个依赖，你可以像这样声明这一行：
```
    libraryDependencies += "org.scalatest" %% "scalatest" % "3.2.3" % "test"
```

注意，在第一个例子中我使用了 **++=**，在第二个例子中我使用了 **+=**。在这两种情况下，这是因为我把这个依赖添加到之前可能定义的其他依赖中。与此相反，前三个参数是用 **:=** 设置的，在这几行中我只设置了一个值，但 **libraryDependencies** 允许你添加多个依赖关系。

通过这个shell脚本，*project/build.properties* 文件被创建，其中有这些内容：
```
    sbt.version=1.5.1
```

这告诉sbt launcher，我想在这个项目上使用1.5.1版本的sbt。

这只是一个简单的启动脚本，我首先展示它，以证明创建一个sbt项目是多么容易。关于更完整的shell脚本 **sbtmkdirs**，请参阅我的博文“sbtmkdirs: A Shell Script to Create a Scala SBT Project Directory Structure”（ *https:// oreil.ly/o5uYO* ）。

####  控制scalac -- TODO 耗子栏

&nbsp;&nbsp;&nbsp;&nbsp;在我的项目中，我通常会添加一系列的选项来控制 **scalac** 编译器如何与sbt一起工作。这些是我在Scala 3中使用的几个选项：
```
    scalacOptions ++= Seq(
        "-deprecation",
        "-explain",
        "-explain-types",
        "-new-syntax",
        "-unchecked",
        "-Xfatal-warnings",
        "-Xmigration"
)
```

&nbsp;&nbsp;&nbsp;&nbsp;你可以把这些选项添加到 *build.sbt* 文件的末尾，或者添加到你在后面的 **sbt new** 部分看到的 **settings** 方法里面。

#### 方法2：使用sbt new

虽然该脚本展示了如何简单地建立一个初始的sbt项目，但你也可以使用 **sbt new** 命令从预先构建的模板中创建新项目。这些模板是开源的，由其他sbt用户创建，它们被用来创建预先配置好的sbt项目，以使用一个或多个Scala工具，如ScalaTest、Akka和其他。我发现这些模板还使用了不同的编码风格，当你想看到不同的sbt配置功能时，这对你很有帮助。

为了展示它是如何工作的，这个 **sbt new** 命令大致相当于我刚才展示的shell脚本：
```
    $ sbt new scala/scala3.g8
```

这是从你的操作系统命令行中看到的过程：
```
    $ sbt new scala/scala3.g8
    // some initial output here ...
    
    A template to demonstrate a minimal Scala 3 application
    
    name [Scala 3 Project Template]: My New Project
    
    Template applied in ./my-new-project
```

*my-new-project* 目录现在包含一个 *build.sbt* 文件以及其他目录和文件，因此你可以将其用于一个新的Scala/sbt项目。

### 讨论

**sbt new** 的方法与使用shell脚本有很大不同，所以值得进一步讨论。首先，下面是关于 **sbt new** 如何工作的一些说明：
- 有几个模板可用，但 **sbt new scala/scala3.g8** 命令使用一个名为Giter8（ *http://www.foundweekends.org/giter8* ）的工具寻找并运行一个名为 *scala3.g8* 的模板。
- 在这个例子中，*scala3.g8* 模板可以在这个GitHub页面找到（ *https:// github.com/scala/scala3.g8* ）。
- 根据Giter8的网站，“Giter8是一个命令行工具，可以从GitHub或任何其他Git仓库发布的模板中生成文件和目录。”
- 因为这个命令是从GitHub上调取模板，所以运行可能需要花一些时间。
- 该命令将项目名称“My New Project”转换为名为 **my-new-project** 的目录。

由于采用了模板方法，这个命令创建的目录结构和文件可能会随着时间的推移而改变，但在写这篇文章时，从 *scala3.g8* 模板创建的结构看起来是这样的：
```
    $ tree .
    .
    ├── README.md
    ├── build.sbt
    ├── project
    │   └── build.properties 
    └── src
        ├── main
        │   └── scala
        │       └── Main.scala
        └── test
            └── scala
                └── Test1.scala
```

#### 模板创建的文件

模板的 *build.sbt* 文件看起来是这样的：
```
    val scala3Version = "3.0.0"
    lazy val root = project
      .in(file("."))
      .settings(
        name := "scala3-simple",
        version := "0.1.0",
        scalaVersion := scala3Version,
        libraryDependencies += "com.novocode" % "junit-interface" % "0.11" % "test"
    )
```

像往常一样，*project/build.properties* 文件包含最新的sbt版本：
```
    sbt.version=1.5.1
```

*build.sbt* 的语法与我在shell脚本中使用的不同。虽然我发现在第一次学习sbt的时候，shell脚本中的方法更容易阅读，但当项目越来越大时，这第二种方法更受欢迎，部分原因是它看起来更像Scala代码，所以它更像是用Scala代码控制你的Scala项目配置。

随着需求的增长，你会看到额外的 *build.sbt* 变量。例如，如果你要发布一个类库到一个公共仓库，并想控制 *pom.xml* 文件中的内容，你会想指定与组织有关的参数：
```
    organization := "com.alvinalexander"
    organizationName := "Alvin Alexander"
    organizationHomepage := Some(url("https://alvinalexander.com"))
```

你可能想为这个用例配置的其他参数显示在sbt项目的元数据页面（ *https://oreil.ly/2BAc4* ），包括：
```
    homepage := Some(url("https://www.scala-sbt.org"))
    startYear := Some(2008)
    description := "A build tool for Scala."
    licenses += "GPLv2" -> url("https://www.gnu.org/licenses/gpl-2.0.html")
```

综上所述，使用 **sbt new** 命令的主要好处是：
- 已经创建了模板来帮助你开始使用ScalaTest、Akka、Play Framework、Lagom、Scala Native等等。
- 这些模板目前生成的 *build.sbt* 文件都有些不同，所以你可以看到不同的配置方式，也就是其他用户喜欢的方式。

你可以在sbt网站（ *https://oreil.ly/XoVSg* ）上找到与 **sbt new** 一起使用的模板列表。

#### .gitignore中的文件和目录 -- TODO 耗子栏

&nbsp;&nbsp;&nbsp;&nbsp;假设你将代码保存在Git仓库中，你还需要创建一个 *.gitignore* 文件来告诉Git应该忽略哪些sbt文件和目录。这是两个你想告诉Git忽略的初始目录：
```
    target/
    project/target/
```

&nbsp;&nbsp;&nbsp;&nbsp;我的 **sbtmkdirs** 脚本（ *https://oreil.ly/o5uYO* ）增加了许多其他条目，以说明IntelliJ IDEA、VS Code、Bloop（ *https://scalacenter.github.io/bloop* ）和Metals（ *https://scalameta.org/metals* ）等工具。

## 17.2 使用sbt命令构建项目

### 问题

你需要看看如何用sbt命令来编译、测试和运行你的项目。

### 解决方案

使用sbt命令来构建、编译、测试和打包你的项目。例如，这个命令可以编译你的项目：
```
    $ sbt compile
```

如果你在项目中配置了ScalaTest（ *https://www.scalatest.org* ）这样的测试框架的话，这个命令就可以运行你的项目测试：
```
    $ sbt test
```

而这个命令是在你的项目中运行 **main** 方法：
```
    $ sbt run
```

在17.4和17.11小节中详细介绍了从一个sbt项目创建一个JAR文件，但作为一个快速介绍，你可以使用 **package** 命令将一个简单的项目打包成一个JAR文件：
```
    $ sbt package
```

#### 多个@main方法 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;如果你的项目有多个 **@main** 方法，请参阅17.10小节以了解在使用 **run** 和 **package** 命令时如何处理它们。

### 讨论

需要理解的一点是，系统中的 **sbt** 命令只是一个 *启动器（launcher）*。它启动了整个sbt进程，但由于sbt能够使用不同版本的Scala和sbt，所以 **sbt** 命令只是启动了这个进程。当它启动时，它会下载任何它需要的资源，包括你想在项目中使用的Scala和sbt的版本。（事实上，当你运行sbt时，你实际上是在Unix系统上运行一个Bash脚本或在Windows上运行一个批处理文件）。

正因为如此，建议你在你的项目的 *project/build.properties* 文件中加入这样的设置：
```
    sbt.version=1.5.1
```

这告诉sbt启动器，在这个项目上运行命令时，你想使用sbt1.5.1版本。这样做是为了确保在团队环境中，每个人在进行构建时都使用的是相同版本的sbt。如果你不设置这个值，sbt会在第一次运行时将其设置为最新版本。

#### 批量和交互式模式

关于sbt命令的另一个注意点是，它可以在批处理模式下运行，也可以交互式模式下运行。我之前展示的命令是 *批处理模式（batch mode）* 的命令：
```
    $ sbt compile $ sbt test
    $ sbt run
    $ sbt package
```

它们从你的操作系统命令行运行。它们首先启动 **sbt** 启动器，然后运行你指定的任何命令。因为它们是从操作系统的命令行运行的，所以sbt需要花一点时间来启动，因此这不是运行sbt的首选方式，除非你从一个脚本中运行它，比如Unix的cron进程。（Unix中的cron系统是一种调度工作的方式，可以在特定的日期和时间运行。）

首选的方法是在 *交互式（interactive）* 模式下运行sbt。在这种模式下，你从操作系统的命令行启动一次sbt：
```
    $ sbt
```

然后你在sbt shell里面运行命令：
```
    > compile > test
    > run
    > package
```

这些命令的运行速度明显加快，因为sbt已经在运行、预热并准备好了。如17.6小节所示，你也可以连续运行 **compile** 和 **test** 命令。在这种用法中，每当你改变项目中的一个文件时，这些命令就会运行。

##### sbt只需要用到Java -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;你不需要安装Scala来运行sbt。它只要求你安装了Java JDK。

## 17.3 理解build.sbt语法风格

### 问题

### 解决方案

### 讨论

## 17.4 编译、运行和打包一个Scala项目

### 问题

### 解决方案

### 讨论

## 17.5 理解其他sbt命令

### 问题

### 解决方案

### 讨论

## 17.6 连续的编译和测试

### 问题

### 解决方案

### 讨论

## 17.7 用sbt管理依赖

### 问题

### 解决方案

### 讨论

## 17.8 控制使用哪个版本的托管依赖

### 问题

### 解决方案

### 讨论

## 17.9 生成项目的API文档

### 问题

### 解决方案

### 讨论

## 17.10 指定一个使用sbt运行的主类

### 问题

### 解决方案

### 讨论

## 17.11 部署单个可执行的JAR文件

### 问题

### 解决方案

### 讨论

## 17.12 发布你的类库

### 问题

### 解决方案

### 讨论