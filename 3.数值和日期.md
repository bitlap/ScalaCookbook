# 3. 数值和日期

本章涵盖了Scala数值类型，以及Java 8引入的日期和时间API的使用方法。


在Scala中，**Byte**、**Short**、**Int**、**Long**和**Char**类型被称为*整数类型*，因为它们由整型数字表示。整数类型以及**Double**和**Float**组成了Scala的*数值类型*。与被称为“非数值类型”的**Unit**和**Boolean**一样，这些数值类型都继承**AnyVal**特质（trait）。在[Scala页面](https://oreil.ly/C7Id7)（ *https://oreil.ly/C7Id7* ）关于统一类型的讨论中，这9种类型都被称为*预定义值类型*，并且不能为空。



预定义值类型与**AnyVal**和**Any**（以及**Nothing**）的关系如图3-1所示：

* 所有的数值类型都继承自**AnyVal**。

* Scala类层次结构中的所有其他类型都继承自**AnyRef**。

<img title="" src="./images/ch3/Figure3-1.jpg" alt="" data-align="center" width="783">

                       *图3-1：所有预定义的数值类型都继承自* ***AnyVal***



如表3-1所示，Scala的数值类型与Java中对应的基本类型有着相同的数值范围。



表3-1：Scala中数值类型的数值范围：

| 类型         | 描述                | 范围                     |
| ---------- | ----------------- | ---------------------- |
| **Char**   | 16位无符号Unicode字符   | 0~65535                |
| **Byte**   | 8位有符号整数           | -128~127               |
| **Short**  | 16位有符号整数          | -32768~32767           |
| **Int**    | 32位有符号整数          | -2147483648~2147483647 |
| **Long**   | 64位有符号整数          | -2^63~2^63-1           |
| **Float**  | 32位IEEE 754单精度浮点数 | 见下文                    |
| **Double** | 64位IEEE 754双精度浮点数 | 见下文                    |

除此之外，**Boolean**可以为**true**或者**false**。



如果想知道数据范围的精确值，但手头没有这本书，可以在Scala REPL中查看：

```scala
 Char.MinValue.toInt // 0
 Char.MaxValue.toInt // 65535
 Byte.MinValue       // -128
 Byte.MaxValue       // +127
 Short.MinValue      // −32768
 Short.MaxValue      // +32767
 Int.MinValue        // −2147483648
 Int.MaxValue        // +2147483647
 Long.MinValue       // -9,223,372,036,854,775,808
 Long.MaxValue       // +9,223,372,036,854,775,807
 Float.MinValue      // −3.4028235e38
 Float.MaxValue      // +3.4028235e38
 Double.MinValue     // -1.7976931348623157e308
 Double.MaxValue     // +1.7976931348623157e308
```

除了这些基本数值类型之外，**BigInt**和**BigDecimal**在本章后续部分都会降到。



### 数值常量中的下划线

Scala 2.13 引入了在数值常量中使用下划线的功能：

```scala
// Int
val x = 1_000
val x = 100_000
val x = 1_000_000

// Long (也可以使用小写的‘l’, 但看起来容易跟数字’1‘混淆)
val x = 1_000_000L

// Double
val x = 1_123.45
val x = 1_123.45D
val x = 1_123.45d
val x = 1_234e2 // 123400.0

// Float
val x = 3_456.7F
val x = 3_456.7f
val x = 1_234e2F

// BigInt and BigDecimal
val x: BigInt = 1_000_000
val x: BigDecimal = 1_234.56
```



带下划线的数值常量可以使用在所有常用的地方：

```scala
val x = 1_000 + 1

if x > 1_000 && x < 1_000_000 then println(x)

x match
   case 1_000 => println("got 1,000")
   case _     => println("got something else")

for
   i <- 1 to 1_000
   if i > 999
do
   println(i)
```



目前带下划线的数值常量不能使用的一个地方是从**String**转换为数字类型：

```scala
Integer.parseInt("1_000") // NumberFormatException
"1_000".toInt             // NumberFormatException
```



### 复数

除了Scala自带的math类库，如果需要其他更强大的数学运算能力，可以了解一下[Spire](https://typelevel.org/spire)（ **https://typelevel.org/spire** ），它包含了Rational、Complex和Real等更高级的数学概念。



### 日期和时间

本章最后几节介绍了Java 8引入的日期和时间API，并展示了如何使用**LocalDate**、**LocalTime**、**LocalDateTime**、**Instant**和**ZonedDateTime**等新类。



## 3.1 从字符串到数值

### 问题

把一个字符串转换成一个Scala的数值类型。



### 解决方法

可以在**String**上使用**toXxx**方法：

```scala
"1".toByte   // Byte = 1
"1".toShort  // Short = 1
"1".toInt    // Int = 1
"1".toLong   // Long = 1
"1".toFloat  // Float = 1.0
"1".toDouble // Double = 1.0
```

需要注意的是，这些方法可能会抛出Java的**NumberFormatException**：

```scala
"hello!".toInt // java.lang.NumberFormatException
```

因此，使用**to*Option**方法也是一个不错的选择，它的作用是在转换成功时返回**Some**，转换失败时返回**None**：

```scala
"1".toByteOption   // Option[Byte] = Some(1)
"1".toShortOption  // Option[Short] = Some(1)
"1".toIntOption    // Option[Int] = Some(1)
"1".toLongOption   // Option[Long] = Some(1)
"1".toFloatOption  // Option[Float] = Some(1.0)
"1".toDoubleOption // Option[Double] = Some(1.0)
"one".toIntOption  // Option[Int] = None
```

**BigInt**和**BigDecimal**实例也可以通过字符串创建，并且也有可能抛出**NumberFormatException**：

```scala
val b = BigInt("1") // BigInt = 1
val b = BigDecimal("1.234") // BigDecimal = 1.234

val b = BigInt("yo") // NumberFormatException
val b = BigDecimal("dude!") // NumberFormatException
```



#### 处理基数和根

如果想要处理**十进制**以外的计算，使用Scala的**toInt**方法是不支持传入**进制**的参数的。此时可以使用**java.lang.Integer**类的**parseInt**方法，例如：

```scala
Integer.parseInt("1", 2)   // Int = 1
Integer.parseInt("10", 2)  // Int = 2
Integer.parseInt("100", 2) // Int = 4
Integer.parseInt("1", 8)   // Int = 1
Integer.parseInt("10", 8)  // Int = 8
```

当然，参考2.11节，你也可以使用Scala中的自定义扩展方法来解决这个问题：

```scala
extension(s: String) {
  def toInt(radix: Int) = java.lang.Integer.parseInt(s, radix)
}

"10".toInt(2) // Int = 2
```



### 讨论

如果用过Java把**字符串**转换成数值类型，那么一定会对**NumberFormatException**很熟悉。然而，Scala中并没有受检异常，所以可以用其他方式来处理这个异常。

首先，没有必要在一个Scala方法上声明可能抛出的异常，因此下面的方法定义是合法的：

```scala
// you're not required to declare "throws NumberFormatException"
def makeInt(s: String) = s.toInt
```

#### 编写一个纯函数

然而，在函数式编程（FP）中，最好永远不要定义上述的方法。如前所述，这种方法可能会使调用方的代码短路抛出异常。（如果不希望其他开发人员定义这种方法给你使用，你最好也不要对其他开发人员这样做。）相反，纯函数 ***总是*** 返回其签名所显示的类型。因此，在FP中，你可以这样写这个函数：

```scala
def makeInt(s: String): Option[Int] =
  try
    Some(s.toInt)
  catch
    case e: NumberFormatException => None
```

该函数的返回值类型是**Option[Int]**，这意味着如果你给它一个 **“10”**，它将返回一个**Some(10)**，如果你给它一个 **“Yo”**，它将返回一个**None**。此函数相当于上述解决办法中的**toIntOption**，该方法在Scala2.13中引入。



TODO（松鼠图）

#### 简化makeInt方法

虽然上述代码 **makeInt(s: String): Option[Int]** 已经比较完美了，但是还可以进一步精简，如下所示：

```scala
import scala.util.Try
def makeInt(s: String): Option[Int] = Try(s.toInt).toOption
```

这两种不同定义的**makeInt**方法都会返回 **Some[Int]** 或者 **None**：

```scala
makeInt("a") // None
makeInt("1") // Some(1)
makeInt("2147483647") // Some(2147483647)
makeInt("2147483648") // None
```

如果更加喜欢**Try**的返回值类型，你可以这样做：

```scala
import scala.util.{Try, Success, Failure}
def makeInt(s: String): Try[Int] = Try(s.toInt)
```

使用**Try**的优势是当程序发生异常，可以从返回的**Failure**对象中获取具体的异常：

```scala
makeInt("1") // Success(1)
makeInt("a") // Failure(java.lang.NumberFormatException: For input string: "a")
```

#### 声明方法的异常

如果期望声明方法会抛出异常，可以通过 **@throws** 注解来标注方法：

```scala
@throws(classOf[NumberFormatException])
def makeInt(s: String) = s.toInt
```

如果在Java代码调用这个方法，这个注解式异常声明是必须的。22.7节说明了这点。



### 另见

* 24.6节，更详细讲解了**Option**、**Some**和**None**的使用。





## 3.2 数值类型转换

### 问题

把一个数值类型转换成另一个数值类型，比如把**Int**转成**Double**、**Double**转成**Int**、或者涉及到**BigInt**和**BigDecimal**的转换。



### 解决方法





- [ ]  3.3 Overriding the Default Numeric Type

- [ ]  3.4 Replacements for ++ and −−

- [ ]  3.5 Comparing Floating-Point Numbers

- [ ]  3.6 Handling Large Numbers

- [ ]  3.7 Generating Random Numbers

- [ ]  3.8 Formatting Numbers and Currency

- [ ]  3.9 Creating New Date and Time Instances

- [ ]  3.10 Calculating the Difference Between Two Dates

- [ ]  3.11 Formatting Dates

- [ ]  3.12 Parsing Strings into Dates
