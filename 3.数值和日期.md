# 3. 数值和日期

本章涵盖了Scala数值类型，以及Java 8引入的日期和时间API的使用方法。


在Scala中，**Byte**、**Short**、**Int**、**Long**和**Char**类型被称为*整数类型*，因为它们由整型数字表示。整数类型以及**Double**和**Float**组成了Scala的*数值类型*。与被称为“非数值类型”的**Unit**和**Boolean**一样，这些数值类型都继承**AnyVal**特质（trait）。在[Scala页面](https://oreil.ly/C7Id7)（ *https://oreil.ly/C7Id7* ）关于统一类型的讨论中，这9种类型都被称为*预定义值类型*，并且不能为空。



预定义值类型与**AnyVal**和**Any**（以及**Nothing**）的关系如图3-1所示：

* 所有的数值类型都继承自**AnyVal**。

* Scala类层次结构中的所有其他类型都继承自**AnyRef**。

<img title="" src="./images/ch3/Figure3-1.jpg" alt="" data-align="center" width="783">

                       *图3-1：所有预定义的数值类型都继承自* ***AnyVal***



如表3-1所示，Scala的数值类型与Java中对应的基本类型有着相同的数值范围。



表3-1：Scala中数值类型的数值范围：

| 类型         | 描述                | 范围                     |
| ---------- | ----------------- | ---------------------- |
| **Char**   | 16位无符号Unicode字符   | 0~65535                |
| **Byte**   | 8位有符号整数           | -128~127               |
| **Short**  | 16位有符号整数          | -32768~32767           |
| **Int**    | 32位有符号整数          | -2147483648~2147483647 |
| **Long**   | 64位有符号整数          | -2^63~2^63-1           |
| **Float**  | 32位IEEE 754单精度浮点数 | 见下文                    |
| **Double** | 64位IEEE 754双精度浮点数 | 见下文                    |

除此之外，**Boolean**可以为**true**或者**false**。



如果想知道数据范围的精确值，但手头没有这本书，可以在Scala REPL中查看：

```scala
    Char.MinValue.toInt // 0
    Char.MaxValue.toInt // 65535
    Byte.MinValue       // -128
    Byte.MaxValue       // +127
    Short.MinValue      // −32768
    Short.MaxValue      // +32767
    Int.MinValue        // −2147483648
    Int.MaxValue        // +2147483647
    Long.MinValue       // -9,223,372,036,854,775,808
    Long.MaxValue       // +9,223,372,036,854,775,807
    Float.MinValue      // −3.4028235e38
    Float.MaxValue      // +3.4028235e38
    Double.MinValue     // -1.7976931348623157e308
    Double.MaxValue     // +1.7976931348623157e308
```

除了这些基本数值类型之外，**BigInt**和**BigDecimal**在本章后续部分都会降到。



### 数值常量中的下划线

Scala 2.13 引入了在数值常量中使用下划线的功能：

```scala
    // Int
    val x = 1_000
    val x = 100_000
    val x = 1_000_000

    // Long (也可以使用小写的‘l’, 但看起来容易跟数字’1‘混淆)
    val x = 1_000_000L

    // Double
    val x = 1_123.45
    val x = 1_123.45D
    val x = 1_123.45d
    val x = 1_234e2 // 123400.0

    // Float
    val x = 3_456.7F
    val x = 3_456.7f
    val x = 1_234e2F

    // BigInt and BigDecimal
    val x: BigInt = 1_000_000
    val x: BigDecimal = 1_234.56
```



带下划线的数值常量可以使用在所有常用的地方：

```scala
    val x = 1_000 + 1

    if x > 1_000 && x < 1_000_000 then println(x)

    x match
       case 1_000 => println("got 1,000")
       case _     => println("got something else")

    for
       i <- 1 to 1_000
       if i > 999
    do
       println(i)
```



目前带下划线的数值常量不能使用的一个地方是从**String**转换为数字类型：

```scala
    Integer.parseInt("1_000") // NumberFormatException
    "1_000".toInt             // NumberFormatException
```



### 复数

除了Scala自带的math类库，如果需要其他更强大的数学运算能力，可以了解一下[Spire](https://typelevel.org/spire)（ **https://typelevel.org/spire** ），它包含了Rational、Complex和Real等更高级的数学概念。



### 日期和时间

本章最后几节介绍了Java 8引入的日期和时间API，并展示了如何使用**LocalDate**、**LocalTime**、**LocalDateTime**、**Instant**和**ZonedDateTime**等新类。



## 3.1 从字符串到数值

### 问题

把一个字符串转换成一个Scala的数值类型。



### 解决方法

可以在**String**上使用**toXxx**方法：

```scala
    "1".toByte   // Byte = 1
    "1".toShort  // Short = 1
    "1".toInt    // Int = 1
    "1".toLong   // Long = 1
    "1".toFloat  // Float = 1.0
    "1".toDouble // Double = 1.0
```

需要注意的是，这些方法可能会抛出Java的**NumberFormatException**：

```scala
    "hello!".toInt // java.lang.NumberFormatException
```

因此，使用**to*Option**方法也是一个不错的选择，它的作用是在转换成功时返回**Some**，转换失败时返回**None**：

```scala
    "1".toByteOption   // Option[Byte] = Some(1)
    "1".toShortOption  // Option[Short] = Some(1)
    "1".toIntOption    // Option[Int] = Some(1)
    "1".toLongOption   // Option[Long] = Some(1)
    "1".toFloatOption  // Option[Float] = Some(1.0)
    "1".toDoubleOption // Option[Double] = Some(1.0)
    "one".toIntOption  // Option[Int] = None
```

**BigInt**和**BigDecimal**实例也可以通过字符串创建，并且也有可能抛出**NumberFormatException**：

```scala
    val b = BigInt("1") // BigInt = 1
    val b = BigDecimal("1.234") // BigDecimal = 1.234

    val b = BigInt("yo") // NumberFormatException
    val b = BigDecimal("dude!") // NumberFormatException
```



#### 处理基数和根

如果想要处理**十进制**以外的计算，使用Scala的**toInt**方法是不支持传入**进制**的参数的。此时可以使用**java.lang.Integer**类的**parseInt**方法，例如：

```scala
    Integer.parseInt("1", 2)   // Int = 1
    Integer.parseInt("10", 2)  // Int = 2
    Integer.parseInt("100", 2) // Int = 4
    Integer.parseInt("1", 8)   // Int = 1
    Integer.parseInt("10", 8)  // Int = 8
```

当然，参考2.11节，也可以使用Scala中的自定义扩展方法来解决这个问题：

```scala
    extension(s: String) {
      def toInt(radix: Int) = java.lang.Integer.parseInt(s, radix)
    }

    "10".toInt(2) // Int = 2
```



### 讨论

如果用过Java把**字符串**转换成数值类型，那么一定会对**NumberFormatException**很熟悉。然而，Scala中并没有受检异常，所以可以用其他方式来处理这个异常。

首先，没有必要在一个Scala方法上声明可能抛出的异常，因此下面的方法定义是合法的：

```scala
    // you're not required to declare "throws NumberFormatException"
    def makeInt(s: String) = s.toInt
```

#### 编写一个纯函数

然而，在函数式编程（FP）中，最好永远不要定义上述的方法。如前所述，这种方法可能会使调用方的代码短路抛出异常。（如果不希望其他开发人员定义这种方法给你使用，你最好也不要对其他开发人员这样做。）相反，纯函数 ***总是*** 返回其签名所显示的类型。因此，在FP中，可以这样写这个函数：

```scala
    def makeInt(s: String): Option[Int] =
      try
        Some(s.toInt)
      catch
        case e: NumberFormatException => None
```

该函数的返回值类型是**Option[Int]**，这意味着如果给它一个 **“10”**，它将返回一个**Some(10)**，如果给它一个 **“Yo”**，它将返回一个**None**。此函数相当于上述解决办法中的**toIntOption**，该方法在Scala2.13中引入。



TODO（松鼠图）

#### 简化makeInt方法

虽然上述代码 **makeInt(s: String): Option[Int]** 已经比较完美了，但是还可以进一步精简，如下所示：

```scala
    import scala.util.Try
    def makeInt(s: String): Option[Int] = Try(s.toInt).toOption
```

这两种不同定义的**makeInt**方法都会返回 **Some[Int]** 或者 **None**：

```scala
    makeInt("a") // None
    makeInt("1") // Some(1)
    makeInt("2147483647") // Some(2147483647)
    makeInt("2147483648") // None
```

如果更加喜欢**Try**的返回值类型，可以这样做：

```scala
    import scala.util.{Try, Success, Failure}
    def makeInt(s: String): Try[Int] = Try(s.toInt)
```

使用**Try**的优势是当程序发生异常，可以从返回的**Failure**对象中获取具体的异常：

```scala
    makeInt("1") // Success(1)
    makeInt("a") // Failure(java.lang.NumberFormatException: For input string: "a")
```

#### 声明方法的异常

如果期望声明方法会抛出异常，可以通过 **@throws** 注解来标注方法：

```scala
    @throws(classOf[NumberFormatException])
    def makeInt(s: String) = s.toInt
```

如果在Java代码调用这个方法，这个注解式异常声明是必须的。22.7节说明了这点。



### 另见

* 24.6节，更详细讲解了**Option**、**Some**和**None**的使用。



## 3.2 数值类型转换

### 问题

把一个数值类型转换成另一个数值类型，比如把**Int**转成**Double**、**Double**转成**Int**、或者涉及到**BigInt**和**BigDecimal**的转换。



### 解决方法

数值类型通常可以使用一系列**toXXX**方法进行类型转换，包括**toByte**、**toChar**、**toDouble**、**toFloat**、**toInt**、**toLong**和**toShort**方法。这些方法由**RichDouble**、**RichInt**、**RichFloat**等类添加到基本数值类型中，且自动被类**Scala.Predef**所引入。

在关于[Scala统一类型的页面](https://oreil.ly/C7Id7)（ *https://oreil.ly/C7Id7* ），数值类型可以很容易按照图3-2所示的方向进行转换。

![](./images/ch3/Figure3-2.jpg)

                           *图3-2：数值类型简单类型转换方向*



一些简单的转换示例：

```scala
    val b: Byte = 1
    b.toShort   // Short = 1
    b.toInt     // Int = 1
    b.toLong    // Long = 1
    b.toFloat   // Float = 1.0
    b.toDouble  // Double = 1.0
```

当按照图示转换方向时，操作很简单。当然也可以按照相反的方向进行转换，如下所示：

```scala
    val d = 100.0 // Double = 100.0
    d.toFloat // Float = 100.0
    d.toLong // Long = 1
    d.toInt // Int = 100
    d.toShort // Short = 100
    d.toByte // Byte = 10000
```

然而，按照相反的方向进行转换时，需要注意所产生一些问题：

```scala
    val d = Double.MaxValue // 1.7976931348623157E308

    // intentional error: don’t do these things
    d.toFloat // Float = Infinity
    d.toLong // Long = 9223372036854775807
    d.toInt // Int = 2147483647
    d.toShort // Short = -1
    d.toByte // Byte = -1
```

因此，在尝试使用这些转换方法时，最好仔细检查一下转换是否合法：

```scala
    val d: Double = 65_535.0
    d.isValidByte // false (Byte ranges from -128 to 127)
    d.isValidChar // true (Char ranges from 0 to 65,535)
    d.isValidShort // false (Short ranges from -32,768 to 32,767)
    d.isValidInt // true (Int ranges from -2,147,483,648 to 2,147,483,647)
```

注意**Double**类型没有以下检查方法：

```scala
    d.isValidFloat // not a member of Double
    d.isValidLong // not a member of Double
```

另外请注意，当使用这些方法时，如果**Double**含有非零小数部分，**Int**/**Short**/**Byte**的测试将会失败：

```scala
    val d = 1.5 // Double = 1.5
    d.isValidInt // false
    d.isValidShort // false
    d.isValidByte // false
```

#### asInstanceOf

根据使用需求，也可以按照类型转换方向使用**asInstanceOf**方法：

```scala
    val b: Byte = 1 // Byte = 1
    b.asInstanceOf[Short] // Short = 1
    b.asInstanceOf[Int] // Int = 1
    b.asInstanceOf[Long] // Long = 1
    b.asInstanceOf[Float] // Float = 1.0
    b.asInstanceOf[Double] // Double = 1.0
```



## 讨论

由于所有数值类型都是类（而不是基本类型），所以**BigInt**和**BigDecimal**的使用方式也类似。以下示例展示了如何跟数值类型一起使用。

#### BigInt

**BigInt**的构造函数含有9中不同的重载方式，包括**Int**、**Long**和**String**等入参：

```scala
    val i: Int = 101
    val l: Long = 102
    val s = "103"
    
    val b1 = BigInt(i) // BigInt = 101
    val b2 = BigInt(l) // BigInt = 102
    val b3 = BigInt(s) // BigInt = 103
```

**BigInt**也包含**isValidXxx**和**toXxx**方法来协助进行数值类型的转换：

* isValidByte、toByte

* isValidChar、toChar

* isValidDouble、toDouble

* isValidFloat、toFloat

* isValidInt、toInt

* isValidLong、toLong

* isValidShort、toShort

#### BigDecimal

同样，**BigDecimal**构造函数也含有多种不同的重载方式，包括如下：

```scala
    BigDecimal(100)
    BigDecimal(100L)
    BigDecimal(100.0)
    BigDecimal(100F)
    BigDecimal("100")
    BigDecimal(BigInt(100))
```

**BigDecimal**同样包含**isValidXxx**和**toXxx**方法。它还包含**to*Exact**方法，使用方式如下：

```scala
    BigDecimal(100).toBigIntExact // Some(100)
    BigDecimal(100.5).toBigIntExact // None
    BigDecimal(100).toIntExact // Int = 100
    BigDecimal(100.5).toIntExact // java.lang.ArithmeticException: ↵
                                 // (Rounding necessary)
    BigDecimal(100.5).toLongExact // java.lang.ArithmeticException
    BigDecimal(100.5).toByteExact // java.lang.ArithmeticException
    BigDecimal(100.5).toShortExact // java.lang.ArithmeticException
```

参考Scaladoc查看更多关于**BigInt**（https://oreil.ly/PGdIE）和**BigDecimal**（https://

oreil.ly/E6Lsk）的使用方法。



## 3.3 重载默认数值类型

### 问题

当使用隐式类型声明一个变量时，Scala会根据变量的具体数值自动地把数值类型赋值给这个变量，并且可以重载其默认的类型。



### 解决方法

如果把1赋给一个变量，并且没有显示声明类型，Scala会把它的类型设置为**Int**：

```scala
    scala> val a = 1
    a: Int = 1
```

因此，如果想显示声明类型，可以这样：

```scala
    val a: Byte = 1 // Byte = 1
    val a: Short = 1 // Short = 1
    val a: Int = 1 // Int = 1
    val a: Long = 1 // Long = 1
    val a: Float = 1 // Float = 1.0
    val a: Double = 1 // Double = 1.0
```

虽然这种样式更让人喜欢，但在表达式末尾指定类型也是合法的：

```scala
    val a = 0: Byte
    val a = 0: Int
    val a = 0: Short
    val a = 0: Double
    val a = 0: Float
```

对于long、double和float，也可以使用以下声明方式：

```scala
    val a = 1l // Long = 1
    val a = 1L // Long = 1
    val a = 1d // Double = 1.0
    val a = 1D // Double = 1.0
    val a = 1f // Float = 1.0
    val a = 1F // Float = 1.0
```

通过在数字前面加一个前导**0x**或**0X**来定义一个十六进制值，并且可以把这个值保存为**Int**或者**Long**类型：

```scala
    val a = 0x20 // Int = 32
    val a = 0x20L // Long = 32
```



### 讨论

创建对象实例时了解这种定义变量的方式很有帮助，其基本语法如下：

```scala
    // general case
    var [name]: [Type] = [initial value]

    // example
    var a: Short = 0
```

这种格式在类初始化变量时非常有用：

```scala
    class Foo:
      var a: Short = 0 // specify a default value
      var b: Short = _ // defaults to 0
      var s: String = _ // defaults to null
```

可以看到，在初始化变量时，可以使用下划线作为占位符。这在创建类成员变量时是可以的，但是在其他情况下，如在方法中定义变量是无效的。对于数值类型，这也不算一个问题，可以赋值为0。但是对于其他类型，可以采用这种方式：

```scala
    var name = null.asInstanceOf[String]
```

但通常的警告是：不要使用null值。最好使用**Option/Some/None**模式，在一些优秀的Scala库和框架中，如Play Framework，这种模式非常常见。在24.5节和24.6节，对这种方式有更深入的讨论。



---

类型归属：

在一些不常见的情形需要使用类型归属（type ascription），Stack Overflow “What Is the Purpose of Type Ascriptions in Scala?”（https://oreil.ly/y9eQz）上有个例子讲解了把String向上转成Object的好处，实现方式如下：

```scala
    val s = "Hala" // s: String = Hala
    val o = s: Object // o: Object = Hala
```

如上所示，这个技巧和本节很类似。向上转换（upcast）也被称为类型归属，Scala官方文档（https://oreil.ly/eWyge）对其的描述如下：

“类型归属是一种发生在编译时，为了满足类型校验器的类型的向上转换。这种情况并不常见，但确实会发生。其中最常见的一种场景是向一个接受变参（varargs）的方法传入一个**Seq**类，将 _* 的类型进行归属。”

---









## 3.4 替代++和−−

### 问题

像其他语言里那样使用++或者--来递增或者递减一个变量，但是Scala里没有这样的操作符。



### 解决方法

由于声明为**val**的字段是不可变的，他们不能递增或递减，但是声明为**var**的**Int**类型变量是可以通过+=和-=方法来修改的：

```scala
    var a = 1 // a = 1
    a += 1 // a = 2
    a −= 1 // a = 1
```

同样，可以通过类似的方法对变量进行乘法和除法操作：

```scala
    var i = 1 // i = 1
    i *= 4 // i = 4
    i /= 2 // i = 2
```

如果想在一个被声明为**val**的字段上调用此方法，会得到一个编译时错误：

```scala
    scala> val x = 1
    x: Int = 1
    
    scala> x += 1
    <console>:9: error: value += is not a member of Int
                 x += 1
                   ^
```



### 讨论

**这种**方式的另外一个优势就是可以在除**Int**以外的其他类型上调用这些操作方法，例如在**Double**和**Float**类上：

```scala
    var d = 1.2 // Double = 1.2
    d += 1 // 2.2
    d *= 2 // 4.4
    d /= 2 // 2.2
    
    var f = 1.2F // Float = 1.2
    f += 1 // 2.2
    f *= 2 // 4.4
    f /= 2 // 2.2
```



----

注意：上面提到，+=、-=、*=和/=并不是操作符，而是方法。这种把功能实现为方法而非操作符的方式是Scala里一贯的模式。例如，Actors就是通过库而非语言本身实现的。

----



## 3.5 浮点数的比较

### 问题

比较两个浮点数的值，然而，和其他语言一样，两个应该相等的浮点数有可能实际上是不相等的。



### 解决方法





### 讨论







- [ ]  3.6 Handling Large Numbers

- [ ]  3.7 Generating Random Numbers

- [ ]  3.8 Formatting Numbers and Currency

- [ ]  3.9 Creating New Date and Time Instances

- [ ]  3.10 Calculating the Difference Between Two Dates

- [ ]  3.11 Formatting Dates

- [ ]  3.12 Parsing Strings into Dates
