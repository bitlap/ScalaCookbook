# 3. 数值和日期

本章涵盖了Scala数值类型，以及Java 8引入的日期和时间API的使用方法。


在Scala中，**Byte**、**Short**、**Int**、**Long**和**Char**类型被称为*整数类型*，因为它们由整型数字表示。整数类型以及**Double**和**Float**组成了Scala的*数值类型*。与被称为“非数值类型”的**Unit**和**Boolean**一样，这些数值类型都继承**AnyVal**特质（trait）。在[Scala页面](https://oreil.ly/C7Id7)（ *https://oreil.ly/C7Id7* ）关于统一类型的讨论中，这9种类型都被称为*预定义值类型*，并且不能为空。



预定义值类型与**AnyVal**和**Any**（以及**Nothing**）的关系如图3-1所示：

* 所有的数值类型都继承自**AnyVal**。

* Scala类层次结构中的所有其他类型都继承自**AnyRef**。

<img title="" src="./images/ch3/Figure3-1.jpg" alt="" data-align="center" width="783">

                       *图3-1：所有预定义的数值类型都继承自* ***AnyVal***



如表3-1所示，Scala的数值类型与Java中对应的基本类型有着相同的数值范围。



表3-1：Scala中数值类型的数值范围：

| 类型         | 描述                | 范围                     |
| ---------- | ----------------- | ---------------------- |
| **Char**   | 16位无符号Unicode字符   | 0~65535                |
| **Byte**   | 8位有符号整数           | -128~127               |
| **Short**  | 16位有符号整数          | -32768~32767           |
| **Int**    | 32位有符号整数          | -2147483648~2147483647 |
| **Long**   | 64位有符号整数          | -2^63~2^63-1           |
| **Float**  | 32位IEEE 754单精度浮点数 | 见下文                    |
| **Double** | 64位IEEE 754双精度浮点数 | 见下文                    |

除此之外，**Boolean**可以为**true**或者**false**。



如果想知道数据范围的精确值，但手头没有这本书，可以在Scala REPL中查看：

```scala
    Char.MinValue.toInt // 0
    Char.MaxValue.toInt // 65535
    Byte.MinValue       // -128
    Byte.MaxValue       // +127
    Short.MinValue      // −32768
    Short.MaxValue      // +32767
    Int.MinValue        // −2147483648
    Int.MaxValue        // +2147483647
    Long.MinValue       // -9,223,372,036,854,775,808
    Long.MaxValue       // +9,223,372,036,854,775,807
    Float.MinValue      // −3.4028235e38
    Float.MaxValue      // +3.4028235e38
    Double.MinValue     // -1.7976931348623157e308
    Double.MaxValue     // +1.7976931348623157e308
```

除了这些基本数值类型之外，**BigInt**和**BigDecimal**在本章后续部分都会降到。



### 数值常量中的下划线

Scala 2.13 引入了在数值常量中使用下划线的功能：

```scala
    // Int
    val x = 1_000
    val x = 100_000
    val x = 1_000_000

    // Long (也可以使用小写的‘l’, 但看起来容易跟数字’1‘混淆)
    val x = 1_000_000L

    // Double
    val x = 1_123.45
    val x = 1_123.45D
    val x = 1_123.45d
    val x = 1_234e2 // 123400.0

    // Float
    val x = 3_456.7F
    val x = 3_456.7f
    val x = 1_234e2F

    // BigInt and BigDecimal
    val x: BigInt = 1_000_000
    val x: BigDecimal = 1_234.56
```



带下划线的数值常量可以使用在所有常用的地方：

```scala
    val x = 1_000 + 1

    if x > 1_000 && x < 1_000_000 then println(x)

    x match
       case 1_000 => println("got 1,000")
       case _     => println("got something else")

    for
       i <- 1 to 1_000
       if i > 999
    do
       println(i)
```



目前带下划线的数值常量不能使用的一个地方是从**String**转换为数字类型：

```scala
    Integer.parseInt("1_000") // NumberFormatException
    "1_000".toInt             // NumberFormatException
```



### 复数

除了Scala自带的math类库，如果需要其他更强大的数学运算能力，可以了解一下[Spire](https://typelevel.org/spire)（ **https://typelevel.org/spire** ），它包含了Rational、Complex和Real等更高级的数学概念。



### 日期和时间

本章最后几节介绍了Java 8引入的日期和时间API，并展示了如何使用**LocalDate**、**LocalTime**、**LocalDateTime**、**Instant**和**ZonedDateTime**等新类。



## 3.1 从字符串到数值

### 问题

把一个字符串转换成一个Scala的数值类型。



### 解决方法

可以在**String**上使用**toXxx**方法：

```scala
    "1".toByte   // Byte = 1
    "1".toShort  // Short = 1
    "1".toInt    // Int = 1
    "1".toLong   // Long = 1
    "1".toFloat  // Float = 1.0
    "1".toDouble // Double = 1.0
```

需要注意的是，这些方法可能会抛出Java的**NumberFormatException**：

```scala
    "hello!".toInt // java.lang.NumberFormatException
```

因此，使用**to*Option**方法也是一个不错的选择，它的作用是在转换成功时返回**Some**，转换失败时返回**None**：

```scala
    "1".toByteOption   // Option[Byte] = Some(1)
    "1".toShortOption  // Option[Short] = Some(1)
    "1".toIntOption    // Option[Int] = Some(1)
    "1".toLongOption   // Option[Long] = Some(1)
    "1".toFloatOption  // Option[Float] = Some(1.0)
    "1".toDoubleOption // Option[Double] = Some(1.0)
    "one".toIntOption  // Option[Int] = None
```

**BigInt**和**BigDecimal**实例也可以通过字符串创建，并且也有可能抛出**NumberFormatException**：

```scala
    val b = BigInt("1") // BigInt = 1
    val b = BigDecimal("1.234") // BigDecimal = 1.234

    val b = BigInt("yo") // NumberFormatException
    val b = BigDecimal("dude!") // NumberFormatException
```



#### 处理基数和根

如果想要处理**十进制**以外的计算，使用Scala的**toInt**方法是不支持传入**进制**的参数的。此时可以使用**java.lang.Integer**类的**parseInt**方法，例如：

```scala
    Integer.parseInt("1", 2)   // Int = 1
    Integer.parseInt("10", 2)  // Int = 2
    Integer.parseInt("100", 2) // Int = 4
    Integer.parseInt("1", 8)   // Int = 1
    Integer.parseInt("10", 8)  // Int = 8
```

当然，参考2.11节，也可以使用Scala中的自定义扩展方法来解决这个问题：

```scala
    extension(s: String) {
      def toInt(radix: Int) = java.lang.Integer.parseInt(s, radix)
    }

    "10".toInt(2) // Int = 2
```



### 讨论

如果用过Java把**字符串**转换成数值类型，那么一定会对**NumberFormatException**很熟悉。然而，Scala中并没有受检异常，所以可以用其他方式来处理这个异常。

首先，没有必要在一个Scala方法上声明可能抛出的异常，因此下面的方法定义是合法的：

```scala
    // you're not required to declare "throws NumberFormatException"
    def makeInt(s: String) = s.toInt
```

#### 编写一个纯函数

然而，在函数式编程（FP）中，最好永远不要定义上述的方法。如前所述，这种方法可能会使调用方的代码短路抛出异常。（如果不希望其他开发人员定义这种方法给你使用，你最好也不要对其他开发人员这样做。）相反，纯函数 ***总是*** 返回其签名所显示的类型。因此，在FP中，可以这样写这个函数：

```scala
    def makeInt(s: String): Option[Int] =
      try
        Some(s.toInt)
      catch
        case e: NumberFormatException => None
```

该函数的返回值类型是**Option[Int]**，这意味着如果给它一个 **“10”**，它将返回一个**Some(10)**，如果给它一个 **“Yo”**，它将返回一个**None**。此函数相当于上述解决办法中的**toIntOption**，该方法在Scala2.13中引入。



TODO（松鼠图）

#### 简化makeInt方法

虽然上述代码 **makeInt(s: String): Option[Int]** 已经比较完美了，但是还可以进一步精简，如下所示：

```scala
    import scala.util.Try
    def makeInt(s: String): Option[Int] = Try(s.toInt).toOption
```

这两种不同定义的**makeInt**方法都会返回 **Some[Int]** 或者 **None**：

```scala
    makeInt("a") // None
    makeInt("1") // Some(1)
    makeInt("2147483647") // Some(2147483647)
    makeInt("2147483648") // None
```

如果更加喜欢**Try**的返回值类型，可以这样做：

```scala
    import scala.util.{Try, Success, Failure}
    def makeInt(s: String): Try[Int] = Try(s.toInt)
```

使用**Try**的优势是当程序发生异常，可以从返回的**Failure**对象中获取具体的异常：

```scala
    makeInt("1") // Success(1)
    makeInt("a") // Failure(java.lang.NumberFormatException: For input string: "a")
```

#### 声明方法的异常

如果期望声明方法会抛出异常，可以通过 **@throws** 注解来标注方法：

```scala
    @throws(classOf[NumberFormatException])
    def makeInt(s: String) = s.toInt
```

如果在Java代码调用这个方法，这个注解式异常声明是必须的。22.7节说明了这点。



### 另见

* 24.6节，更详细讲解了**Option**、**Some**和**None**的使用。



## 3.2 数值类型转换

### 问题

把一个数值类型转换成另一个数值类型，比如把**Int**转成**Double**、**Double**转成**Int**、或者涉及到**BigInt**和**BigDecimal**的转换。



### 解决方法

数值类型通常可以使用一系列**toXXX**方法进行类型转换，包括**toByte**、**toChar**、**toDouble**、**toFloat**、**toInt**、**toLong**和**toShort**方法。这些方法由**RichDouble**、**RichInt**、**RichFloat**等类添加到基本数值类型中，且自动被类**Scala.Predef**所引入。

在关于[Scala统一类型的页面](https://oreil.ly/C7Id7)（ *https://oreil.ly/C7Id7* ），数值类型可以很容易按照图3-2所示的方向进行转换。

![](./images/ch3/Figure3-2.jpg)

                           *图3-2：数值类型简单类型转换方向*



一些简单的转换示例：

```scala
    val b: Byte = 1
    b.toShort   // Short = 1
    b.toInt     // Int = 1
    b.toLong    // Long = 1
    b.toFloat   // Float = 1.0
    b.toDouble  // Double = 1.0
```

当按照图示转换方向时，操作很简单。当然也可以按照相反的方向进行转换，如下所示：

```scala
    val d = 100.0 // Double = 100.0
    d.toFloat // Float = 100.0
    d.toLong // Long = 1
    d.toInt // Int = 100
    d.toShort // Short = 100
    d.toByte // Byte = 10000
```

然而，按照相反的方向进行转换时，需要注意所产生一些问题：

```scala
    val d = Double.MaxValue // 1.7976931348623157E308

    // intentional error: don’t do these things
    d.toFloat // Float = Infinity
    d.toLong // Long = 9223372036854775807
    d.toInt // Int = 2147483647
    d.toShort // Short = -1
    d.toByte // Byte = -1
```

因此，在尝试使用这些转换方法时，最好仔细检查一下转换是否合法：

```scala
    val d: Double = 65_535.0
    d.isValidByte // false (Byte ranges from -128 to 127)
    d.isValidChar // true (Char ranges from 0 to 65,535)
    d.isValidShort // false (Short ranges from -32,768 to 32,767)
    d.isValidInt // true (Int ranges from -2,147,483,648 to 2,147,483,647)
```

注意**Double**类型没有以下检查方法：

```scala
    d.isValidFloat // not a member of Double
    d.isValidLong // not a member of Double
```

另外请注意，当使用这些方法时，如果**Double**含有非零小数部分，**Int**/**Short**/**Byte**的测试将会失败：

```scala
    val d = 1.5 // Double = 1.5
    d.isValidInt // false
    d.isValidShort // false
    d.isValidByte // false
```

#### asInstanceOf

根据使用需求，也可以按照类型转换方向使用**asInstanceOf**方法：

```scala
    val b: Byte = 1 // Byte = 1
    b.asInstanceOf[Short] // Short = 1
    b.asInstanceOf[Int] // Int = 1
    b.asInstanceOf[Long] // Long = 1
    b.asInstanceOf[Float] // Float = 1.0
    b.asInstanceOf[Double] // Double = 1.0
```



### 讨论

由于所有数值类型都是类（而不是基本类型），所以**BigInt**和**BigDecimal**的使用方式也类似。以下示例展示了如何跟数值类型一起使用。

#### BigInt

**BigInt**的构造函数含有9中不同的重载方式，包括**Int**、**Long**和**String**等入参：

```scala
    val i: Int = 101
    val l: Long = 102
    val s = "103"
    
    val b1 = BigInt(i) // BigInt = 101
    val b2 = BigInt(l) // BigInt = 102
    val b3 = BigInt(s) // BigInt = 103
```

**BigInt**也包含**isValidXxx**和**toXxx**方法来协助进行数值类型的转换：

* isValidByte、toByte

* isValidChar、toChar

* isValidDouble、toDouble

* isValidFloat、toFloat

* isValidInt、toInt

* isValidLong、toLong

* isValidShort、toShort

#### BigDecimal

同样，**BigDecimal**构造函数也含有多种不同的重载方式，包括如下：

```scala
    BigDecimal(100)
    BigDecimal(100L)
    BigDecimal(100.0)
    BigDecimal(100F)
    BigDecimal("100")
    BigDecimal(BigInt(100))
```

**BigDecimal**同样包含**isValidXxx**和**toXxx**方法。它还包含**to*Exact**方法，使用方式如下：

```scala
    BigDecimal(100).toBigIntExact // Some(100)
    BigDecimal(100.5).toBigIntExact // None
    BigDecimal(100).toIntExact // Int = 100
    BigDecimal(100.5).toIntExact // java.lang.ArithmeticException: ↵
                                 // (Rounding necessary)
    BigDecimal(100.5).toLongExact // java.lang.ArithmeticException
    BigDecimal(100.5).toByteExact // java.lang.ArithmeticException
    BigDecimal(100.5).toShortExact // java.lang.ArithmeticException
```

参考Scaladoc查看更多关于**BigInt**（https://oreil.ly/PGdIE）和**BigDecimal**（https://

oreil.ly/E6Lsk）的使用方法。



## 3.3 重载默认数值类型

### 问题

当使用隐式类型声明一个变量时，Scala会根据变量的具体数值自动地把数值类型赋值给这个变量，并且可以重载其默认的类型。



### 解决方法

如果把1赋给一个变量，并且没有显示声明类型，Scala会把它的类型设置为**Int**：

```scala
    scala> val a = 1
    a: Int = 1
```

因此，如果想显示声明类型，可以这样：

```scala
    val a: Byte = 1 // Byte = 1
    val a: Short = 1 // Short = 1
    val a: Int = 1 // Int = 1
    val a: Long = 1 // Long = 1
    val a: Float = 1 // Float = 1.0
    val a: Double = 1 // Double = 1.0
```

虽然这种样式更让人喜欢，但在表达式末尾指定类型也是合法的：

```scala
    val a = 0: Byte
    val a = 0: Int
    val a = 0: Short
    val a = 0: Double
    val a = 0: Float
```

对于long、double和float，也可以使用以下声明方式：

```scala
    val a = 1l // Long = 1
    val a = 1L // Long = 1
    val a = 1d // Double = 1.0
    val a = 1D // Double = 1.0
    val a = 1f // Float = 1.0
    val a = 1F // Float = 1.0
```

通过在数字前面加一个前导**0x**或**0X**来定义一个十六进制值，并且可以把这个值保存为**Int**或者**Long**类型：

```scala
    val a = 0x20 // Int = 32
    val a = 0x20L // Long = 32
```



### 讨论

创建对象实例时了解这种定义变量的方式很有帮助，其基本语法如下：

```scala
    // general case
    var [name]: [Type] = [initial value]

    // example
    var a: Short = 0
```

这种格式在类初始化变量时非常有用：

```scala
    class Foo:
      var a: Short = 0 // specify a default value
      var b: Short = _ // defaults to 0
      var s: String = _ // defaults to null
```

可以看到，在初始化变量时，可以使用下划线作为占位符。这在创建类成员变量时是可以的，但是在其他情况下，如在方法中定义变量是无效的。对于数值类型，这也不算一个问题，可以赋值为0。但是对于其他类型，可以采用这种方式：

```scala
    var name = null.asInstanceOf[String]
```

但通常的警告是：不要使用null值。最好使用**Option/Some/None**模式，在一些优秀的Scala库和框架中，如Play Framework，这种模式非常常见。在24.5节和24.6节，对这种方式有更深入的讨论。



---

类型归属：

在一些不常见的情形需要使用类型归属（type ascription），Stack Overflow “What Is the Purpose of Type Ascriptions in Scala?”（https://oreil.ly/y9eQz）上有个例子讲解了把String向上转成Object的好处，实现方式如下：

```scala
    val s = "Hala" // s: String = Hala
    val o = s: Object // o: Object = Hala
```

如上所示，这个技巧和本节很类似。向上转换（upcast）也被称为类型归属，Scala官方文档（https://oreil.ly/eWyge）对其的描述如下：

“类型归属是一种发生在编译时，为了满足类型校验器的类型的向上转换。这种情况并不常见，但确实会发生。其中最常见的一种场景是向一个接受变参（varargs）的方法传入一个**Seq**类，将 _* 的类型进行归属。”

---









## 3.4 替代++和−−

### 问题

像其他语言里那样使用++或者--来递增或者递减一个变量，但是Scala里没有这样的操作符。



### 解决方法

由于声明为**val**的字段是不可变的，他们不能递增或递减，但是声明为**var**的**Int**类型变量是可以通过+=和-=方法来修改的：

```scala
    var a = 1 // a = 1
    a += 1 // a = 2
    a −= 1 // a = 1
```

同样，可以通过类似的方法对变量进行乘法和除法操作：

```scala
    var i = 1 // i = 1
    i *= 4 // i = 4
    i /= 2 // i = 2
```

如果想在一个被声明为**val**的字段上调用此方法，会得到一个编译时错误：

```scala
    scala> val x = 1
    x: Int = 1
    
    scala> x += 1
    <console>:9: error: value += is not a member of Int
                 x += 1
                   ^
```



### 讨论

**这种**方式的另外一个优势就是可以在除**Int**以外的其他类型上调用这些操作方法，例如在**Double**和**Float**类上：

```scala
    var d = 1.2 // Double = 1.2
    d += 1 // 2.2
    d *= 2 // 4.4
    d /= 2 // 2.2
    
    var f = 1.2F // Float = 1.2
    f += 1 // 2.2
    f *= 2 // 4.4
    f /= 2 // 2.2
```



----

注意：上面提到，+=、-=、*=和/=并不是操作符，而是方法。这种把功能实现为方法而非操作符的方式是Scala里一贯的模式。例如，Actors就是通过库而非语言本身实现的。

----



## 3.5 浮点数的比较

### 问题

比较两个浮点数的值，然而，和其他语言一样，两个应该相等的浮点数有可能实际上是不相等的。



### 解决方法

刚开始接触浮点数时，可以知道**0.1**加**0.1**等于**0.2**：

```scala
    scala> 0.1 + 0.1
    res0: Double = 0.2
```

但是**0.1**加**0.1**并不精确等于**0.3**：

```scala
    scala> 0.1 + 0.2
    res1: Double = 0.30000000000000004
```

这个微小的误差使浮点数比较成了一个问题：

```scala
    val a = 0.3       // Double = 0.3
    val b = 0.1 + 0.2 // Double = 0.30000000000000004
    a == b            // false
```

因此，可以定义能容忍一定误差的浮点数比较的函数。下面用*近似相等*的方法来进行演示：

```scala
    import scala.annotation.targetName
    @targetName("approxEqual")
    def ~=(x: Double, y: Double, tolerance: Double): Boolean =
      if (x - y).abs < tolerance then true else false
```

可以这样使用该方法：

```scala
    val a = 0.3        // 0.3
    val b = 0.1 + 0.2  // 0.30000000000000004
    ~=(a, b, 0.0001)   // true
    ~=(b, a, 0.0001)   // true
```



### 讨论

在上述解决方法中 **@targetName** 注解是可选的，但是推荐在使用符号的方法中使用：

* 有助于提高跟其他不支持使用符号方法名的语言之间的互操作性。

* 这使得堆栈分析变得更容易，因为其中使用的是注解提供的方法名，而不是方法的符号名。

* 注解中的名称也会在文档中标注为符号名称的一个可选的别名。



#### 扩展方法

在8.9节中所示，可以在**Double**类上定义一个扩展方法。假设可容忍的误差是**0.5**，可以这样定义扩展方法：

```scala
    extension (x: Double)
      def ~=(y: Double): Boolean = (x - y).abs < 0.5
```

还可以使用条件判断的方式：

```scala
    extension (x: Double)
      def ~=(y: Double): Boolean =
      if (x - y).abs < 0.5 then true else false
```

在任何时候，都可以在两个**Double**值上进行使用：

```scala
    if a ~= b then ...
```

这会让代码更具有可读性。然而，当硬编码容忍误差的值时，做好将该值定义为给定**x**的百分比：

```scala
    extension (x: Double)
      def ~=(y: Double): Boolean =
      // allow a +/- 10% variance
      val xHigh = if x > 0 then x*1.1 else x*0.9
      val xLow = if x > 0 then x*0.9 else x*1.1
      if y >= xLow && y <= xHigh then true else false
```

或者，将**容忍误差值**定义为方法入参：

```scala
    extension (x: Double)
      def ~=(y: Double, tolerance: Double): Boolean =
      if (x - y).abs < tolerance then true else false
```

最后，可以这样使用该扩展方法：

```scala
    1.0 ~= (1.1, .2) // true
    1.0 ~= (0.9, .2) // true

    1.0 ~= (1.21, .2) // false
    1.0 ~= (0.79, .2) // false
```

### 另见

* 所有计算机科学家应该知道的关于浮点数算法的知识（https://oreil.ly/K52zn）。

* 浮点数精度问题（https://oreil.ly/PgxrB）。

* 任意精度算法（https://oreil.ly/PPdkg）。



## 3.6 Handling Large Numbers

### 问题

编写一个需要处理非常大的整数或者浮点数的程序。



### 解决方法

如果**Long**和**Double**无法满足“大”的需求，可以使用Scala **BigInt**和**BigDecimal**类：

```scala
    val bi = BigInt(1234567890) // BigInt = 1234567890
    val bd = BigDecimal(123456.789) // BigDecimal = 123456.789
    
    // 数值常量中使用下划线
    val bi = BigInt(1_234_567_890) // BigInt = 1234567890
    val bd = BigDecimal(123_456.789) // BigDecimal = 123456.789
```

**BigInt**和**BigDecimal**是Java **BigInteger**和**BigDecimal**类的封装，并且支持Scala普通数值类型的所有操作符：

```scala
    bi + bi        // BigInt = 2469135780
    bi * bi        // BigInt = 1524157875019052100
    bi / BigInt(2) // BigInt = 617283945
```

可以把它们转换成其他数值类型：

```scala
    // bad conversions
    bi.toByte  // -46
    bi.toChar  // ˒
    bi.toShort // 722

    // correct conversions
    bi.toInt    // 1234567891
    bi.toLong   // 1234567891
    bi.toFloat  // 1.23456794E9
    bi.toDouble // 1.234567891E9
```

为避免错误，可以在转换前测试下是否能够转换：

```scala
    bi.isValidByte  // false
    bi.isValidChar  // false
    bi.isValidShort // false
    bi.isValidInt   // true
    bi.isValidLong  // true
```

**BigInt**也可以转换成**Array[Byte]**:

```scala
bi.toByteArray // Array[Byte] = Array(73, -106, 2, -46)
```



### 讨论

在使用**BigInt**或者**BigDecimal**之前，可以检查下**Long**和**Double**能处理的最小和最大值：

```scala
    Long.MinValue   // -9,223,372,036,854,775,808
    Long.MaxValue   // +9,223,372,036,854,775,807
    Double.MinValue // -1.7976931348623157e308
    Double.MaxValue // +1.7976931348623157e308
```

根据需要，也可以使用普通数值类型的**PositiveInfinity**和**NegativeInfinity**：

```scala
    scala> 1.7976931348623157E308 > Double.PositiveInfinity
    res0: Boolean = false
```



TODO（松鼠图）

#### BigDecimal经常在货币中使用

**BigDecimal**通常用于表示货币，因为它提供了对舍入行为的控制。如之前的章节所示，`$0.10`加`$0.20`不能精确表示`$0.30`：

```scala
    0.10 + 0.20 // Double = 0.30000000000000004
```

但是**BigDecimal**避免了这个问题：

```scala
    BigDecimal(0.10) + BigDecimal(0.20) // BigDecimal = 0.3
```

尽管如此，在**BigDecimal**构造函数中使用**Double**可能还会产生一些问题：

```scala
    BigDecimal(0.1 + 0.2) // BigDecimal = 0.30000000000000004
    BigDecimal(.2 * .7)   // BigDecimal = 0.13999999999999999
```

因此，推荐在**BigDecimal**构造函数中使用**String**来获取准确的结果：

```scala
    BigDecimal("0.1") + BigDecimal("0.2") // BigDecimal = 0.3
    BigDecimal("0.2") * BigDecimal("0.7") // BigDecimal = 0.14
```

正如Joshua Bloch在《Effective Java》（Addison Wesley）中所说：“使用BigDecimal、int或long进行货币计算”。



### 另见

* Baeldung的“Java中的BigDecimal和BigInteger”（https://oreil.ly/3pdrS）含有大量的使用细节。

* 如果想要将这些数据类型存储到数据库，这些页面可能会提供一些帮助：
  
  * Stack Overflow的”How to Insert BigInteger in Prepared Statement Java”（https://oreil.ly/kdn73）
  
  * Stack Overflow的“Store BigInteger into MySql” （https://oreil.ly/5lQgk）

* Stack Overflow的“Unpredictability of the BigDecimal(double) Constructor” （https://oreil.ly/62ZSQ）讨论了在Java中将**double**传递给**BigDecimal**的问题。



## 3.7 生成随机数

### 问题

当前有很多需要创建随机数的场景，比如测试一个程序，运行仿真系统等。



### 解决方法

使用Scala的scala.util.Random生成随机数，下面列出一些使用示例：

```scala
    val r = scala.util.Random

    // random integers
    r.nextInt // 455978773
    r.nextInt // -1837771511

    // returns a value between 0.0 and 1.0
    r.nextDouble // 0.22095085955974536
    r.nextDouble // 0.3349793259700605

    // returns a value between 0.0 and 1.0
    r.nextFloat // 0.34705013
    r.nextFloat // 0.79055405

    // set a seed when creating a new Random
    val r = scala.util.Random(31)

    // update the seed after you already have a Random instance
    r.setSeed(1_000L) 


    // limit the integers to a maximum value
    r.nextInt(6) // 0
    r.nextInt(6) // 5
    r.nextInt(6) // 1
```

当在**nextInt**方法上传入一个最大值，方法将会返回一个0（包括）到给定的值（不包括）之前的随机数。因此，给定100将会返回一个0到99之间的随机数。



### 讨论

这一小节将会展示一些**Random**类的常用方式。



#### 生成随机长度的range

Scala中创建一个随机长度的range，这在测试时会非常有用，也十分方便：

```scala
    // random length ranges
    0 to r.nextInt(10) // Range 0 to 9
    0 to r.nextInt(10) // Range 0 to 3
    0 to r.nextInt(10) // Range 0 to 7
```

当然，**Range**可以按需转换成集合序列：

```scala
    // the resulting list size will be random
    (0 to r.nextInt(10)).toList // List(0, 1, 2, 3, 4)
    (0 to r.nextInt(10)).toList // List(0, 1, 2)

    // a random size LazyList
    (0 to r.nextInt(1_000_000)).to(LazyList)
        // result: LazyList[Int] = LazyList(<not computed>)
```

也可以通过**for**/**yield**循环来修改这些数值：

```scala
    for i <- 0 to r.nextInt(10) yield i * 10
```

可能会产生如下的序列：

```scala
    Vector(0, 10, 20, 30)
    Vector(0, 10)
    Vector(0, 10, 20, 30, 40, 50, 60, 70, 80)
```



#### 生成固定长度的随机数

可以创建一个长度已知的序列，序列中的值是随机生成的：

```scala
    val seq = for i <- 1 to 5 yield r.nextInt(100)
```

可能会产生如下包含5个随机数的序列：

```scala
    Vector(99, 6, 40, 77, 19)
    Vector(1, 75, 87, 55, 39)
    Vector(46, 40, 4, 82, 92)
```

同样，使用nextFloat和nextDouble也类似：

```scala
    val floats = for i <- 1 to 5 yield r.nextFloat()
    val doubles = for i <- 1 to 5 yield r.nextDouble()
```



#### 打乱序列的元素

另一个常见的需求是”随机化“一个现有的序列。因此，可以使用**Random**类中的**shuffle**方法：

```scala
    import scala.util.Random
    val x = List(1, 2, 3)

    Random.shuffle(x) // List(3, 1, 2)
    Random.shuffle(x) // List(2, 3, 1)
```



#### 从序列中随机取出一个元素

已知一个存在的序列，想要从中随机获取一个元素，可以这样做：

```scala
    import scala.util.Random
    def getRandomElement[A](list: Seq[A], random: Random): A =
      list(random.nextInt(list.length))
```

下面列出一些使用**getRandomElement**方法的示例：

```scala
    val r = scala.util.Random

    // integers
    val ints = (1 to 100).toList
    getRandomElement(ints, r) // Int = 66
    getRandomElement(ints, r) // Int = 11

    // strings
    val names = List("Hala", "Helia", "Hannah", "Hope")
    getRandomElement(names, r) // Hala
    getRandomElement(names, r) // Hannah
```





## 3.8 格式化数值和金额

### 问题

对数值或者金额的小数位数或逗号进行格式化，特别是在输出时。



### 解决方法





### 本地化



### 讨论







- [ ]  3.9 Creating New Date and Time Instances

- [ ]  3.10 Calculating the Difference Between Two Dates

- [ ]  3.11 Formatting Dates

- [ ]  3.12 Parsing Strings into Dates
