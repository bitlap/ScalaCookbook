# 5. 类

从本章开始的后面四章涵盖了Scala 3中领域建模的概念。 *领域建模* 是指如何使用编程语言对周围的世界进行建模，也就是说，如何对人、汽车、金融交易等概念建模。无论你是用函数式编程还是面向对象的编程风格来写代码，这都意味着你对这些事物的 *属性* 和 *行为* 进行建模。

为了灵活地对周围的世界进行建模，Scala 3提供了以下语言结构：

- 类
- 样例类
- 特质
- 枚举
- 对象和样例对象
- 抽象类
- 方法，可以在以上所有的这些结构中定义

这里涵盖了很多知识点，为了帮助管理这种复杂性，5.1小节展示了以FP和OOP编程时如何使用这些结构。然后，本章介绍了类和样例类，第六章介绍了特质和枚举，第七章介绍了对象，第八章的一些小节介绍了方法。因为抽象类的使用频率较低，所以他们只在5.1小节被提及。

## 类和样例类

虽然Scala和Java有很多相似之处，但与 *类* 和 *构造函数* 有关的语法代表了这两种语言之间的一些最大差异。Java往往比较啰嗦，显然Scala则比较简洁，而代码最终会生成其他代码。例如，这个只有一行的Scala类编译成了至少29行的Java代码，其中大部分是模板式的属性的 访问字段/修改字段 方法：

```
    class Employee(var name: String, var age: Int, var role: String)
```

因为类和构造函数非常重要，所以在本章的最开始的小节中将对它们进行详细讨论。

接下来，因为 *equals* 的概念是一个非常重要的话题，所以5.9小节花了很多时间来演示如何在Scala中实现 **equals** 方法。

(松鼠图)

#### 在匹配表达式中使用类

当在 **匹配** 表达式中使用类时，请在这个类的伴随对象中实现 **unapply** 方法。因为这相当于调用 **对象** 中的方法，这个主题在7.8小节 "用unapply实现模式匹配 "中涉及。

类字段的访问方法的概念很重要，所以5.10小节演示了如何禁止止访问字段和修改字段方法被自动生成。之后，5.11小节演示了如何覆盖访问字段和修改字段方法的默认行为。

(鸟图)

#### 访问字段和修改字段

在Java中，将 *访问字段* 和 *修改字段* 方法称为 *getter* 和 *setter* 方法似乎是正确的，主要是因为JavaBeans的 **get** / **set** 标准。在本章中，我将这些术语互换使用，但要明确的是，Scala并不遵循JavaBeans的访问字段和修改字段方法的命名规则。

接下来，两个小节展示了与参数和字段有关的其他技术。首先，5.12小节展示了如何将一个代码块（的执行结果）赋值给一个类中的 *lazy* 字段，然后5.13小节展示了如何通过使用 **Option** 类型来处理未初始化的 **var** 字段。

最后，正如在前面看到的，OOP风格的Scala **Employee** 类相当于29行Java代码。相比之下，这个FP风格的样例类相当于远远超过一百行的Java代码：

```
    case class Employee(name: String, age: Int, role: String)
```

因为样例类生成了很多模板代码，所以它们的用途和好处将在5.14小节中讨论。此外，由于样例类与默认的Scala类不同，样例类的构造函数（实际上是工厂方法）将在5.15小节中讨论。

## 5.1 从领域建模选项中选择

### 问题

因为Scala提供了特质、枚举、类、样例类、对象和抽象类，所以在设计自己的代码时，要了解如何从这些领域建模选项中选择。

### 解决方案

解决方案取决于是使用函数式编程还是面向对象的编程风格。这两种解决方案将在下面的章节中讨论。在讨论中还提供了一些例子，随后简要介绍了何时应该使用抽象类。

#### 函数式编程的建模选择

在以FP风格编程时，将主要使用这些结构：

- 特质
- 枚举
- 样例类
- 对象

在FP风格中，可以按如下方式使用这些结构：

*特质*

特质是用来创建小型的、以逻辑分组为单元的行为。它们通常被写成 **def** 方法，但如果愿意也可以被写成 **val** 函数。无论哪种方式，它们都被写成纯函数（详见第272页的 "纯函数"）。这些特质以后将被组合成具体的对象。

*枚举*

使用枚举来创建代数数据类型（ADTs，如6.13小节"用枚举建模代数数据类型"所示）以及广义ADTs（GADTs）。

*样例类*

使用样例类来创建具有不可变字段的对象（在某些语言中被称为 *不可变记录* ，如Java 14中的 **记录** 类型）。样例类是为FP风格创建的，它们有几个专门的方法对使用这种风格有帮助，包括：默认为 **val** 字段的参数，如果想模拟修改值时的 **copy** 方法，用于模式匹配的内置 **unapply** 方法，良好的默认 **equals** 和 **hashCode** 方法，以及其他。

*对象*

在FP中，通常会使用对象作为使一个或多个特质 "真实 "的方式，在这个过程中，技术上被称为具像化。

在FP中，当不需要案例类的所有功能时，也可以使用普通 **类** 结构（相对于 **样例类** 结构）。当这样做时，需要将字段定义为 **val** 字段，然后可以手动实现其他行为，比如为类定义一个 **unapply** 提取方法，详见7.8小节，"用unapply实现模式匹配"。

#### 面向对象编程的建模选择

当以OOP风格进行编程时，将主要使用这些结构：

- 特质
- 枚举
- 类
- 对象

在OOP风格中，可以按如下方式使用这些结构：

*特质*

Traits主要是作为接口使用的。如果你用过Java，可以像Java 8或更高的版本的接口一样使用Scala的特质，既有抽象成员，也有具体成员。以后会用类来实现这些特质。

*枚举*

主要使用枚举来创建简单的常量集，如显示器的位置（顶部、底部、左侧和右侧）。

*类*

在OOP中，将主要使用普通的类，而不是样例类。将它们的构造函数参数定义为var字段，这样它们就可以被改变。它们将包含基于这些可变字段的方法。根据需要覆盖默认的访问字段和修改字段方法（getters和setters）。

*对象*

使用 **对象** 结构作为创建相当于Java中静态方法的方式，比如一个包含对字符串进行操作的静态方法的 **StringUtils** 对象（详见7.4小节，"用伴随对象创建静态成员"）。

当想要样例类提供的许多或全部功能时（见5.14小节），也可以用它们来代替普通的类（尽管它们主要是为了FP风格编程所设计的）。

### 讨论

为了讨论这个解决方案，这里将分别展示FP和OOP的例子。但在进入这些单独的例子之前，这里先展示一下这几个枚举，它们都是被两者使用的：

```
    enum Topping:
        case Cheese, Pepperoni, Sausage, Mushrooms, Onions
    enum CrustSize:
        case Small, Medium, Large
    enum CrustType:
        case Regular, Thin, Thick
```

像这样使用枚举，从技术上讲其实是ADT，详见6.13小节，"用枚举建模代数数据类型"，展示了FP和OOP领域建模之间的一些共同点。

#### FP风格的例子

10.10小节 "真实世界的例子： 函数式领域建模"中的比萨店例子，详细演示了FP领域建模的方法，所以在这里只简单介绍一下。

首先，使用上面的枚举来定义一个 **Pizza** 类，使用 **样例类** 结构：

```
    case class Pizza(
        crustSize: CrustSize, 
        crustType: CrustType, 
        toppings: Seq[Topping] 
    )
```

之后再加入这些样例类：

```
    case class Customer( 
        name: String, 
        phone: String, 
        address: Address 
    )

    case class Address( 
        street1: String, 
        street2: Option[String], 
        city: String, 
        state: String, 
        postalCode: String 
    )

    case class Order( 
        pizzas: Seq[Pizza], 
        customer: Customer 
    )
```

在FP中，样例类是首选，因为所有的参数都是不可变的，而且样例类提供了内置的方法，使编写FP风格代码更容易（如5.14小节所示）。另外，注意这些类不包含任何方法；它们只是简单的数据结构。

接下来，把对这些数据结构进行操作的方法写成纯函数，并把这些方法进行分组使之成为小的、有逻辑组织的特质，或者说这个例子中只有一个特质：

```
    trait PizzaServiceInterface:
        def addTopping(p: Pizza, t: Topping): Pizza 
        def removeTopping(p: Pizza, t: Topping): Pizza 
        def removeAllToppings(p: Pizza): Pizza 
        def updateCrustSize(p: Pizza, cs: CrustSize): Pizza 
        def updateCrustType(p: Pizza, ct: CrustType): Pizza
```

然后在其他特质中实现这些方法：

```
    trait PizzaService extends PizzaServiceInterface:
        def addTopping(p: Pizza, t: Topping): Pizza = 
            // the 'copy' method comes with a case class 
            val newToppings = p.toppings :+ t 
            p.copy(toppings = newToppings)
        // there are about two lines of code for each of these 
        // methods, so all of that code is not repeated here: 
        def removeTopping(p: Pizza, t: Topping): Pizza = ???
        def removeAllToppings(p: Pizza): Pizza = ???
        def updateCrustSize(p: Pizza, cs: CrustSize): Pizza = ??? 
        def updateCrustType(p: Pizza, ct: CrustType): Pizza = ??? 
    end PizzaService
```

注意在这个特质中，所有的东西都是不可变的。披萨、配料和饼皮的细节被传递到方法中，它们不会改变这些值。而是根据传入的值返回新的值。

最终，把服务变成了 "真实的"，把它们具像为了对象：

```
    object PizzaService extends PizzaService
```

在这个例子中，只用了一个特质，但在现实世界中，经常会把多个特质组合到一个对象中，就像这样：

```
    object DogServices extend TailService, RubberyNoseService, PawService ...
```

如上所示，这就是如何将多个细化的、单一目的的服务组合成一个更大的、完整的服务。

这就是在这里所要展示的比萨店的例子，更多细节请参见10.10小节，"真实世界的例子： 函数式领域建模"。

#### 面向对象风格的例子

接下来，将为这个同样的问题创建一个OOP风格的解决方案。首先，使用类结构和可变参数创建一个OOP风格的披萨类：

```
    class Pizza ( 
        var crustSize: CrustSize, 
        var crustType: CrustType, 
        val toppings: ArrayBuffer[Topping] 
    ):
        def addTopping(t: Topping): Unit = 
            toppings += t 
        def removeTopping(t: Topping): Unit = 
            toppings -= t 
        def removeAllToppings(): Unit = 
            toppings.clear()
```

前两个构造函数参数被定义为 **var** 字段，所以它们可以被改变， **toppings** 被定义为 **ArrayBuffer** ，所以它的值也可以被改变。

请注意，FP风格的样例类包含属性，但没有行为，而用OOP的方法，pizza类包含两者，包括处理可变参数的方法。这些方法中的每一个都可以定义在一行中，但这里把每个方法的主体放在单独的一行中，以使它们易于阅读。但如果愿意的话它们可以像这样写得更简洁：

```
   def addTopping(t: Topping): Unit = toppings += t 
   def removeTopping(t: Topping): Unit = toppings -= t 
   def removeAllToppings(): Unit = toppings.clear()
```

如果继续沿着这条路走下去，会创建更多的OOP风格的类来封装属性和行为。例如，一个订单类可能完全封装了一系列构成 **订单** 的概念。

```
    class Order:
        private lineItems = ArrayBuffer[Product]()
        
        def addItem(p: Product): Unit = ??? 
        def removeItem(p: Product): Unit = ??? 
        def getItems(): Seq[Product] = ???
        
        def getPrintableReceipt(): String = ??? 
        def getTotalPrice(): Money = ???
    end Order
    // usage:
    val o = Order() 
    o.addItem(Pizza(Small, Thin, ArrayBuffer(Cheese, Pepperoni))) 
    o.addItem(Cheesesticks)
```

这个例子假设有一个看起来像这样层次结构的 **Product** 类：

```
    // a Product may have methods to determine its cost, sales price, 
    // and other details
    sealed trait Product
    // each class may have additional attributes and methods 
    class Pizza extends Product 
    class Beverage extends Product 
    class Cheesesticks extends Product
```

这里不会对这个例子作进一步说明，因为我认为大多数读者都熟悉用多态方法来封装属性和行为的OOP风格。

#### 还有一件事：什么时候使用抽象类

因为现在在Scala 3中，特质可以接受参数，而且类只能扩展一个抽象类（同时可以混入多个特质），那么问题来了，"什么时候应该使用抽象类？"

答案就是“几乎不用”，具体来说应该是这样：

- 当在Java使用Scala代码时，扩展一个类比扩展一个特质更容易。
- 当我在Scala Center提出这个问题时，Scala.js的创建者Sébastien Doeraene说道："在Scala.js中，一个类可以从JavaScript导入或导出"。
- 同时，Scala中心的讲师总监Julien Richard-Foy指出，抽象类可能比特质的编码效率略高，因为作为父类，特质是动态的，而对于抽象类，它是静态已知的。

因此，我的经验是始终使用特质，然后在满足上述条件（也有可能是我没有想到的其他条件）时，再回过头来使用一个抽象类。

### 另见

除了帮助了解领域建模选项外，这个小节还为其他小节提纲挈领，这些小节提供了关于每个主题的更多细节：

- 类在从5.2小节开始其他许多小节中都有讨论。
- 样例类在5.14小节中详细讨论。
- 使用特质作为接口的概念在6.1小节 "使用特质作为接口 "中讨论。
- 在6.3小节 "像抽象类一样使用特质 "中讨论了将特质作为抽象类使用的问题。
- 在6.11小节 "使用特质创建模块 "和7.7小节 "将特质具像为对象 "中涵盖了将特质具像为模块的概念。
- 在10.10小节 "真实世界的例子，函数式领域建模 "中，将更详细地介绍FP式比萨店的例子。
- 第10章中讨论了许多其他的FP概念。
- 如果对的Java代码中使用Scala特质感兴趣，请参阅22.5小节，"在Java中使用Scala特质"。

## 5.2 创建主构造函数

### 问题

如何为Scala类创建一个主构造函数，这与Java（以及其他语言）不同。

### 解决方案

Scala类的主构造函数由下面这些组成：

- 构造函数参数
- 类的主体中的字段（变量分配）。
- 在类的主体中执行的语句和表达式

下面的类演示了构造函数参数、类字段和类主体中的语句：

```
    class Employee(var firstName: String, var lastName: String):
        // a statement 
        println("the constructor begins ...")
        
        // some class fields (variable assignments) 
        var age = 0 
        private var salary = 0d
        
        // a method call 
        printEmployeeInfo() 
        
        // methods defined in the class 
        override def toString = s"$firstName $lastName is $age years old" 
        def printEmployeeInfo() = println(this) //uses toString
        
        // any statement or field prior to the end of the class 
        // definition is part of the class constructor 
        println("the constructor ends") 
        
    // optional 'end' statement 
    end Employee
```

构造函数参数、语句和字段都是类的构造函数的一部分。注意，方法也在类的主体中，但它们不是构造函数的一部分。

因为类的主体中的 *方法调用* 是构造函数的一部分，当 **Employee** 类的实例被创建时，可以看到类声明开头和结尾的 **println** 语句的输出，以及对 **printEmployeeInfo** 方法的调用。

```
    scala> val e = Employee("Kim", "Carnes")
    the constructor begins ...
    Kim Carnes is 0 years old 
    the constructor ends 
    val e: Employee = Kim Carnes is 0 years old
```

### 讨论

如果熟悉Java的话，可以发现Scala中声明主构造函数的过程与Java相比是非常不同的。在Java中，什么代码在主构造函数中，什么代码不在，是相当明显的，但Scala模糊了这种区别。然而，一旦理解了这种方法，就有助于使类声明更加简洁。

在上面所示的例子中，构造函数的两个参数 **firstName** 和 **lastName** 被定义为 **var** 字段，这意味着它们是 *可变的* ：它们在最初被设置后可以被改变。因为这些字段是可变的，也因为它们默认是公共访问，所以Scala为它们生成了访问字段和修改字段方法。因此，给定一个 **Employee** 类型的实例 **e** ，可以像这样改变其值：

```
    e.firstName = "Xena" 
    e.lastName = "Princess Warrior"
```

也可以这样来访问其值：

```
    println(e.firstName) // Xena
    println(e.lastName)  // Princess Warrior
```

因为 **age** 字段像构造函数参数一样被声明为 **var** ，类成员默认是公开的，所以它也是可见的，可以被改变和访问。

```
    e.age = 30 
    println(e.age)
```

相反，**salary** 字段被声明为 **私有的** ，所以它不能从类之外被访问。

```
    scala> e.salary 
    1 |e.salary
      | ^^ ^^
      |variable salary cannot be accessed as a member of (e: Employee)
```

当在类的主体中调用一个方法时--比如在这里是 **printEmployeeInfo** 方法的调用--这就是一个 *语句* ，它也是构造函数的一部分。如果好奇的话可以通过用 **scalac** 将代码编译成 *Employee.class* 文件，然后用像JAD这样的反编译器工具将其反编译成Java源代码来验证。**Employee** 构造函数被反编译为Java代码时就是这个样子。

```
    public Employee(String firstName, String lastName) {
        this.firstName = firstName; 
        this.lastName = lastName; 
        super(); 
        Predef$.MODULE$.println("the constructor begins ...");
        age = 0;
        double salary = 0.0D;
        printEmployeeInfo(); 
        Predef$.MODULE$.println("the constructor ends");
    }
```

这清楚地展示了 **Employee** 构造函数中的两个 **println** 语句和 **printEmployeeInfo** 方法调用，以及初始 **age** 和 **salary** 的设置。

#### 主构造函数的内容（鸟图）

在Scala中，类的主体中的任何语句、表达式或变量赋值都是类的主构造函数的一部分。

作为最后的比较，当用JAD反编译类文件，然后计算Scala和Java文件中的源代码行数--即使每个文件使用相同的格式风格--你会发现Scala的源代码有9行，Java的源代码有38行。有人说，开发人员花在 *阅读* 代码上的时间是我们 *写* 代码的10倍，所以这种创建简洁而又可读的代码的能力--我们称之为 *表现力* --是最初吸引我加入Scala的一个原因。

## 5.3 构造函数字段可见性

### 问题

如何控制Scala类中作为构造函数参数的字段的可见性。

### 解决方案

如下面的例子所示，Scala类中构造函数字段的可见性由该字段是否被声明为 **val** 或 **var** ，以及是否在字段中加入 **private** 来控制。

以下是解决方案的简短版本：

- 如果一个字段被声明为 **var** ，Scala会为该字段生成getter和setter方法。
- 如果字段是一个 **val** ，Scala只为它生成一个getter方法。
- 如果一个字段既不是 **var** 也不是 **val** ，Scala不会为该字段生成getter或setter方法；它成为类的私有部分。
- 此外， **var** 和 **val** 字段可以用 **private** 关键字进行修饰，这样可以防止产生公开的getter和setter方法。

下面的例子里会阐述更多的细节。

#### var 字段

如果一个构造函数参数被声明为 **var** ，那么该字段的值就可以被改变，所以Scala为该字段生成了getter和setter方法。在下面这个例子中，构造函数参数名被声明为 **var** ，所以该字段可以被访问和修改。

```
    scala> class Person(var name: String) 
    scala> val p = Person("Mark Sinclair Vincent")
    
    // getter 
    scala> p.name 
    val res0: String = Mark Sinclair Vincent
    
    // setter
    scala> p.name = "Vin Diesel"
    
    scala> p.name 
    val res1: String = Vin Diesel
```

熟悉Java的读者会发现Scala在生成访问字段和修改字段方法时并不遵循JavaBean *getName/setName* 的命名规则。相反，只需通过它的名字就可以访问一个字段。

#### val 字段

如果一个构造函数字段被声明为 **val** ，那么该字段的值一旦被设置就不能被改变也就是说它是不可变的，就像Java中的 **final** 。因此，它有一个访问字段方法，而 *没* 有一个修改字段方法。

```
    scala> class Person(val name: String) 
    defined class Person
    
    scala> val p = Person("Jane Doe")
    p: Person = Person@3f9f332b
    
    // getter 
    scala> p.name 
    res0: String = Jane Doe
    
    // attempt to use a setter
    scala> p.name = "Wilma Flintstone"
    1 |p.name = "Wilma Flintstone"
      | ^^^^^^^^^ 
      |Reassignment to val name
```

最后一个例子失败了，因为没有为 **val** 字段生成一个修改字段方法。

#### 没有var或val的字段

当构造函数参数上既没有 **val** 也没有 **var** 时，这个字段就是私有的，Scala就不会生成访问字段或修改字段方法。如下所示，当创建一个这样的类时：

```
    class SuperEncryptor(password: String):
        // encrypt increments each Char in a String by 1 
        private def encrypt(s: String) = s.map(c => (c + 1).toChar) 
        def getEncryptedPassword = encrypt(password)
```

然后试图访问 **password** 字段时，会报错说：该字段被声明为没有 **val** 或 **var** 。

```
    val e = SuperEncryptor("1234") 
    e.password // error: value password cannot be accessed 
    e.getEncryptedPassword // 2345
```

如上所示，不能直接访问 **password** 字段，但由于 **getEncryptedPassword** 方法是一个类成员，它可以访问 **password** 。如果继续试验这段代码就会发现，在声明 **password** 时不使用 **val** 或 **var** ，就相当于把它变成了一个私有的 **val** 。

在大多数情况下，我只是在忘记为字段指定 **val** 或 **var** 使用这种语法，但如果想接受一个构造函数参数，然后在类中使用该参数，但又不想让它在类外直接使用，那么这种语法就有意义。

#### 给val或var添加private

除了上面三种基本配置外，还可以给 **val** 或 **var** 字段添加 **private** 关键字。这可以防止生成getter和setter方法，因此该字段只能从类的成员中访问，如本例中的 **salary** 字段所示：

```
    enum Role:
        case HumanResources, WorkerBee
    
    import Role.*
    
    class Employee(var name: String, private var salary: Double):
        def getSalary(r: Role): Option[Double] = r match 
            case HumanResources => Some(salary) 
            case _ => None
```

在这段代码中， **getSalary** 可以访问 **salary** 字段，因为它被定义在类的内部，但是正如下面这个例子所展示的 **salary** 字段不能从类的外部直接访问：

```
    val e = Employee("Steve Jobs", 1)
    
    // to access the salary field you have to use getSalary 
    e.name                          // Steve Jobs 
    e.getSalary(WorkerBee)          // None 
    e.getSalary(HumanResources)     // Some(1.0)
    
    e.salary    // error: variable salary in class Employee cannot be accessed
```

### 讨论

如果这些都让人感到困惑，那么想想编译器在生成代码时的选择就会对理解这些有所帮助。当一个字段被定义为 **val** 时，根据定义，它的值不能被改变，所以只生成一个getter，而不生成setter是合理的。同样，根据定义， **var** 字段的值 *可以* 被改变，所以生成getter和setter是说得过去的。

构造函数参数可以被设置成 **private** 给了开发人员额外的灵活性。当它被添加到 **val** 或 **var** 字段时，getter和setter方法会像以前一样被生成，但会被标记为私有。如果不在构造函数参数上指定 **val** 或 **var** ，根本不会生成任何getter或setter方法。

表5-1中总结了根据这些设置会生成的访问字段和修改字段方法。

*表5-1 构造函数参数设置的效果*

| 参数的设置                 | 访问字段方法 | 修改字段方法 |
| -------------------------- | ------------ | ------------ |
| var                        | 有           | 有           |
| val                        | 有           | 没有         |
| 默认（既没有var也没有val） | 没有         | 没有         |
| var或val上有private        | 没有         | 没有         |

#### 样例类

样例类构造函数中的参数与这些规则有一个不同之处：样例类构造函数参数默认为 **val** 。因此，如果定义一个样例类字段而不添加 **val** 或 **var** ，像这样：

```
    case class Person(name: String)
```

仍然可以访问这个字段，就像它被定义为一个 **val** 一样：

```
    scala> val p = Person("Dale Cooper")
    p: Person = Person(Dale Cooper)
    
    scala> p.name 
    res0: String = Dale Cooper
```

虽然这与普通的类不同，但它很便利，并且与函数式编程中使用样例类的方式有关，即作为不可变的记录。

### 另见

- 关于手动添加自己的访问字段和修改字段方法的更多信息，请参见5.11小节；关于 **private** 修饰的更多信息，请参见5.3小节。
- 关于样例类原理的更多信息，见5.14小节。

## 5.4 定义类的辅助构造函数

### 问题

为一个类定义一个或多个辅助构造函数，这样类的使用者就可以有多种方式来创建对象实例。

### 解决方案

将辅助构造函数定义为类中的方法，其名称为 **this** 并有合适的签名。可以定义多个辅助构造函数，但它们必须有不同的签名（参数列表）。另外，每个构造函数必须调用已经定义过的构造函数。

举个例子，假设这里有两个枚举定义，将在后面的 **Pizza** 类中使用。

```
    enum CrustSize:
        case Small, Medium, Large
        
    enum CrustType:
        case Thin, Regular, Thick
```

根据上面的定义，下面有一个 **Pizza** 类，有一个主构造函数和三个辅助构造函数。

```
    import CrustSize.*, CrustType.*
    
    // primary constructor
    class Pizza (var crustSize: CrustSize, var crustType: CrustType):
    
        // one-arg auxiliary constructor
        def this(crustSize: CrustSize) = 
            this(crustSize, Pizza.DefaultCrustType)
            
        // one-arg auxiliary constructor 
        def this(crustType: CrustType) = 
            this(Pizza.DefaultCrustSize, crustType)
            
        // zero-arg auxiliary constructor 
        def this() = 
            this(Pizza.DefaultCrustSize, Pizza.DefaultCrustType)
            
        override def toString = s"A $crustSize pizza with a $crustType crust"
        
        object Pizza:
            val DefaultCrustSize = Medium 
            val DefaultCrustType = Regular
```

基于上面这些构造函数，可以通过以下方式创建相同的比萨：

```
    import Pizza.{DefaultCrustSize, DefaultCrustType}
    
    // use the different constructors 
    val p1 = Pizza(DefaultCrustSize, DefaultCrustType) 
    val p2 = Pizza(DefaultCrustSize) 
    val p3 = Pizza(DefaultCrustType) 
    val p4 = Pizza
```

所有这些定义的输出结果是相同的：

```
    A Medium pizza with a Regular crust
```

### 讨论

这个小节有以下几个要点：

- 辅助构造函数是通过创建名为 **this** 的方法来定义的。
- 每个辅助构造函数必须以调用先前定义过的构造函数为开始。
- 每个构造函数参数列表必须不同。
- 一个构造函数使用方法名 **this** 调用另一个构造函数，并指定所需参数。

在所示的例子中，所有的辅助构造函数都调用主构造函数，但这不是必须的；辅助构造函数只需要调用先前定义的构造函数之一即可。例如，接受 **crustType** 参数的辅助构造函数可以被写成调用参数为 **CrustSize** 的构造函数。

```
    def this(crustType: CrustType) =
        this(Pizza.DefaultCrustSize) 
        this.crustType = Pizza.DefaultCrustType
```

#### 不要忘记构造函数参数可以有默认值（鸟图）

尽管 "解决方案 "中所示的方法是完全有效的，但在创建这样的多个类构造函数之前，请花些时间阅读5.6小节。如该小节所示，使用默认参数值通常可以消除对多个构造函数的需要。例如，这种方法与解决方案中所示的类具有几乎相同的功能。

```
    class Pizza( 
        var crustSize: CrustSize = Pizza.DefaultCrustSize, 
        var crustType: CrustType = Pizza.DefaultCrustType 
    ):
        override def toString = 
            s"A $crustSize pizza with a $crustType crust"
```



