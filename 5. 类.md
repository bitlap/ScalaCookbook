# 5. 类

从本章开始的后面四章涵盖了Scala 3中领域建模的概念。 *领域建模* 是指如何使用编程语言对周围的世界进行建模，也就是说，如何对人、汽车、金融交易等概念建模。无论你是用函数式编程还是面向对象的编程风格来写代码，这都意味着你对这些事物的 *属性* 和 *行为* 进行建模。

为了灵活地对周围的世界进行建模，Scala 3提供了以下语言结构：

- 类
- 样例类
- 特质
- 枚举
- 对象和样例对象
- 抽象类
- 方法，可以在以上所有的这些结构中定义

这里涵盖了很多知识点，为了帮助管理这种复杂性，5.1小节展示了以FP和OOP编程时如何使用这些结构。然后，本章介绍了类和样例类，第六章介绍了特质和枚举，第七章介绍了对象，第八章的一些小节介绍了方法。因为抽象类的使用频率较低，所以他们只在5.1小节被提及。

## 类和样例类

虽然Scala和Java有很多相似之处，但与 *类* 和 *构造函数* 有关的语法代表了这两种语言之间的一些最大差异。Java往往比较啰嗦，显然Scala则比较简洁，而代码最终会生成其他代码。例如，这个只有一行的Scala类编译成了至少29行的Java代码，其中大部分是模板式的属性的 访问字段/修改字段 方法：

```
    class Employee(var name: String, var age: Int, var role: String)
```

因为类和构造函数非常重要，所以在本章的最开始的小节中将对它们进行详细讨论。

接下来，因为 *equals* 的概念是一个非常重要的话题，所以5.9小节花了很多时间来演示如何在Scala中实现 **equals** 方法。

(松鼠图)

#### 在匹配表达式中使用类

当在 **匹配** 表达式中使用类时，请在这个类的伴随对象中实现 **unapply** 方法。因为这相当于调用 **对象** 中的方法，这个主题在7.8小节 "用unapply实现模式匹配 "中涉及。

类字段的访问方法的概念很重要，所以5.10小节演示了如何禁止止访问字段和修改字段方法被自动生成。之后，5.11小节演示了如何覆盖访问字段和修改字段方法的默认行为。

(鸟图)

#### 访问字段和修改字段

在Java中，将 *访问字段* 和 *修改字段* 方法称为 *getter* 和 *setter* 方法似乎是正确的，主要是因为JavaBeans的 **get** / **set** 标准。在本章中，我将这些术语互换使用，但要明确的是，Scala并不遵循JavaBeans的访问字段和修改字段方法的命名规则。

接下来，两个小节展示了与参数和字段有关的其他技术。首先，5.12小节展示了如何将一个代码块（的执行结果）赋值给一个类中的 *lazy* 字段，然后5.13小节展示了如何通过使用 **Option** 类型来处理未初始化的 **var** 字段。

最后，正如在前面看到的，OOP风格的Scala **Employee** 类相当于29行Java代码。相比之下，这个FP风格的样例类相当于远远超过一百行的Java代码：

```
    case class Employee(name: String, age: Int, role: String)
```

因为样例类生成了很多模板代码，所以它们的用途和好处将在5.14小节中讨论。此外，由于样例类与默认的Scala类不同，样例类的构造函数（实际上是工厂方法）将在5.15小节中讨论。

## 5.1 从领域建模选项中选择

### 问题

因为Scala提供了特质、枚举、类、样例类、对象和抽象类，所以在设计自己的代码时，要了解如何从这些领域建模选项中选择。

### 解决方法

解决方案取决于是使用函数式编程还是面向对象的编程风格。这两种解决方案将在下面的章节中讨论。在讨论中还提供了一些例子，随后简要介绍了何时应该使用抽象类。

#### 函数式编程的建模选择

在以FP风格编程时，将主要使用这些结构：

- 特质
- 枚举
- 样例类
- 对象

在FP风格中，可以按如下方式使用这些结构：

*特质*

特质是用来创建小型的、以逻辑分组为单元的行为。它们通常被写成 **def** 方法，但如果愿意也可以被写成 **val** 函数。无论哪种方式，它们都被写成纯函数（详见第272页的 "纯函数"）。这些特质以后将被组合成具体的对象。

*枚举*

使用枚举来创建代数数据类型（ADTs，如6.13小节"用枚举建模代数数据类型"所示）以及广义ADTs（GADTs）。

*样例类*

使用样例类来创建具有不可变字段的对象（在某些语言中被称为 *不可变记录* ，如Java 14中的 **记录** 类型）。样例类是为FP风格创建的，它们有几个专门的方法对使用这种风格有帮助，包括：默认为 **val** 字段的参数，如果想模拟修改值时的 **copy** 方法，用于模式匹配的内置 **unapply** 方法，良好的默认 **equals** 和 **hashCode** 方法，以及其他。

*对象*

在FP中，通常会使用对象作为使一个或多个特质 "真实 "的方式，在这个过程中，技术上被称为具像化。

在FP中，当不需要案例类的所有功能时，也可以使用普通 **类** 结构（相对于 **样例类** 结构）。当这样做时，需要将字段定义为 **val** 字段，然后可以手动实现其他行为，比如为类定义一个 **unapply** 提取方法，详见7.8小节，"用unapply实现模式匹配"。

#### 面向对象编程的建模选择

当以OOP风格进行编程时，将主要使用这些结构：

- 特质
- 枚举
- 类
- 对象

在OOP风格中，可以按如下方式使用这些结构：

*特质*

Traits主要是作为接口使用的。如果你用过Java，可以像Java 8或更高的版本的接口一样使用Scala的特质，既有抽象成员，也有具体成员。以后会用类来实现这些特质。

*枚举*

主要使用枚举来创建简单的常量集，如显示器的位置（顶部、底部、左侧和右侧）。

*类*

在OOP中，将主要使用普通的类，而不是样例类。将它们的构造函数参数定义为var字段，这样它们就可以被改变。它们将包含基于这些可变字段的方法。根据需要覆盖默认的访问字段和修改字段方法（getters和setters）。

*对象*

使用 **对象** 结构作为创建相当于Java中静态方法的方式，比如一个包含对字符串进行操作的静态方法的 **StringUtils** 对象（详见7.4小节，"用伴随对象创建静态成员"）。

当想要样例类提供的许多或全部功能时（见5.14小节），也可以用它们来代替普通的类（尽管它们主要是为了FP风格编程所设计的）。