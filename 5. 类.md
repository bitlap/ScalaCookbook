# 5. 类

从本章开始的后面四章涵盖了Scala 3中领域建模的概念。 *领域建模* 是指如何使用编程语言对周围的世界进行建模，也就是说，如何对人、汽车、金融交易等概念建模。无论你是用函数式编程还是面向对象的编程风格来写代码，这都意味着你对这些事物的 *属性* 和 *行为* 进行建模。

为了灵活地对周围的世界进行建模，Scala 3提供了以下语言结构：

- 类
- 样例类
- 特质
- 枚举
- 对象和样例对象
- 抽象类
- 方法，可以在以上所有的这些结构中定义

这里涵盖了很多知识点，为了帮助管理这种复杂性，5.1小节展示了以FP和OOP编程时如何使用这些结构。然后，本章介绍了类和样例类，第六章介绍了特质和枚举，第七章介绍了对象，第八章的一些小节介绍了方法。因为抽象类的使用频率较低，所以他们只在5.1小节被提及。

## 类和样例类

虽然Scala和Java有很多相似之处，但与 *类* 和 *构造函数* 有关的语法代表了这两种语言之间的一些最大差异。Java往往比较啰嗦，显然Scala则比较简洁，而代码最终会生成其他代码。例如，这个只有一行的Scala类编译成了至少29行的Java代码，其中大部分是模板式的属性的 访问字段/修改字段 方法：

```
    class Employee(var name: String, var age: Int, var role: String)
```

因为类和构造函数非常重要，所以在本章的最开始的小节中将对它们进行详细讨论。

接下来，因为 *equals* 的概念是一个非常重要的话题，所以5.9小节花了很多时间来演示如何在Scala中实现 **equals** 方法。

(松鼠图)

#### 在匹配表达式中使用类

当在 **匹配** 表达式中使用类时，请在这个类的伴随对象中实现 **unapply** 方法。因为这相当于调用 **对象** 中的方法，这个主题在7.8小节 "用unapply实现模式匹配 "中涉及。

类字段的访问方法的概念很重要，所以5.10小节演示了如何禁止止访问字段和修改字段方法被自动生成。之后，5.11小节演示了如何覆盖访问字段和修改字段方法的默认行为。

(鸟图)

#### 访问字段和修改字段

在Java中，将 *访问字段* 和 *修改字段* 方法称为 *getter* 和 *setter* 方法似乎是正确的，主要是因为JavaBeans的 **get** / **set** 标准。在本章中，我将这些术语互换使用，但要明确的是，Scala并不遵循JavaBeans的访问字段和修改字段方法的命名规则。

接下来，两个小节展示了与参数和字段有关的其他技术。首先，5.12小节展示了如何将一个代码块（的执行结果）赋值给一个类中的 *lazy* 字段，然后5.13小节展示了如何通过使用 **Option** 类型来处理未初始化的 **var** 字段。

最后，正如在前面看到的，OOP风格的Scala **Employee** 类相当于29行Java代码。相比之下，这个FP风格的样例类相当于远远超过一百行的Java代码：

```
    case class Employee(name: String, age: Int, role: String)
```

因为样例类生成了很多模板代码，所以它们的用途和好处将在5.14小节中讨论。此外，由于样例类与默认的Scala类不同，样例类的构造函数（实际上是工厂方法）将在5.15小节中讨论。

## 5.1 从领域建模选项中选择

### 问题

因为Scala提供了特质、枚举、类、样例类、对象和抽象类，所以在设计自己的代码时，要了解如何从这些领域建模选项中选择。

### 解决方案

解决方案取决于是使用函数式编程还是面向对象的编程风格。这两种解决方案将在下面的章节中讨论。在讨论中还提供了一些例子，随后简要介绍了何时应该使用抽象类。

#### 函数式编程的建模选择

在以FP风格编程时，将主要使用这些结构：

- 特质
- 枚举
- 样例类
- 对象

在FP风格中，可以按如下方式使用这些结构：

*特质*

特质是用来创建小型的、以逻辑分组为单元的行为。它们通常被写成 **def** 方法，但如果愿意也可以被写成 **val** 函数。无论哪种方式，它们都被写成纯函数（详见第272页的 "纯函数"）。这些特质以后将被组合成具体的对象。

*枚举*

使用枚举来创建代数数据类型（ADTs，如6.13小节"用枚举建模代数数据类型"所示）以及广义ADTs（GADTs）。

*样例类*

使用样例类来创建具有不可变字段的对象（在某些语言中被称为 *不可变记录* ，如Java 14中的 **记录** 类型）。样例类是为FP风格创建的，它们有几个专门的方法对使用这种风格有帮助，包括：默认为 **val** 字段的参数，如果想模拟修改值时的 **copy** 方法，用于模式匹配的内置 **unapply** 方法，良好的默认 **equals** 和 **hashCode** 方法，以及其他。

*对象*

在FP中，通常会使用对象作为使一个或多个特质 "真实 "的方式，在这个过程中，技术上被称为具像化。

在FP中，当不需要案例类的所有功能时，也可以使用普通 **类** 结构（相对于 **样例类** 结构）。当这样做时，需要将字段定义为 **val** 字段，然后可以手动实现其他行为，比如为类定义一个 **unapply** 提取方法，详见7.8小节，"用unapply实现模式匹配"。

#### 面向对象编程的建模选择

当以OOP风格进行编程时，将主要使用这些结构：

- 特质
- 枚举
- 类
- 对象

在OOP风格中，可以按如下方式使用这些结构：

*特质*

Traits主要是作为接口使用的。如果你用过Java，可以像Java 8或更高的版本的接口一样使用Scala的特质，既有抽象成员，也有具体成员。以后会用类来实现这些特质。

*枚举*

主要使用枚举来创建简单的常量集，如显示器的位置（顶部、底部、左侧和右侧）。

*类*

在OOP中，将主要使用普通的类，而不是样例类。将它们的构造函数参数定义为var字段，这样它们就可以被改变。它们将包含基于这些可变字段的方法。根据需要覆盖默认的访问字段和修改字段方法（getters和setters）。

*对象*

使用 **对象** 结构作为创建相当于Java中静态方法的方式，比如一个包含对字符串进行操作的静态方法的 **StringUtils** 对象（详见7.4小节，"用伴随对象创建静态成员"）。

当想要样例类提供的许多或全部功能时（见5.14小节），也可以用它们来代替普通的类（尽管它们主要是为了FP风格编程所设计的）。

### 讨论

为了讨论这个解决方案，这里将分别展示FP和OOP的例子。但在进入这些单独的例子之前，这里先展示一下这几个枚举，它们都是被两者使用的：

```
    enum Topping:
        case Cheese, Pepperoni, Sausage, Mushrooms, Onions
    enum CrustSize:
        case Small, Medium, Large
    enum CrustType:
        case Regular, Thin, Thick
```

像这样使用枚举，从技术上讲其实是ADT，详见6.13小节，"用枚举建模代数数据类型"，展示了FP和OOP领域建模之间的一些共同点。

#### FP风格的例子

10.10小节 "真实世界的例子： 函数式领域建模"中的比萨店例子，详细演示了FP领域建模的方法，所以在这里只简单介绍一下。

首先，使用上面的枚举来定义一个 **Pizza** 类，使用 **样例类** 结构：

```
    case class Pizza(
        crustSize: CrustSize, 
        crustType: CrustType, 
        toppings: Seq[Topping] 
    )
```

之后再加入这些样例类：

```
    case class Customer( 
        name: String, 
        phone: String, 
        address: Address 
    )

    case class Address( 
        street1: String, 
        street2: Option[String], 
        city: String, 
        state: String, 
        postalCode: String 
    )

    case class Order( 
        pizzas: Seq[Pizza], 
        customer: Customer 
    )
```

在FP中，样例类是首选，因为所有的参数都是不可变的，而且样例类提供了内置的方法，使编写FP风格代码更容易（如5.14小节所示）。另外，注意这些类不包含任何方法；它们只是简单的数据结构。

接下来，把对这些数据结构进行操作的方法写成纯函数，并把这些方法进行分组使之成为小的、有逻辑组织的特质，或者说这个例子中只有一个特质：

```
    trait PizzaServiceInterface:
        def addTopping(p: Pizza, t: Topping): Pizza 
        def removeTopping(p: Pizza, t: Topping): Pizza 
        def removeAllToppings(p: Pizza): Pizza 
        def updateCrustSize(p: Pizza, cs: CrustSize): Pizza 
        def updateCrustType(p: Pizza, ct: CrustType): Pizza
```

然后在其他特质中实现这些方法：

```
    trait PizzaService extends PizzaServiceInterface:
        def addTopping(p: Pizza, t: Topping): Pizza = 
            // the 'copy' method comes with a case class 
            val newToppings = p.toppings :+ t 
            p.copy(toppings = newToppings)
        // there are about two lines of code for each of these 
        // methods, so all of that code is not repeated here: 
        def removeTopping(p: Pizza, t: Topping): Pizza = ???
        def removeAllToppings(p: Pizza): Pizza = ???
        def updateCrustSize(p: Pizza, cs: CrustSize): Pizza = ??? 
        def updateCrustType(p: Pizza, ct: CrustType): Pizza = ??? 
    end PizzaService
```

注意在这个特质中，所有的东西都是不可变的。披萨、配料和饼皮的细节被传递到方法中，它们不会改变这些值。而是根据传入的值返回新的值。

最终，把服务变成了 "真实的"，把它们具像为了对象：

```
    object PizzaService extends PizzaService
```

在这个例子中，只用了一个特质，但在现实世界中，经常会把多个特质组合到一个对象中，就像这样：

```
    object DogServices extend TailService, RubberyNoseService, PawService ...
```

如上所示，这就是如何将多个细化的、单一目的的服务组合成一个更大的、完整的服务。

这就是在这里所要展示的比萨店的例子，更多细节请参见10.10小节，"真实世界的例子： 函数式领域建模"。

#### 面向对象风格的例子

接下来，将为这个同样的问题创建一个OOP风格的解决方案。首先，使用类结构和可变参数创建一个OOP风格的披萨类：

```
    class Pizza ( 
        var crustSize: CrustSize, 
        var crustType: CrustType, 
        val toppings: ArrayBuffer[Topping] 
    ):
        def addTopping(t: Topping): Unit = 
            toppings += t 
        def removeTopping(t: Topping): Unit = 
            toppings -= t 
        def removeAllToppings(): Unit = 
            toppings.clear()
```

前两个构造函数参数被定义为 **var** 字段，所以它们可以被改变， **toppings** 被定义为 **ArrayBuffer** ，所以它的值也可以被改变。

请注意，FP风格的样例类包含属性，但没有行为，而用OOP的方法，pizza类包含两者，包括处理可变参数的方法。这些方法中的每一个都可以定义在一行中，但这里把每个方法的主体放在单独的一行中，以使它们易于阅读。但如果愿意的话它们可以像这样写得更简洁：

```
   def addTopping(t: Topping): Unit = toppings += t 
   def removeTopping(t: Topping): Unit = toppings -= t 
   def removeAllToppings(): Unit = toppings.clear()
```

如果继续沿着这条路走下去，会创建更多的OOP风格的类来封装属性和行为。例如，一个订单类可能完全封装了一系列构成 **订单** 的概念。

```
    class Order:
        private lineItems = ArrayBuffer[Product]()
        
        def addItem(p: Product): Unit = ??? 
        def removeItem(p: Product): Unit = ??? 
        def getItems(): Seq[Product] = ???
        
        def getPrintableReceipt(): String = ??? 
        def getTotalPrice(): Money = ???
    end Order
    // usage:
    val o = Order() 
    o.addItem(Pizza(Small, Thin, ArrayBuffer(Cheese, Pepperoni))) 
    o.addItem(Cheesesticks)
```

这个例子假设有一个看起来像这样层次结构的 **Product** 类：

```
    // a Product may have methods to determine its cost, sales price, 
    // and other details
    sealed trait Product
    // each class may have additional attributes and methods 
    class Pizza extends Product 
    class Beverage extends Product 
    class Cheesesticks extends Product
```

这里不会对这个例子作进一步说明，因为我认为大多数读者都熟悉用多态方法来封装属性和行为的OOP风格。

#### 还有一件事：什么时候使用抽象类

因为现在在Scala 3中，特质可以接受参数，而且类只能扩展一个抽象类（同时可以混入多个特质），那么问题来了，"什么时候应该使用抽象类？"

答案就是“几乎不用”，具体来说应该是这样：

- 当在Java使用Scala代码时，扩展一个类比扩展一个特质更容易。
- 当我在Scala Center提出这个问题时，Scala.js的创建者Sébastien Doeraene说道："在Scala.js中，一个类可以从JavaScript导入或导出"。
- 同时，Scala中心的讲师总监Julien Richard-Foy指出，抽象类可能比特质的编码效率略高，因为作为父类，特质是动态的，而对于抽象类，它是静态已知的。

因此，我的经验是始终使用特质，然后在满足上述条件（也有可能是我没有想到的其他条件）时，再回过头来使用一个抽象类。

### 另见

除了帮助了解领域建模选项外，这个小节还为其他小节提纲挈领，这些小节提供了关于每个主题的更多细节：

- 类在从5.2小节开始其他许多小节中都有讨论。
- 样例类在5.14小节中详细讨论。
- 使用特质作为接口的概念在6.1小节 "使用特质作为接口 "中讨论。
- 在6.3小节 "像抽象类一样使用特质 "中讨论了将特质作为抽象类使用的问题。
- 在6.11小节 "使用特质创建模块 "和7.7小节 "将特质具像为对象 "中涵盖了将特质具像为模块的概念。
- 在10.10小节 "真实世界的例子，函数式领域建模 "中，将更详细地介绍FP式比萨店的例子。
- 第10章中讨论了许多其他的FP概念。
- 如果对的Java代码中使用Scala特质感兴趣，请参阅22.5小节，"在Java中使用Scala特质"。

## 5.2 创建主构造函数

### 问题

如何为Scala类创建一个主构造函数，这与Java（以及其他语言）不同。

### 解决方案

Scala类的主构造函数由下面这些组成：

- 构造函数参数
- 类的主体中的字段（变量分配）。
- 在类的主体中执行的语句和表达式

下面的类演示了构造函数参数、类字段和类主体中的语句：

```
    class Employee(var firstName: String, var lastName: String):
        // a statement 
        println("the constructor begins ...")
        
        // some class fields (variable assignments) 
        var age = 0 
        private var salary = 0d
        
        // a method call 
        printEmployeeInfo() 
        
        // methods defined in the class 
        override def toString = s"$firstName $lastName is $age years old" 
        def printEmployeeInfo() = println(this) //uses toString
        
        // any statement or field prior to the end of the class 
        // definition is part of the class constructor 
        println("the constructor ends") 
        
    // optional 'end' statement 
    end Employee
```

构造函数参数、语句和字段都是类的构造函数的一部分。注意，方法也在类的主体中，但它们不是构造函数的一部分。

因为类的主体中的 *方法调用* 是构造函数的一部分，当 **Employee** 类的实例被创建时，可以看到类声明开头和结尾的 **println** 语句的输出，以及对 **printEmployeeInfo** 方法的调用。

```
    scala> val e = Employee("Kim", "Carnes")
    the constructor begins ...
    Kim Carnes is 0 years old 
    the constructor ends 
    val e: Employee = Kim Carnes is 0 years old
```

### 讨论

如果熟悉Java的话，可以发现Scala中声明主构造函数的过程与Java相比是非常不同的。在Java中，什么代码在主构造函数中，什么代码不在，是相当明显的，但Scala模糊了这种区别。然而，一旦理解了这种方法，就有助于使类声明更加简洁。

在上面所示的例子中，构造函数的两个参数 **firstName** 和 **lastName** 被定义为 **var** 字段，这意味着它们是 *可变的* ：它们在最初被设置后可以被改变。因为这些字段是可变的，也因为它们默认是公共访问，所以Scala为它们生成了访问字段和修改字段方法。因此，给定一个 **Employee** 类型的实例 **e** ，可以像这样改变其值：

```
    e.firstName = "Xena" 
    e.lastName = "Princess Warrior"
```

也可以这样来访问其值：

```
    println(e.firstName) // Xena
    println(e.lastName)  // Princess Warrior
```

因为 **age** 字段像构造函数参数一样被声明为 **var** ，类成员默认是公开的，所以它也是可见的，可以被改变和访问。

```
    e.age = 30 
    println(e.age)
```

相反，**salary** 字段被声明为 **私有的** ，所以它不能从类之外被访问。

```
    scala> e.salary 
    1 |e.salary
      | ^^ ^^
      |variable salary cannot be accessed as a member of (e: Employee)
```

当在类的主体中调用一个方法时--比如在这里是 **printEmployeeInfo** 方法的调用--这就是一个 *语句* ，它也是构造函数的一部分。如果好奇的话可以通过用 **scalac** 将代码编译成 *Employee.class* 文件，然后用像JAD这样的反编译器工具将其反编译成Java源代码来验证。**Employee** 构造函数被反编译为Java代码时就是这个样子。

```
    public Employee(String firstName, String lastName) {
        this.firstName = firstName; 
        this.lastName = lastName; 
        super(); 
        Predef$.MODULE$.println("the constructor begins ...");
        age = 0;
        double salary = 0.0D;
        printEmployeeInfo(); 
        Predef$.MODULE$.println("the constructor ends");
    }
```

这清楚地展示了 **Employee** 构造函数中的两个 **println** 语句和 **printEmployeeInfo** 方法调用，以及初始 **age** 和 **salary** 的设置。

#### 主构造函数的内容（鸟图）

在Scala中，类的主体中的任何语句、表达式或变量赋值都是类的主构造函数的一部分。

作为最后的比较，当用JAD反编译类文件，然后计算Scala和Java文件中的源代码行数--即使每个文件使用相同的格式风格--你会发现Scala的源代码有9行，Java的源代码有38行。有人说，开发人员花在 *阅读* 代码上的时间是我们 *写* 代码的10倍，所以这种创建简洁而又可读的代码的能力--我们称之为 *表现力* --是最初吸引我加入Scala的一个原因。