# 5. 类

从本章开始的后面四章涵盖了Scala 3中领域建模的概念。 *领域建模* 是指如何使用编程语言对周围的世界进行建模，也就是说，如何对人、汽车、金融交易等概念建模。无论你是用函数式编程还是面向对象的编程风格来写代码，这都意味着你对这些事物的 *属性* 和 *行为* 进行建模。

为了灵活地对周围的世界进行建模，Scala 3提供了以下语言结构：

- 类
- 样例类
- 特质
- 枚举
- 对象和样例对象
- 抽象类
- 方法，可以在以上所有的这些结构中定义

这里涵盖了很多知识点，为了帮助管理这种复杂性，5.1小节展示了以FP和OOP编程时如何使用这些结构。然后，本章介绍了类和样例类，第六章介绍了特质和枚举，第七章介绍了对象，第八章的一些小节介绍了方法。因为抽象类的使用频率较低，所以他们只在5.1小节被提及。

## 类和样例类

虽然Scala和Java有很多相似之处，但与 *类* 和 *构造函数* 有关的语法代表了这两种语言之间的一些最大差异。Java往往比较啰嗦，显然Scala则比较简洁，而代码最终会生成其他代码。例如，这个只有一行的Scala类编译成了至少29行的Java代码，其中大部分是模板式的属性的 访问字段/修改字段 方法：

```
    class Employee(var name: String, var age: Int, var role: String)
```

因为类和构造函数非常重要，所以在本章的最开始的小节中将对它们进行详细讨论。

接下来，因为 *equals* 的概念是一个非常重要的话题，所以5.9小节花了很多时间来演示如何在Scala中实现 **equals** 方法。

(松鼠图)

#### 在匹配表达式中使用类

当在 **匹配** 表达式中使用类时，请在这个类的伴随对象中实现 **unapply** 方法。因为这相当于调用 **对象** 中的方法，这个主题在7.8小节 "用unapply实现模式匹配 "中涉及。

类字段的访问方法的概念很重要，所以5.10小节演示了如何禁止止访问字段和修改字段方法被自动生成。之后，5.11小节演示了如何覆盖访问字段和修改字段方法的默认行为。

(鸟图)

#### 访问字段和修改字段

在Java中，将 *访问字段* 和 *修改字段* 方法称为 *getter* 和 *setter* 方法似乎是正确的，主要是因为JavaBeans的 **get** / **set** 标准。在本章中，我将这些术语互换使用，但要明确的是，Scala并不遵循JavaBeans的访问字段和修改字段方法的命名规则。

接下来，两个小节展示了与参数和字段有关的其他技术。首先，5.12小节展示了如何将一个代码块（的执行结果）赋值给一个类中的 *lazy* 字段，然后5.13小节展示了如何通过使用 **Option** 类型来处理未初始化的 **var** 字段。

最后，正如在前面看到的，OOP风格的Scala **Employee** 类相当于29行Java代码。相比之下，这个FP风格的样例类相当于远远超过一百行的Java代码：

```
    case class Employee(name: String, age: Int, role: String)
```

因为样例类生成了很多模板代码，所以它们的用途和好处将在5.14小节中讨论。此外，由于样例类与默认的Scala类不同，样例类的构造函数（实际上是工厂方法）将在5.15小节中讨论。

## 5.1 从领域建模选项中选择

### 问题

因为Scala提供了特质、枚举、类、样例类、对象和抽象类，所以在设计自己的代码时，要了解如何从这些领域建模选项中选择。

### 解决方案

解决方案取决于是使用函数式编程还是面向对象的编程风格。这两种解决方案将在下面的章节中讨论。在讨论中还提供了一些例子，随后简要介绍了何时应该使用抽象类。

#### 函数式编程的建模选择

在以FP风格编程时，将主要使用这些结构：

- 特质
- 枚举
- 样例类
- 对象

在FP风格中，可以按如下方式使用这些结构：

*特质*

特质是用来创建小型的、以逻辑分组为单元的行为。它们通常被写成 **def** 方法，但如果愿意也可以被写成 **val** 函数。无论哪种方式，它们都被写成纯函数（详见第272页的 "纯函数"）。这些特质以后将被组合成具体的对象。

*枚举*

使用枚举来创建代数数据类型（ADTs，如6.13小节"用枚举建模代数数据类型"所示）以及广义ADTs（GADTs）。

*样例类*

使用样例类来创建具有不可变字段的对象（在某些语言中被称为 *不可变记录* ，如Java 14中的 **记录** 类型）。样例类是为FP风格创建的，它们有几个专门的方法对使用这种风格有帮助，包括：默认为 **val** 字段的参数，如果想模拟修改值时的 **copy** 方法，用于模式匹配的内置 **unapply** 方法，良好的默认 **equals** 和 **hashCode** 方法，以及其他。

*对象*

在FP中，通常会使用对象作为使一个或多个特质 "真实 "的方式，在这个过程中，技术上被称为具像化。

在FP中，当不需要案例类的所有功能时，也可以使用普通 **类** 结构（相对于 **样例类** 结构）。当这样做时，需要将字段定义为 **val** 字段，然后可以手动实现其他行为，比如为类定义一个 **unapply** 提取方法，详见7.8小节，"用unapply实现模式匹配"。

#### 面向对象编程的建模选择

当以OOP风格进行编程时，将主要使用这些结构：

- 特质
- 枚举
- 类
- 对象

在OOP风格中，可以按如下方式使用这些结构：

*特质*

Traits主要是作为接口使用的。如果你用过Java，可以像Java 8或更高的版本的接口一样使用Scala的特质，既有抽象成员，也有具体成员。以后会用类来实现这些特质。

*枚举*

主要使用枚举来创建简单的常量集，如显示器的位置（顶部、底部、左侧和右侧）。

*类*

在OOP中，将主要使用普通的类，而不是样例类。将它们的构造函数参数定义为var字段，这样它们就可以被改变。它们将包含基于这些可变字段的方法。根据需要覆盖默认的访问字段和修改字段方法（getters和setters）。

*对象*

使用 **对象** 结构作为创建相当于Java中静态方法的方式，比如一个包含对字符串进行操作的静态方法的 **StringUtils** 对象（详见7.4小节，"用伴随对象创建静态成员"）。

当想要样例类提供的许多或全部功能时（见5.14小节），也可以用它们来代替普通的类（尽管它们主要是为了FP风格编程所设计的）。

### 讨论

为了讨论这个解决方案，这里将分别展示FP和OOP的例子。但在进入这些单独的例子之前，这里先展示一下这几个枚举，它们都是被两者使用的：

```
    enum Topping:
        case Cheese, Pepperoni, Sausage, Mushrooms, Onions
    enum CrustSize:
        case Small, Medium, Large
    enum CrustType:
        case Regular, Thin, Thick
```

像这样使用枚举，从技术上讲其实是ADT，详见6.13小节，"用枚举建模代数数据类型"，展示了FP和OOP领域建模之间的一些共同点。

#### FP风格的例子

10.10小节 "真实世界的例子： 函数式领域建模"中的比萨店例子，详细演示了FP领域建模的方法，所以在这里只简单介绍一下。

首先，使用上面的枚举来定义一个 **Pizza** 类，使用 **样例类** 结构：

```
    case class Pizza(
        crustSize: CrustSize, 
        crustType: CrustType, 
        toppings: Seq[Topping] 
    )
```

之后再加入这些样例类：

```
    case class Customer( 
        name: String, 
        phone: String, 
        address: Address 
    )

    case class Address( 
        street1: String, 
        street2: Option[String], 
        city: String, 
        state: String, 
        postalCode: String 
    )

    case class Order( 
        pizzas: Seq[Pizza], 
        customer: Customer 
    )
```

在FP中，样例类是首选，因为所有的参数都是不可变的，而且样例类提供了内置的方法，使编写FP风格代码更容易（如5.14小节所示）。另外，注意这些类不包含任何方法；它们只是简单的数据结构。

接下来，把对这些数据结构进行操作的方法写成纯函数，并把这些方法进行分组使之成为小的、有逻辑组织的特质，或者说这个例子中只有一个特质：

```
    trait PizzaServiceInterface:
        def addTopping(p: Pizza, t: Topping): Pizza 
        def removeTopping(p: Pizza, t: Topping): Pizza 
        def removeAllToppings(p: Pizza): Pizza 
        def updateCrustSize(p: Pizza, cs: CrustSize): Pizza 
        def updateCrustType(p: Pizza, ct: CrustType): Pizza
```

然后在其他特质中实现这些方法：

```
    trait PizzaService extends PizzaServiceInterface:
        def addTopping(p: Pizza, t: Topping): Pizza = 
            // the 'copy' method comes with a case class 
            val newToppings = p.toppings :+ t 
            p.copy(toppings = newToppings)
        // there are about two lines of code for each of these 
        // methods, so all of that code is not repeated here: 
        def removeTopping(p: Pizza, t: Topping): Pizza = ???
        def removeAllToppings(p: Pizza): Pizza = ???
        def updateCrustSize(p: Pizza, cs: CrustSize): Pizza = ??? 
        def updateCrustType(p: Pizza, ct: CrustType): Pizza = ??? 
    end PizzaService
```

注意在这个特质中，所有的东西都是不可变的。披萨、配料和饼皮的细节被传递到方法中，它们不会改变这些值。而是根据传入的值返回新的值。

最终，把服务变成了 "真实的"，把它们具像为了对象：

```
    object PizzaService extends PizzaService
```

在这个例子中，只用了一个特质，但在现实世界中，经常会把多个特质组合到一个对象中，就像这样：

```
    object DogServices extend TailService, RubberyNoseService, PawService ...
```

如上所示，这就是如何将多个细化的、单一目的的服务组合成一个更大的、完整的服务。

这就是在这里所要展示的比萨店的例子，更多细节请参见10.10小节，"真实世界的例子： 函数式领域建模"。

#### 面向对象风格的例子

接下来，将为这个同样的问题创建一个OOP风格的解决方案。首先，使用类结构和可变参数创建一个OOP风格的披萨类：

```
    class Pizza ( 
        var crustSize: CrustSize, 
        var crustType: CrustType, 
        val toppings: ArrayBuffer[Topping] 
    ):
        def addTopping(t: Topping): Unit = 
            toppings += t 
        def removeTopping(t: Topping): Unit = 
            toppings -= t 
        def removeAllToppings(): Unit = 
            toppings.clear()
```

前两个构造函数参数被定义为 **var** 字段，所以它们可以被改变， **toppings** 被定义为 **ArrayBuffer** ，所以它的值也可以被改变。

请注意，FP风格的样例类包含属性，但没有行为，而用OOP的方法，pizza类包含两者，包括处理可变参数的方法。这些方法中的每一个都可以定义在一行中，但这里把每个方法的主体放在单独的一行中，以使它们易于阅读。但如果愿意的话它们可以像这样写得更简洁：

```
   def addTopping(t: Topping): Unit = toppings += t 
   def removeTopping(t: Topping): Unit = toppings -= t 
   def removeAllToppings(): Unit = toppings.clear()
```

如果继续沿着这条路走下去，会创建更多的OOP风格的类来封装属性和行为。例如，一个订单类可能完全封装了一系列构成 **订单** 的概念。

```
    class Order:
        private lineItems = ArrayBuffer[Product]()
        
        def addItem(p: Product): Unit = ??? 
        def removeItem(p: Product): Unit = ??? 
        def getItems(): Seq[Product] = ???
        
        def getPrintableReceipt(): String = ??? 
        def getTotalPrice(): Money = ???
    end Order
    // usage:
    val o = Order() 
    o.addItem(Pizza(Small, Thin, ArrayBuffer(Cheese, Pepperoni))) 
    o.addItem(Cheesesticks)
```

这个例子假设有一个看起来像这样层次结构的 **Product** 类：

```
    // a Product may have methods to determine its cost, sales price, 
    // and other details
    sealed trait Product
    // each class may have additional attributes and methods 
    class Pizza extends Product 
    class Beverage extends Product 
    class Cheesesticks extends Product
```

这里不会对这个例子作进一步说明，因为我认为大多数读者都熟悉用多态方法来封装属性和行为的OOP风格。

#### 还有一件事：什么时候使用抽象类

因为现在在Scala 3中，特质可以接受参数，而且类只能扩展一个抽象类（同时可以混入多个特质），那么问题来了，"什么时候应该使用抽象类？"

答案就是“几乎不用”，具体来说应该是这样：

- 当在Java使用Scala代码时，扩展一个类比扩展一个特质更容易。
- 当我在Scala Center提出这个问题时，Scala.js的创建者Sébastien Doeraene说道："在Scala.js中，一个类可以从JavaScript导入或导出"。
- 同时，Scala中心的讲师总监Julien Richard-Foy指出，抽象类可能比特质的编码效率略高，因为作为父类，特质是动态的，而对于抽象类，它是静态已知的。

因此，我的经验是始终使用特质，然后在满足上述条件（也有可能是我没有想到的其他条件）时，再回过头来使用一个抽象类。

### 另见

除了帮助了解领域建模选项外，这个小节还为其他小节提纲挈领，这些小节提供了关于每个主题的更多细节：

- 类在从5.2小节开始其他许多小节中都有讨论。
- 样例类在5.14小节中详细讨论。
- 使用特质作为接口的概念在6.1小节 "使用特质作为接口 "中讨论。
- 在6.3小节 "像抽象类一样使用特质 "中讨论了将特质作为抽象类使用的问题。
- 在6.11小节 "使用特质创建模块 "和7.7小节 "将特质具像为对象 "中涵盖了将特质具像为模块的概念。
- 在10.10小节 "真实世界的例子，函数式领域建模 "中，将更详细地介绍FP式比萨店的例子。
- 第10章中讨论了许多其他的FP概念。
- 如果对的Java代码中使用Scala特质感兴趣，请参阅22.5小节，"在Java中使用Scala特质"。

## 5.2 创建主构造函数

### 问题

如何为Scala类创建一个主构造函数，这与Java（以及其他语言）不同。

### 解决方案

Scala类的主构造函数由下面这些组成：

- 构造函数参数
- 类的主体中的字段（变量分配）。
- 在类的主体中执行的语句和表达式

下面的类演示了构造函数参数、类字段和类主体中的语句：

```
    class Employee(var firstName: String, var lastName: String):
        // a statement 
        println("the constructor begins ...")
        
        // some class fields (variable assignments) 
        var age = 0 
        private var salary = 0d
        
        // a method call 
        printEmployeeInfo() 
        
        // methods defined in the class 
        override def toString = s"$firstName $lastName is $age years old" 
        def printEmployeeInfo() = println(this) //uses toString
        
        // any statement or field prior to the end of the class 
        // definition is part of the class constructor 
        println("the constructor ends") 
        
    // optional 'end' statement 
    end Employee
```

构造函数参数、语句和字段都是类的构造函数的一部分。注意，方法也在类的主体中，但它们不是构造函数的一部分。

因为类的主体中的 *方法调用* 是构造函数的一部分，当 **Employee** 类的实例被创建时，可以看到类声明开头和结尾的 **println** 语句的输出，以及对 **printEmployeeInfo** 方法的调用。

```
    scala> val e = Employee("Kim", "Carnes")
    the constructor begins ...
    Kim Carnes is 0 years old 
    the constructor ends 
    val e: Employee = Kim Carnes is 0 years old
```

### 讨论

如果熟悉Java的话，可以发现Scala中声明主构造函数的过程与Java相比是非常不同的。在Java中，什么代码在主构造函数中，什么代码不在，是相当明显的，但Scala模糊了这种区别。然而，一旦理解了这种方法，就有助于使类声明更加简洁。

在上面所示的例子中，构造函数的两个参数 **firstName** 和 **lastName** 被定义为 **var** 字段，这意味着它们是 *可变的* ：它们在最初被设置后可以被改变。因为这些字段是可变的，也因为它们默认是公共访问，所以Scala为它们生成了访问字段和修改字段方法。因此，给定一个 **Employee** 类型的实例 **e** ，可以像这样改变其值：

```
    e.firstName = "Xena" 
    e.lastName = "Princess Warrior"
```

也可以这样来访问其值：

```
    println(e.firstName) // Xena
    println(e.lastName)  // Princess Warrior
```

因为 **age** 字段像构造函数参数一样被声明为 **var** ，类成员默认是公开的，所以它也是可见的，可以被改变和访问。

```
    e.age = 30 
    println(e.age)
```

相反，**salary** 字段被声明为 **私有的** ，所以它不能从类之外被访问。

```
    scala> e.salary 
    1 |e.salary
      | ^^ ^^
      |variable salary cannot be accessed as a member of (e: Employee)
```

当在类的主体中调用一个方法时--比如在这里是 **printEmployeeInfo** 方法的调用--这就是一个 *语句* ，它也是构造函数的一部分。如果好奇的话可以通过用 **scalac** 将代码编译成 *Employee.class* 文件，然后用像JAD这样的反编译器工具将其反编译成Java源代码来验证。**Employee** 构造函数被反编译为Java代码时就是这个样子。

```
    public Employee(String firstName, String lastName) {
        this.firstName = firstName; 
        this.lastName = lastName; 
        super(); 
        Predef$.MODULE$.println("the constructor begins ...");
        age = 0;
        double salary = 0.0D;
        printEmployeeInfo(); 
        Predef$.MODULE$.println("the constructor ends");
    }
```

这清楚地展示了 **Employee** 构造函数中的两个 **println** 语句和 **printEmployeeInfo** 方法调用，以及初始 **age** 和 **salary** 的设置。

#### 主构造函数的内容（鸟图）

在Scala中，类的主体中的任何语句、表达式或变量赋值都是类的主构造函数的一部分。

作为最后的比较，当用JAD反编译类文件，然后计算Scala和Java文件中的源代码行数--即使每个文件使用相同的格式风格--你会发现Scala的源代码有9行，Java的源代码有38行。有人说，开发人员花在 *阅读* 代码上的时间是我们 *写* 代码的10倍，所以这种创建简洁而又可读的代码的能力--我们称之为 *表现力* --是最初吸引我加入Scala的一个原因。

## 5.3 构造函数字段可见性

### 问题

如何控制Scala类中作为构造函数参数的字段的可见性。

### 解决方案

如下面的例子所示，Scala类中构造函数字段的可见性由该字段是否被声明为 **val** 或 **var** ，以及是否在字段中加入 **private** 来控制。

以下是解决方案的简短版本：

- 如果一个字段被声明为 **var** ，Scala会为该字段生成getter和setter方法。
- 如果字段是一个 **val** ，Scala只为它生成一个getter方法。
- 如果一个字段既不是 **var** 也不是 **val** ，Scala不会为该字段生成getter或setter方法；它成为类的私有部分。
- 此外， **var** 和 **val** 字段可以用 **private** 关键字进行修饰，这样可以防止产生公开的getter和setter方法。

下面的例子里会阐述更多的细节。

#### var 字段

如果一个构造函数参数被声明为 **var** ，那么该字段的值就可以被改变，所以Scala为该字段生成了getter和setter方法。在下面这个例子中，构造函数参数名被声明为 **var** ，所以该字段可以被访问和修改。

```
    scala> class Person(var name: String) 
    scala> val p = Person("Mark Sinclair Vincent")
    
    // getter 
    scala> p.name 
    val res0: String = Mark Sinclair Vincent
    
    // setter
    scala> p.name = "Vin Diesel"
    
    scala> p.name 
    val res1: String = Vin Diesel
```

熟悉Java的读者会发现Scala在生成访问字段和修改字段方法时并不遵循JavaBean *getName/setName* 的命名规则。相反，只需通过它的名字就可以访问一个字段。

#### val 字段

如果一个构造函数字段被声明为 **val** ，那么该字段的值一旦被设置就不能被改变也就是说它是不可变的，就像Java中的 **final** 。因此，它有一个访问字段方法，而 *没* 有一个修改字段方法。

```
    scala> class Person(val name: String) 
    defined class Person
    
    scala> val p = Person("Jane Doe")
    p: Person = Person@3f9f332b
    
    // getter 
    scala> p.name 
    res0: String = Jane Doe
    
    // attempt to use a setter
    scala> p.name = "Wilma Flintstone"
    1 |p.name = "Wilma Flintstone"
      | ^^^^^^^^^ 
      |Reassignment to val name
```

最后一个例子失败了，因为没有为 **val** 字段生成一个修改字段方法。

#### 没有var或val的字段

当构造函数参数上既没有 **val** 也没有 **var** 时，这个字段就是私有的，Scala就不会生成访问字段或修改字段方法。如下所示，当创建一个这样的类时：

```
    class SuperEncryptor(password: String):
        // encrypt increments each Char in a String by 1 
        private def encrypt(s: String) = s.map(c => (c + 1).toChar) 
        def getEncryptedPassword = encrypt(password)
```

然后试图访问 **password** 字段时，会报错说：该字段被声明为没有 **val** 或 **var** 。

```
    val e = SuperEncryptor("1234") 
    e.password // error: value password cannot be accessed 
    e.getEncryptedPassword // 2345
```

如上所示，不能直接访问 **password** 字段，但由于 **getEncryptedPassword** 方法是一个类成员，它可以访问 **password** 。如果继续试验这段代码就会发现，在声明 **password** 时不使用 **val** 或 **var** ，就相当于把它变成了一个私有的 **val** 。

在大多数情况下，我只是在忘记为字段指定 **val** 或 **var** 使用这种语法，但如果想接受一个构造函数参数，然后在类中使用该参数，但又不想让它在类外直接使用，那么这种语法就有意义。

#### 给val或var添加private

除了上面三种基本配置外，还可以给 **val** 或 **var** 字段添加 **private** 关键字。这可以防止生成getter和setter方法，因此该字段只能从类的成员中访问，如本例中的 **salary** 字段所示：

```
    enum Role:
        case HumanResources, WorkerBee
    
    import Role.*
    
    class Employee(var name: String, private var salary: Double):
        def getSalary(r: Role): Option[Double] = r match 
            case HumanResources => Some(salary) 
            case _ => None
```

在这段代码中， **getSalary** 可以访问 **salary** 字段，因为它被定义在类的内部，但是正如下面这个例子所展示的 **salary** 字段不能从类的外部直接访问：

```
    val e = Employee("Steve Jobs", 1)
    
    // to access the salary field you have to use getSalary 
    e.name                          // Steve Jobs 
    e.getSalary(WorkerBee)          // None 
    e.getSalary(HumanResources)     // Some(1.0)
    
    e.salary    // error: variable salary in class Employee cannot be accessed
```

### 讨论

如果这些都让人感到困惑，那么想想编译器在生成代码时的选择就会对理解这些有所帮助。当一个字段被定义为 **val** 时，根据定义，它的值不能被改变，所以只生成一个getter，而不生成setter是合理的。同样，根据定义， **var** 字段的值 *可以* 被改变，所以生成getter和setter是说得过去的。

构造函数参数可以被设置成 **private** 给了开发人员额外的灵活性。当它被添加到 **val** 或 **var** 字段时，getter和setter方法会像以前一样被生成，但会被标记为私有。如果不在构造函数参数上指定 **val** 或 **var** ，根本不会生成任何getter或setter方法。

表5-1中总结了根据这些设置会生成的访问字段和修改字段方法。

*表5-1 构造函数参数设置的效果*

| 参数的设置                 | 访问字段方法 | 修改字段方法 |
| -------------------------- | ------------ | ------------ |
| var                        | 有           | 有           |
| val                        | 有           | 没有         |
| 默认（既没有var也没有val） | 没有         | 没有         |
| var或val上有private        | 没有         | 没有         |

#### 样例类

样例类构造函数中的参数与这些规则有一个不同之处：样例类构造函数参数默认为 **val** 。因此，如果定义一个样例类字段而不添加 **val** 或 **var** ，像这样：

```
    case class Person(name: String)
```

仍然可以访问这个字段，就像它被定义为一个 **val** 一样：

```
    scala> val p = Person("Dale Cooper")
    p: Person = Person(Dale Cooper)
    
    scala> p.name 
    res0: String = Dale Cooper
```

虽然这与普通的类不同，但它很便利，并且与函数式编程中使用样例类的方式有关，即作为不可变的记录。

### 另见

- 关于手动添加自己的访问字段和修改字段方法的更多信息，请参见5.11小节；关于 **private** 修饰的更多信息，请参见5.3小节。
- 关于样例类原理的更多信息，见5.14小节。

## 5.4 定义类的辅助构造函数

### 问题

为一个类定义一个或多个辅助构造函数，这样类的使用者就可以有多种方式来创建对象实例。

### 解决方案

将辅助构造函数定义为类中的方法，其名称为 **this** 并有合适的签名。可以定义多个辅助构造函数，但它们必须有不同的签名（参数列表）。另外，每个构造函数必须调用已经定义过的构造函数。

举个例子，假设这里有两个枚举定义，将在后面的 **Pizza** 类中使用。

```
    enum CrustSize:
        case Small, Medium, Large
        
    enum CrustType:
        case Thin, Regular, Thick
```

根据上面的定义，下面有一个 **Pizza** 类，有一个主构造函数和三个辅助构造函数。

```
    import CrustSize.*, CrustType.*
    
    // primary constructor
    class Pizza (var crustSize: CrustSize, var crustType: CrustType):
    
        // one-arg auxiliary constructor
        def this(crustSize: CrustSize) = 
            this(crustSize, Pizza.DefaultCrustType)
            
        // one-arg auxiliary constructor 
        def this(crustType: CrustType) = 
            this(Pizza.DefaultCrustSize, crustType)
            
        // zero-arg auxiliary constructor 
        def this() = 
            this(Pizza.DefaultCrustSize, Pizza.DefaultCrustType)
            
        override def toString = s"A $crustSize pizza with a $crustType crust"
        
        object Pizza:
            val DefaultCrustSize = Medium 
            val DefaultCrustType = Regular
```

基于上面这些构造函数，可以通过以下方式创建相同的比萨：

```
    import Pizza.{DefaultCrustSize, DefaultCrustType}
    
    // use the different constructors 
    val p1 = Pizza(DefaultCrustSize, DefaultCrustType) 
    val p2 = Pizza(DefaultCrustSize) 
    val p3 = Pizza(DefaultCrustType) 
    val p4 = Pizza
```

所有这些定义的输出结果是相同的：

```
    A Medium pizza with a Regular crust
```

### 讨论

这个小节有以下几个要点：

- 辅助构造函数是通过创建名为 **this** 的方法来定义的。
- 每个辅助构造函数必须以调用先前定义过的构造函数为开始。
- 每个构造函数参数列表必须不同。
- 一个构造函数使用方法名 **this** 调用另一个构造函数，并指定所需参数。

在所示的例子中，所有的辅助构造函数都调用主构造函数，但这不是必须的；辅助构造函数只需要调用先前定义的构造函数之一即可。例如，接受 **crustType** 参数的辅助构造函数可以被写成调用参数为 **CrustSize** 的构造函数。

```
    def this(crustType: CrustType) =
        this(Pizza.DefaultCrustSize) 
        this.crustType = Pizza.DefaultCrustType
```

#### 不要忘记构造函数参数可以有默认值（鸟图）

尽管 "解决方案 "中所示的方法是完全有效的，但在创建这样的多个类构造函数之前，请花些时间阅读5.6小节。如该小节所示，使用默认参数值通常可以消除对多个构造函数的需要。例如，这种方法与解决方案中所示的类具有几乎相同的功能。

```
    class Pizza( 
        var crustSize: CrustSize = Pizza.DefaultCrustSize, 
        var crustType: CrustType = Pizza.DefaultCrustType 
    ):
        override def toString = 
            s"A $crustSize pizza with a $crustType crust"
```

## 5.5 定义一个私有的主构造函数

### 问题

把一个类的主构造函数变成私有的，比如说为了编写一个单例。

### 解决方案

要使主构造函数成为私有的，在类名和构造函数参数之间插入 **private** 关键字。

```
    // a private one-arg primary constructor 
    class Person private (var name: String)
```

如REPL所示，这样就无法创建一个类的实例了：

```
    scala> class Person private(name: String) 
    defined class Person
    
    scala> val p = Person("Mercedes")
    1 |val p = Person("Mercedes")
      | ^^ 
      |method apply cannot be accessed as a member of Person.type
```

当我第一次看到这种语法时，我觉得它有点不自然，但如果在看代码时将其读出来，会读成："这是有一个 *私有构造函数* 的 **Person** 类......" 我发现这句话中的 "私有构造函数 "可以帮助我记住在构造函数参数紧跟在 **private** 关键字之后。

### 讨论

为了在Scala中实现单例模式，可以将主构造函数设为 **private** ，然后在类的同伴对象中创建一个 **getInstance** 方法。

```
    // a private constructor that takes no parameters 
    class Brain private:
        override def toString = "This is the brain."
    
    object Brain:
        val brain = Brain() 
        def getInstance = brain

@main def singletonTest =
    // this won’t compile because the constructor is private: 
    // val brain = Brain()
    
    // this works:
    val brain = Brain.getInstance 
    println(brain)
```

访问方法的名字不一定非得是 **getInstance** ；这里只是因为Java的惯例是这么命名的。当然也可以给它起一个你认为最好的名字。

#### 伴随对象（鸟图）

*伴随对象* 是指与一个 **类** 定义在同一个文件中，并且与该类有相同名称的 **对象**。如果在一个名为 *Foo.scala* 的文件中声明一个名为 **Foo** 的类，然后在同一个文件中声明一个名为 **Foo** 的对象，那么 **Foo** 对象就是 **Foo** 类的伴随对象。

伴随对象可用于几个目的，其中一个目的是，在伴随对象中声明的任何方法都将做为对象的静态方法。7.4小节，"用伴随对象创建静态成员"，描述了更多关于创建相当于Java静态方法的信息。7.6小节，"用apply实现静态工厂"，描述了如何（以及为什么）在伴随对象中定义apply方法的例子。

#### 工具类

根据要完成的任务，可能创建一个私有类的构造函数根本就没有必要。比如，在Java中，可以通过在Java类中定义 **静态** 方法来创建一个 *文件工具类* ，但在Scala中，可以通过将这些方法放在Scala *对象* 中来做同样的事情：

```
    object FileUtils:
        def readFile(filename: String): String = ???
        def writeFile(filename: String, contents: String): Unit = ???
```

这让代码的使用者可以不需要创建一个 **FileUtils** 类的实例而是直接调用这些方法。

```
    val contents = FileUtils.readFile("input.txt") 
    FileUtils.writeFile("output.txt", content)
```

在这种情况不需要一个私有类的构造函数；只要不定义一个类就可以了。

## 5.6 为构造函数参数提供默认值

### 问题

为一个构造函数参数提供一个默认值，这让这个类的使用者可以选择在调用构造函数时可以不指定该参数的值。

### 解决方案

在构造函数声明中给参数一个默认值。下面是一个 **Socket** 类的声明，它有一个 **timeout** 的构造参数，其默认值为 **10_000** 。

```
    class Socket(val timeout: Int = 10_000)
```

因为该参数定义了默认值，所以可以调用构造函数而不指定超时值，在这种情况下，其值就是默认值：

```
    val s = Socket()
    s.timeout // Int = 10000
```

也可以在创建一个新的 **Socket** 时指定一个所需的超时值：

```
    val s = Socket(5_000)
    s.timeout // Int = 5000
```

### 讨论

这小节展示了一个强大的功能，可以消除对辅助构造函数的需求。如解决方案中所示，下面的单个构造函数相当于两个构造函数：

```
    class Socket(val timeout: Int = 10_000) 
    val s = Socket() 
    val s = Socket(5_000)
```

如果没有这个功能，就需要两个构造函数来获得同样的功能——一个需要单个参数的主构造函数和一个零参数的辅助构造函数：

```
    class Socket(val timeout: Int):
       def this() = this(10_000)
```

#### 多参数情况

当然也可以为多个构造函数参数提供默认值：

```
    class Socket(val timeout: Int = 1_000, val linger: Int = 2_000):
        override def toString = s"timeout: $timeout, linger: $linger"
```

尽管只定义了一个构造函数，但这个类现在看起来有三个构造函数：

```
    println(Socket())               // timeout: 1000, linger: 2000
    println(Socket(3_000))          // timeout: 3000, linger: 2000
    println(Socket(3_000, 4_000))   // timeout: 3000, linger: 4000
```

如8.3小节 "调用方法时使用参数名 "所示，如果愿意的话，也可以在创建类实例时提供构造函数参数的名称。

```
    Socket(timeout=3_000, linger=4_000) 
    Socket(linger=4_000, timeout=3_000) 
    Socket(timeout=3_000) 
    Socket(linger=4_000)
```

## 5.7 继承类时构造函数的处理

### 问题

当扩展一个有构造函数参数的基类时新子类可能需要额外的构造函数参数。

### 解决方案

在解决方案中，将介绍扩展一个有多个 **val** 构造函数参数的类的情形，处理定义为 **var** 的构造函数参数的情况更为复杂，将在讨论中处理。

#### 处理构造函数是val的情形

假设基类构造函数只有 **val** 参数，当定义其子类的构造函数时，不要在两个类共有的字段上声明 **val** 。只要在子类中定义的新的构造函数参数声明为 **val**（或 **var** ）字段即可。

为了演示这一情形，首先定义一个 **Person** 基类，它有一个 **val** 参数是 **name** 。

```
    class Person(val name: String)
```

接下来，将 **Employee** 定义为 **Person** 的一个子类，它接受构造函数参数 **name** 和一个 **age** 的新参数。 **name** 参数在父类 **Person** 中也是被使用的，所以不要对该字段进行 **val** 声明，但 **age** 是新的，所以要将其声明为一个 **val** 。

```
    class Employee(name: String, val age: Int) extends Person(name):
        override def toString = s"$name is $age years old"
```

现在可以这样创建一个新的 **Employee** 了：

```
    scala> val joe = Employee("Joe", 33)
    val joe: Employee = Joe is 33 years old
```

和预期的一样。而且由于字段是不可变的，所以没有其他问题。

### 讨论

当基类中的构造函数参数被定义为一个 **var** 字段时，情况就比较复杂了。有两种解决方案：

- 将子类中对应的字段命名成不同的名字；
- 在伴随对象中定义 **apply** 方法来实现子类的构造函数。

#### 将子类中对应的字段命名成不同的名字

第一种方法是在子类构造函数中为公共字段使用一个不同的名字。例如，在这个例子中，在 **Employee** 的构造函数中使用 **_name** ，而不是使用 **name** 。

```
    class Person(var name: String)
    
    // note the use of '_name' here 
    class Employee(_name: String, var age: Int) extends Person(_name):
        override def toString = s"$name is $age"
```

原因是 **Employee** 类中的这个构造函数参数（ **_name** ）最终被生成为 **Employee** 类中的一个字段。如果对 **Employee.class** 文件进行反编译，就可以看到这一点：

```
    $ javap -private Employee 
    public class Employee extends Person {
        private final java.lang.String _name; 
        private final int age; 
        public Employee(java.lang.String, int); 
        public int age();
        public java.lang.String toString();
    }
```

如果把这个字段命名为 **name** ， **Employee** 类中的这个字段就会覆盖 **Person** 类中的 **name** 字段。这会造成一些问题，比如在这个例子的最后看到的不一致的结果：

```
    class Person(var name: String)
    
    // i incorrectly use 'name' here, rather than '_name'
    class Employee(name: String, var age: Int) extends Person(name):
        override def toString = s"$name is $age years old"
        
    // everything looks OK at first 
    val e = Employee("Joe", 33) 
    e // Joe is 33 years old
    
    // but problems show up when i update the 'name' field
    e.name = "Fred"
    e.age = 34
    e // "Joe is 34 years old" <-- error: this should be "Fred"
    e.name // "Fred" <-- this is "Fred"
```

在这个例子中发生这种情况是因为在 **Employee** 中（不正确地）命名了字段名，而这个名字与 **Person** 中的 **name** 相冲突了。所以，当扩展一个有 **var** 构造函数参数的类时，需要在子类中为该字段使用不同的名字。

#### 这会创建一个私有的val字段（鸟图）

在这个例子中，所示方法在 **Employee** 类中创建了一个名为 **_name** 的私有 **val** 字段。然而，这个字段在这个类之外不能被访问，所以这是一个相对小的问题。只要不使用这个字段，就不会有什么问题。

#### 在伴随对象中使用apply方法

因为该方案在 **Employee** 类中创建了一个私有 **val** 字段 **_name** ，一些读者可能更喜欢另一个方案。

另一个方案是这样的：

- 将 **Employee** 构造函数设为 **私有** 
- 在 **Employee** 的伴随对象中创建一个 **apply** 方法作为构造函数

例如，这个 **Person** 类有一个 **var** 参数 **name** ：

```
    class Person(var name: String):
        override def toString = s"$name"
```

可以在 **Employee** 类中创建一个私有构造函数，并在其伴随对象中创建一个 **apply** 方法，像这样:

```
    class Employee private extends Person(""):
        var age = 0 
        println("Employee constructor called")
        override def toString = s"$name is $age"
    
    object Employee:
        def apply(_name: String, _age: Int) = 
            val e = new Employee() 
            e.name = _name 
            e.age = _age 
            e
```

下面这些代码会如我们所希望的运行：

```
    val e = Employee("Joe", 33) 
    e // Joe is 33 years old
    
    // update and verify the name and age fields
    e.name = "Fred"
    e.age = 34
    e // "Fred is 34 years old"
    e.name // "Fred"
```

这种方法允许 **Employee** 类从 **Person** 类中继承 **name** 字段，并且不需像前面的解决方案那样要使用 **_name** 。其代价是，这种方法需要写更多的代码，尽管它是一种更清晰的方法。

总之，如果要扩展一个只有 **val** 构造函数参数的类，请使用前面解决方案中提到的方法。但是，如果要扩展一个有 **var** 构造函数参数的类，请使用讨论中所示的两种解决方法中的一个。

