# 22. Scala与Java集成

本书完成于2021年，因此本章主要介绍Scala 3和Java 11的集成，后者是Oracle目前的长期支持版本。Java版本的要点在于，目前Oracle每年都有两个主要的Java版本发布计划。

一般来说，Scala和Java代码是可以无缝混合的。在大多数情况下，可以创建一个sbt项目，把Scala代码放在 *src/main/scala* 中，把Java代码放在 *src/main/java* 中，就可以正常工作了。

本章中的小节涵盖了转换器、特质和接口、异常、数字类型的转换等问题。

在作者与Scala/Java的集成的经验中，遇到的最大问题是它们的集合库之间的差异。然而，总是能够通过Scala的 **CollectionConverters** 对象来解决这些问题。从Scala 2.13开始，现在有两个 **CollectionConverters**对象：

- Scala代码中使用的扩展方法在 **scala.jdk.Collection Converters** 中。
- Java代码的转换方法在 **scala.jdk.javaapi.Collection Converters** 中。

同样，Scala的 **Option** 和Java的 **Optional** 之间的转换方法也由这些转换对象来处理：

- Scala的扩展方法在 **scala.jdk.OptionConverters** 中。
- Java的转换方法在 **scala.jdk.javaapi.OptionConverters** 中。

这些转换方法在本章的初始小节中展示。

在转换相关的小节之后，小节 22.5和22.6深入探讨了Scala traits和Java接口之间的关系。由于Java 8或更高版本中接口的特性，traits和接口比 *Scala Cookbook* 第一版中更加紧密地结合在一起。

Scala和Java之间的其他方面集成需要使用注解，这些在关于异常（ **@throws** ）、varargs参数（ **@varargs** ）和序列化（ **@SerialVersionUID** ）的小节中都有涉及。

最后，如果对Java很熟悉，但对Scala很陌生，那么有必要提一下，Scala中的所有东西都是一个对象。具体来说就是意味着Scala没有原始的数字数据类型。如图22-1所示，在Scala REPL中输入数字1，然后输入小数点，再按Tab键，REPL就会显示 **Int** 实例上的所有方法。

![1](./images/ch22/1.png)

图 22-1 在Scala中，所有东西都是一个对象，即使整数也是。

## 22.1 在Scala中使用Java集合对象

### 问题

在Scala应用程序中使用Java类，而这些类要么返回Java集合，要么在其方法调用中需要Java集合，需要将这些与Scala集合的使用结合起来。

### 解决方案

在Scala代码中使用 **scala.jdk.CollectionConverters** 对象的扩展方法来实现转换。例如，如果在一个名为 **JavaCollections** 的公有Java类中有一个这样的 **getNumbers** 的方法：

```
    // java 
    public static List<Integer> getNumbers() {
        return new ArrayList<Integer>(List.of(1,2,3));
    }
```

可以在Scala代码中把这个Java列表转换成Scala **Seq**，就像这样：

```
    // scala 
    import scala.jdk.CollectionConverters.* 
    import java.util.List

    def testList =
        println("Using a Java List in Scala") 
        val jlist: java.util.List[Integer] = JavaCollections.getNumbers 
        // jlist.getClass is "class java.util.ArrayList"

        // note that this is `Seq[Integer]` and not `Seq[Int]`: 
        val slist: Seq[Integer] = jlist.asScala.toSeq 
        slist.foreach(println)
```

同样地，如果有一个Java方法，返回一个 **Map** ：

```
    // java 
    public static Map<String, String> getPeeps() { 
        return new HashMap<String, String>(Map.of( 
            "Captain", "Kirk", 
            "Mr.", "Spock" 
        )); 
    }
```

可以像这样将其转换为Scala **Map** ：

```
    // scala 
    import scala.jdk.CollectionConverters.* 
    import java.util.{Map => JavaMap} 
    import scala.collection.mutable.{Map => ScalaMap}
    
    @main def testMap =
        println("use a Java Map in Scala") 
        val jmap: JavaMap[String,String] = JavaCollections.getPeeps 
        val smap: ScalaMap[String,String] = jmap.asScala 
        for (k,v) <- smap do println(s"key: '$k', value: '$v'")
```

同样地，这个例子展示了如何将Java **Properties** 对象转换为Scala **Map** 。

```
    // [1] create and populate a Java Properties object 
    val javaProps = new java.util.Properties 
    javaProps.put("first_name", "Charles") 
    javaProps.put("last_name", "Carmichael")
    
    // [2] convert Java Properties to Scala Map 
    import scala.jdk.CollectionConverters.* 
    val scalaProps = javaProps.asScala println(scalaProps)
```

println语句会打印出这样的输出：

```
    Map(last_name -> Carmichael, first_name -> Charles)
```

### 讨论

本小节展示了如何在Scala中进行集合转换。要在Java代码中进行转换，请看下一个小节。

#### 类型转换

解决方案中的第一个例子展示了如何从 **Java.util.List\<Integer\>** 创建一个Scala **Seq[Integer]** ：

```
    val slist: Seq[Integer] = jlist.asScala.toSeq
```

假设真的想要一个 **Seq[Int]** -而不是 **Seq[Integer]** -需要在代码中添加一个 **Integer** 到 **Int** 的转换过程。

```
    def integer2Int(i: Integer): Int = i

    val jlist2: java.util.List[Integer] = MyJavaClass.getNumbers() 
    val slist2: Seq[Int] = jlist2.asScala.map(i => integer2Int(i)).toSeq
```

这段代码的作用如下：

- 创建一个 **jlist2** 其类型为 **java.util.List[Integer]** 。
- 使用 **asScala** 将该代码转换为Scala的 **Buffer[Integer]** 。
- 用 **map** 方法和 **integer2Int** 函数将 **Buffer[Integer]** 转换为 **Buffer[Int]** 。
- 通过调用 **toSeq** 创建最终的 **Seq[Int]** 。

#### 转换方法

像这样的代码之所以能够工作，是因为 **CollectionConverters** 对象中的转换方法。表22-1显示了使用 **asScala** 和 **asJava** 方法所能进行的双向转换：

*表22-1，**scala.jdk.CollectionConverters** 对象所提供的双向转换功能*

| Scala 集合                      | Java 集合                          |
| ------------------------------- | ---------------------------------- |
| scala.collection.Iterable       | java.lang.Iterable                 |
| scala.collection.Iterator       | java.util.Iterator                 |
| scala.collection.mutable.Buffer | java.util.List                     |
| scala.collection.mutable.Set    | java.util.Set                      |
| scala.collection.mutable.Map    | java.util.Map                      |
| scala.collection.concurrent.Map | java.util.concurrent.ConcurrentMap |

例如，可以使用 **asJava** 将Scala **Buffer** 转换为Java **List** ，也可以使用 **asScala** 进行相反的转换。

表22-2显示了额外的双向转换。用 **asScala** 支持向Scala的转换，特别命名的扩展方法让你把Scala集合转换为Java集合。

*表22-2 额外的双向转换，包括特别命名的方法*

| Scala 集合                   | Java 集合                                      |
| ---------------------------- | ---------------------------------------------- |
| scala.collection.Iterable    | java.util.Collection (通过 asJavaCollection)   |
| scala.collection.Iterator    | java.util.Enumeration (通过 asJavaEnumeration) |
| scala.collection.mutable.Map | java.util.Dictionary (通过 asJavaDictionary)   |

表22-3 列出了用 **asJava** 可以实现的单向转换。

*表22-3 **CollectionConverters** 类提供的从Scala 到 Java的单向转换*

| Scala集合                    | Java集合       |
| ---------------------------- | -------------- |
| scala.collection.Seq         | java.util.List |
| scala.collection.mutable.Seq | java.util.List |
| scala.collection.Set         | java.util.Set  |
| scala.collection.Map         | java.util.Map  |

表22-4 列出了用 **asScala** 可以实现的单向转换。

*表22-4 **asScala** 提供的单向转换*

| Scala集合            | Java 集合                                  |
| -------------------- | ------------------------------------------ |
| java.util.Properties | scala.collection.mutable.Map[String,String |

### 另见

- scala.jdk.CollectionConverters 提供从 Java 到 Scala 的转换
- scala.javaapi.CollectionConverters 提供从 Scala 到 Java 的转换
- scala.jdk.javaapi.StreamConverters 用于创建可以与 Scala 一起工作的 Java 流

## 22.2 在Java中使用Scala集合

### 问题

需要在Java应用程序中访问Scala集合类，并将这些Scala类转换为Java类。

### 解决方案

在Java代码中，使用Scala的 **scala.javaapi.CollectionConverters** 对象的方法来实现转换的工作。例如，如果在Scala类中有一个像这样的 **List[String]** ：

```
    // scala 
    class ScalaClass:
        val strings = List("a", "b")
```

可以像这样在Java代码中访问Scala的 **List** ：

```
    // java 
    import scala.jdk.javaapi.CollectionConverters;
    
    ScalaClass sc = new ScalaClass();
    
    // access the `strings` field as `sc.strings()`
    scala.collection.immutable.List<String> xs = sc.strings();
    
    // create a Java List<String>
    java.util.List<String> listOfStrings = CollectionConverters.asJava(xs);
```

关于这段代码，有几点需要注意：

- 在Java代码中，创建一个 **ScalaClass** 的实例，就像创建一个Java类的实例一样。
- **ScalaClass** 有一个名为 **strings** 的字段，但在Java中，必须以方法的形式访问这个字段的，比如说， **sc.strings()** 。

这里把这段代码写得很长，是为了帮助强调这些要点，也可以像这样一步到位地进行转换：

```
    java.util.List<String> listOfStrings2 = CollectionConverters.asJava(
        (new ScalaClass()).strings()
    );
```

### 讨论

本小节展示了如何在Java中进行集合转换。要在Scala代码中进行转换，请参见前面的小节。

在某些情况下，会遇到类型擦除的问题。例如，鉴于Scala类中的这个ints字段：

```
    class ScalaClass:
        val ints = Seq(1,2,3)
```

必须将Scala **Seq** 作为Java中的 **List\<Object\>** 来访问：

```
    // java 
    ScalaClass sc = new ScalaClass();
    java.util.List<Object> listInt = CollectionConverters.asJava(sc.ints());
    
    // this also works 
    java.util.List listInt = CollectionConverters.asJava(sc.ints());
```

当用 **scalac** 编译Scala类，然后用 **javap** 反汇编时，就可以看到类型擦除的问题，会看到这样的代码：

``` 
    public scala.collection.immutable.Seq<java.lang.Object> ints();
```

如图所示，该类文件只知道有一个 **ints()** 方法返回 **Seq<java.lang.Object>** 。

如果读者接触过Scala的源代码，就知道可以先将 **Seq[Int]** 转换为 **Seq[Integer]** ，从而使其更容易从Java中访问：

```
    // in a scala class 
    val jIntegers: Seq[java.lang.Integer] = Seq(1,2,3).map(i => i:java.lang.Integer)
```

现在可以像这样在一个Java类中以 **List\<Integer\>** 的形式访问它：

```
    // java
    java.util.List<Integer> listIntegers =
        CollectionConverters.asJava(sc.jIntegers());
```

如果不能修改Scala代码，可能要进行其他与强制类型转换有关的工作来处理 **java.util.List\<Object\>** ，这取决于实际需求

### 另见

**scala.jdk.javaapi.CollectionConverters** 对象所支持的双向转换与前面的小节中所示的 **scala.jdk.CollectionConverters** 对象相同。关于这些转换，请参见前面的小节，更多细节请参见这些链接：

- scala.jdk.CollectionConverters 提供从 Java 到 Scala 的转换
- scala.javaapi.CollectionConverters 提供从 Scala 到 Java 的转换
- scala.jdk.javaapi.StreamConverters 用于创建可以与 Scala 一起工作的 Java 流