# 22. Scala与Java集成

本书完成于2021年，因此本章主要介绍Scala 3和Java 11的集成，后者是Oracle目前的长期支持版本。Java版本的要点在于，目前Oracle每年都有两个主要的Java版本发布计划。

一般来说，Scala和Java代码是可以无缝混合的。在大多数情况下，可以创建一个sbt项目，把Scala代码放在 *src/main/scala* 中，把Java代码放在 *src/main/java* 中，就可以正常工作了。

本章中的小节涵盖了转换器、特质和接口、异常、数字类型的转换等问题。

在作者与Scala/Java的集成的经验中，遇到的最大问题是它们的集合库之间的差异。然而，总是能够通过Scala的 **CollectionConverters** 对象来解决这些问题。从Scala 2.13开始，现在有两个 **CollectionConverters**对象：

- Scala代码中使用的扩展方法在 **scala.jdk.Collection Converters** 中。
- Java代码的转换方法在 **scala.jdk.javaapi.Collection Converters** 中。

同样，Scala的 **Option** 和Java的 **Optional** 之间的转换方法也由这些转换对象来处理：

- Scala的扩展方法在 **scala.jdk.OptionConverters** 中。
- Java的转换方法在 **scala.jdk.javaapi.OptionConverters** 中。

这些转换方法在本章的初始小节中展示。

在转换相关的小节之后，小节 22.5和22.6深入探讨了Scala traits和Java接口之间的关系。由于Java 8或更高版本中接口的特性，traits和接口比 *Scala Cookbook* 第一版中更加紧密地结合在一起。

Scala和Java之间的其他方面集成需要使用注解，这些在关于异常（ **@throws** ）、varargs参数（ **@varargs** ）和序列化（ **@SerialVersionUID** ）的小节中都有涉及。

最后，如果对Java很熟悉，但对Scala很陌生，那么有必要提一下，Scala中的所有东西都是一个对象。具体来说就是意味着Scala没有原始的数字数据类型。如图22-1所示，在Scala REPL中输入数字1，然后输入小数点，再按Tab键，REPL就会显示 **Int** 实例上的所有方法。

![1](./images/ch22/1.png)

图 22-1 在Scala中，所有东西都是一个对象，即使整数也是。

## 22.1 在Scala中使用Java集合对象

### 问题

在Scala应用程序中使用Java类，而这些类要么返回Java集合，要么在其方法调用中需要Java集合，需要将这些与Scala集合的使用结合起来。

### 解决方案

在Scala代码中使用 **scala.jdk.CollectionConverters** 对象的扩展方法来实现转换。例如，如果在一个名为 **JavaCollections** 的公有Java类中有一个这样的 **getNumbers** 的方法：

```
    // java 
    public static List<Integer> getNumbers() {
        return new ArrayList<Integer>(List.of(1,2,3));
    }
```

可以在Scala代码中把这个Java列表转换成Scala **Seq**，就像这样：

```
    // scala 
    import scala.jdk.CollectionConverters.* 
    import java.util.List

    def testList =
        println("Using a Java List in Scala") 
        val jlist: java.util.List[Integer] = JavaCollections.getNumbers 
        // jlist.getClass is "class java.util.ArrayList"

        // note that this is `Seq[Integer]` and not `Seq[Int]`: 
        val slist: Seq[Integer] = jlist.asScala.toSeq 
        slist.foreach(println)
```

同样地，如果有一个Java方法，返回一个 **Map** ：

```
    // java 
    public static Map<String, String> getPeeps() { 
        return new HashMap<String, String>(Map.of( 
            "Captain", "Kirk", 
            "Mr.", "Spock" 
        )); 
    }
```

可以像这样将其转换为Scala **Map** ：

```
    // scala 
    import scala.jdk.CollectionConverters.* 
    import java.util.{Map => JavaMap} 
    import scala.collection.mutable.{Map => ScalaMap}
    
    @main def testMap =
        println("use a Java Map in Scala") 
        val jmap: JavaMap[String,String] = JavaCollections.getPeeps 
        val smap: ScalaMap[String,String] = jmap.asScala 
        for (k,v) <- smap do println(s"key: '$k', value: '$v'")
```

同样地，这个例子展示了如何将Java **Properties** 对象转换为Scala **Map** 。

```
    // [1] create and populate a Java Properties object 
    val javaProps = new java.util.Properties 
    javaProps.put("first_name", "Charles") 
    javaProps.put("last_name", "Carmichael")
    
    // [2] convert Java Properties to Scala Map 
    import scala.jdk.CollectionConverters.* 
    val scalaProps = javaProps.asScala println(scalaProps)
```

println语句会打印出这样的输出：

```
    Map(last_name -> Carmichael, first_name -> Charles)
```

### 讨论

本小节展示了如何在Scala中进行集合转换。要在Java代码中进行转换，请看下一个小节。

#### 类型转换

解决方案中的第一个例子展示了如何从 **Java.util.List\<Integer\>** 创建一个Scala **Seq[Integer]** ：

```
    val slist: Seq[Integer] = jlist.asScala.toSeq
```

假设真的想要一个 **Seq[Int]** -而不是 **Seq[Integer]** -需要在代码中添加一个 **Integer** 到 **Int** 的转换过程。

```
    def integer2Int(i: Integer): Int = i

    val jlist2: java.util.List[Integer] = MyJavaClass.getNumbers() 
    val slist2: Seq[Int] = jlist2.asScala.map(i => integer2Int(i)).toSeq
```

这段代码的作用如下：

- 创建一个 **jlist2** 其类型为 **java.util.List[Integer]** 。
- 使用 **asScala** 将该代码转换为Scala的 **Buffer[Integer]** 。
- 用 **map** 方法和 **integer2Int** 函数将 **Buffer[Integer]** 转换为 **Buffer[Int]** 。
- 通过调用 **toSeq** 创建最终的 **Seq[Int]** 。

#### 转换方法

像这样的代码之所以能够工作，是因为 **CollectionConverters** 对象中的转换方法。表22-1显示了使用 **asScala** 和 **asJava** 方法所能进行的双向转换：

*表22-1，**scala.jdk.CollectionConverters** 对象所提供的双向转换功能*

| Scala 集合                      | Java 集合                          |
| ------------------------------- | ---------------------------------- |
| scala.collection.Iterable       | java.lang.Iterable                 |
| scala.collection.Iterator       | java.util.Iterator                 |
| scala.collection.mutable.Buffer | java.util.List                     |
| scala.collection.mutable.Set    | java.util.Set                      |
| scala.collection.mutable.Map    | java.util.Map                      |
| scala.collection.concurrent.Map | java.util.concurrent.ConcurrentMap |

例如，可以使用 **asJava** 将Scala **Buffer** 转换为Java **List** ，也可以使用 **asScala** 进行相反的转换。

表22-2显示了额外的双向转换。用 **asScala** 支持向Scala的转换，特别命名的扩展方法让你把Scala集合转换为Java集合。

*表22-2 额外的双向转换，包括特别命名的方法*

| Scala 集合                   | Java 集合                                      |
| ---------------------------- | ---------------------------------------------- |
| scala.collection.Iterable    | java.util.Collection (通过 asJavaCollection)   |
| scala.collection.Iterator    | java.util.Enumeration (通过 asJavaEnumeration) |
| scala.collection.mutable.Map | java.util.Dictionary (通过 asJavaDictionary)   |

表22-3 列出了用 **asJava** 可以实现的单向转换。

*表22-3 **CollectionConverters** 类提供的从Scala 到 Java的单向转换*

| Scala集合                    | Java集合       |
| ---------------------------- | -------------- |
| scala.collection.Seq         | java.util.List |
| scala.collection.mutable.Seq | java.util.List |
| scala.collection.Set         | java.util.Set  |
| scala.collection.Map         | java.util.Map  |

表22-4 列出了用 **asScala** 可以实现的单向转换。

*表22-4 **asScala** 提供的单向转换*

| Scala集合            | Java 集合                                  |
| -------------------- | ------------------------------------------ |
| java.util.Properties | scala.collection.mutable.Map[String,String |

### 另见

- scala.jdk.CollectionConverters 提供从 Java 到 Scala 的转换
- scala.javaapi.CollectionConverters 提供从 Scala 到 Java 的转换
- scala.jdk.javaapi.StreamConverters 用于创建可以与 Scala 一起工作的 Java 流

## 22.2 在Java中使用Scala集合

### 问题

需要在Java应用程序中访问Scala集合类，并将这些Scala类转换为Java类。

### 解决方案

在Java代码中，使用Scala的 **scala.javaapi.CollectionConverters** 对象的方法来实现转换的工作。例如，如果在Scala类中有一个像这样的 **List[String]** ：

```
    // scala 
    class ScalaClass:
        val strings = List("a", "b")
```

可以像这样在Java代码中访问Scala的 **List** ：

```
    // java 
    import scala.jdk.javaapi.CollectionConverters;
    
    ScalaClass sc = new ScalaClass();
    
    // access the `strings` field as `sc.strings()`
    scala.collection.immutable.List<String> xs = sc.strings();
    
    // create a Java List<String>
    java.util.List<String> listOfStrings = CollectionConverters.asJava(xs);
```

关于这段代码，有几点需要注意：

- 在Java代码中，创建一个 **ScalaClass** 的实例，就像创建一个Java类的实例一样。
- **ScalaClass** 有一个名为 **strings** 的字段，但在Java中，必须以方法的形式访问这个字段的，比如说， **sc.strings()** 。

这里把这段代码写得很长，是为了帮助强调这些要点，也可以像这样一步到位地进行转换：

```
    java.util.List<String> listOfStrings2 = CollectionConverters.asJava(
        (new ScalaClass()).strings()
    );
```

### 讨论

本小节展示了如何在Java中进行集合转换。要在Scala代码中进行转换，请参见前面的小节。

在某些情况下，会遇到类型擦除的问题。例如，鉴于Scala类中的这个ints字段：

```
    class ScalaClass:
        val ints = Seq(1,2,3)
```

必须将Scala **Seq** 作为Java中的 **List\<Object\>** 来访问：

```
    // java 
    ScalaClass sc = new ScalaClass();
    java.util.List<Object> listInt = CollectionConverters.asJava(sc.ints());
    
    // this also works 
    java.util.List listInt = CollectionConverters.asJava(sc.ints());
```

当用 **scalac** 编译Scala类，然后用 **javap** 反汇编时，就可以看到类型擦除的问题，会看到这样的代码：

``` 
    public scala.collection.immutable.Seq<java.lang.Object> ints();
```

如图所示，该类文件只知道有一个 **ints()** 方法返回 **Seq<java.lang.Object>** 。

如果读者接触过Scala的源代码，就知道可以先将 **Seq[Int]** 转换为 **Seq[Integer]** ，从而使其更容易从Java中访问：

```
    // in a scala class 
    val jIntegers: Seq[java.lang.Integer] = Seq(1,2,3).map(i => i:java.lang.Integer)
```

现在可以像这样在一个Java类中以 **List\<Integer\>** 的形式访问它：

```
    // java
    java.util.List<Integer> listIntegers =
        CollectionConverters.asJava(sc.jIntegers());
```

如果不能修改Scala代码，可能要进行其他与强制类型转换有关的工作来处理 **java.util.List\<Object\>** ，这取决于实际需求

### 另见

**scala.jdk.javaapi.CollectionConverters** 对象所支持的双向转换与前面的小节中所示的 **scala.jdk.CollectionConverters** 对象相同。关于这些转换，请参见前面的小节，更多细节请参见这些链接：

- scala.jdk.CollectionConverters 提供从 Java 到 Scala 的转换
- scala.javaapi.CollectionConverters 提供从 Scala 到 Java 的转换
- scala.jdk.javaapi.StreamConverters 用于创建可以与 Scala 一起工作的 Java 流

## 22.3 在Scala中使用Java的Optional值

### 问题

如何在Scala代码中使用Java的 **Optional** 值

### 解决方案

在写Scala代码时，导入 **scala.jdk.OptionConverters** 对象，然后使用扩展方法 **toScala** 将Java **Optional** 值转换为Scala **Option** 。

为了证明这一点，在这里会创建一个有两个 **Optional\<String\>** 值的Java类，一个包含一个字符串，另一个则为空：

```
    // java 
    import java.util.Optional;
    
    public class JavaClass {
        static Optional<String> oString = Optional.of("foo");
        static Optional<String> oEmptyString = Optional.empty();
    }
```

然后在下面的Scala代码中，可以访问这些字段。如果直接访问它们，它们都将是 **Optional** 值：

```
    // scala 
    import java.util.Optional
    
    val optionalString = JavaClass.oString         // Optional[foo]
    val eOptionalString = JavaClass.oEmptyString   // Optional.empty
```

但是通过使用 **scala.jdk.OptionConverters** 方法，可以将其转换成Scala的 **Option** 值：

```
    import java.util.Optional 
    import scala.jdk.OptionConverters.*
    
    val optionalString = JavaClass.oString 
    val optionString = optionalString.toScala
    
    val eOptionalString = JavaClass.oEmptyString 
    val eOptionString = eOptionalString.toScala
```

这种语法之所以有效，是因为 **toScala** 被定义为一个扩展方法，所以可以在Optional实例上调用。

#### 数字值

数字值从Java到Scala的转换也很好实现。假设有以下Java代码：

```
    // java 
    import java.util.Optional; 
    import java.util.OptionalInt;
    
    public class JOptionalNumericToScala {
        static Optional<Integer> oInt = Optional.of(1);
        static Optional<Integer> oEmptyInt = Optional.empty();
        static OptionalInt optionalInt = OptionalInt.of(1);
    }
```

可以在Scala代码中使用如前所述的这些类型为 **Optional\<Integer\>** 或 **OptionalInt** 的字段。

```
    // scala 
    import java.util.Optional
    
    // Optional[Int] 
    val optionalInt = JOptionalNumericToScala.oInt           // Optional[1]
    val optionInt = optionalInt.toScala                      // Some(1)

    // Optional[Int] (empty) 
    val eOptionalInt = JOptionalNumericToScala.oEmptyInt     // Optional.empty
    val eOptionInt = eOptionalInt.toScala                    // None

    // OptionalInt 
    val optionalInt2 = JOptionalNumericToScala.optionalInt   // OptionalInt[1]
    val sOptionalInt2 = optionalInt2.toScala                 // Some(1)
```

### 讨论

在整合时如果能修改Java侧源码，也可以使用 **scala.jdk.javaapi.OptionConverters** 中的转换方法，在Java代码中而不是在Scala代码中把 **Optional** 值转换成 **Option** 值。注意这个对象也被命名为 **OptionConverters** ，但这两个对象是在不同的地方用来转换 **Optional** 值的。

- 在Scala代码中使用 **scala.jdk.OptionConverters**
- 在Java代码中使用 **scala.jdk.javaapi.OptionConverters**

#### 在Java中将Optional转换为Option

下面这个例子展示了如何使用 **scala.jdk.javaapi.OptionConverters** 对象的方法，在Java代码中把 **Optional** 字段转换为 **Option** 值。

```
    // java 
    import java.util.Optional; 
    import java.util.OptionalInt; 
    import scala.jdk.javaapi.OptionConverters; 
    import scala.Option;
    
    public class JOptionalNumericToScala { 
        static Option<Integer> oInt1 = OptionConverters.toScala(Optional.of(1)); 
        static Option<Integer> oInt2 = OptionConverters.toScala(OptionalInt.of(2)); 
    }
```

注意第一个例子使用了 **Optional** ，第二个例子使用了 **OptionalInt** ，两者都转换为了Scala **Option** 。当它们在Java代码中被这样转换后，在Scala代码中就会显示为 **Option** 值：

```
    // scala 
    val oInt1 = JOptionalNumericToScala.oInt1   // Some(1)
    val oInt2 = JOptionalNumericToScala.oInt2   // Some(2)
```

### 另见

用于转换 **Optional** 和 **Option** 值的两个Scala对象是：

- 在Scala代码中使用scala.jdk.OptionConverters
- 在Java代码中使用scala.jdk.javaapi.OptionConverters

## 22.4 在Java中使用Scala的Option值

### 问题

如何在Java代码中使用Scala的 **Option** 值。

### 解决方案

可以在Scala代码中或在Java代码中把一个Scala **Option** 值转换成一个Java **Optional** 值。这里展示的是在Scala中的解决方案，而在JavaVS的解决方案则在讨论中展示。

在Scala代码中，在导入 **scala.jdk.OptionConverters** 后，使用 **toJava** 扩展方法将Scala **Option** 转换为 Java **Optional** 值。

为了证明这一点，这里创建有两个 **Option[String]** 值的Scala类，一个包含一个字符串，另一个是空的，使用* *toJava** 将这些 **Option[String]** 值转换成 **java.util.Optional[String]** ：

```
    // scala 
    import scala.jdk.OptionConverters.*
    
    // create java.util.Optional[String] values
    object Scala:
        // convert a Some to Optional
        val scalaStringSome = Option("foo").toJava
```

然后在Java代码中，直接以 **Optional** 为类型访问这些字段：

```
    // java 
    import java.util.Optional;
    
    Optional<String> stringSome = Scala.scalaStringSome(); // Optional[foo]
    Optional<String> stringNone = Scala.scalaStringNone(); // Optional.empty
```

这两个字段可以作为 **Optional** 值使用，在Java代码中看到的唯一区别是Scala字段（如 **scalaStringSome** ）在Java代码中作为方法出现—— **scalaStringSome()** ，而不是作为字段。

#### 含有数字值的 Option

转换被Scala 数字值的 **Option** 可能要多花点功夫，但它们也还是可以被转换为Java **Optional** 值。**scala.jdk.Option.Converters** 对象为这些情况提供了几种方法。例如，给定这样Scala代码，它创建了 **Optional** 和 **OptionalInt** 值：

```
    // scala 
    import scala.jdk.OptionConverters.*
    
    object Scala:
        val intOptional1 = Option(1).toJava            // Optional[Int], or
                                                       // Optional[Object]
        val optionalInt = Option(1).toJavaPrimitive    // OptionalInt
        val optionalInt2 = optionalInt.toJavaGeneric   // Optional[Int]
```

这些字段可以像这样在Java代码中被访问：

```
    // java 
    import java.util.Optional;
    import java.util.OptionalInt;
    
    Optional intOptional1 = Scala.intOptional1();    // Optional[1]
    OptionalInt optionalInt = Scala.optionalInt();   // OptionalInt[1]
    Optional optionalInt2 = Scala.optionalInt2();    // Optional[1]
```

这个解决方案的关键是，Java代码中的 **Optional** 字段需要以下面这些方式之一来声明：

```
    Optional x = ... 
    Optional<Object> x = ...
    OptionalInt x = ...
```

由于类型擦除，试图像这样声明字段类型将导致编译时错误：

```
    Optional<Integer> intOptional1 = ... // error
```

### 讨论

如果在Java这一侧来做转换，而Scala代码只提供给一个 **Option** 值，可以在Java代码中将其转换成 **Optional** 值。只要使用 **scala.jdk.javaapi.OptionConverters** 对象中的 **toJava*** 方法即可。

#### 同样的名字，不同的包 -- todo （鸟图）

请注意，虽然这个对象与解决方案中显示的对象（ **OptionConverters** ）有相同的名字，但它们在不同的包中，而且这个对象是要在Java代码中使用。

为了演示在Java中把一个 **Option** 转换为一个 **Optional** 值，首先在Scala代码中创建一个 **Option[String]** ：

```
    // scala 
    object Scala:
        val optionString = Option("foo")
```

现在可以在Java代码中使用 **OptionConverters** 的 **toJava** 方法将其转换为 **Optional\<String\>** ：

```
    // java 
    import scala.jdk.javaapi.OptionConverters.toJava;
    Optional<String> stringOptional = toJava(Scala.optionString());
```

除了 **toJava** 之外，可以在Java代码中使用的其他转换方法是：

- **toJavaOptionalDouble** 
- **toJavaOptionalInt**
- **toJavaOptionalLong** 

### 另见

用于转换 **Optional** 和 **Option** 值的两个Scala对象是：

- 在Scala代码中使用scala.jdk.OptionConverters
- 在Java代码中使用scala.jdk.javaapi.OptionConverters