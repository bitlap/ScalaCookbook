# 22. Scala与Java集成

本书完成于2021年，因此本章主要介绍Scala 3和Java 11的集成，后者是Oracle目前的长期支持版本。这一点很重要，因为目前每年都有两个主要的Java版本发布计划。

一般来说，Scala和Java代码是可以无缝混合的。在大多数情况下，可以创建一个sbt项目，把Scala代码放在 *src/main/scala* 中，把Java代码放在 *src/main/java* 中，就可以正常工作了。

本章中的小节涵盖了转换器、特质和接口、异常、数字类型的转换等问题。

在作者与Scala/Java的集成的经验中，遇到的最大问题是它们的集合库之间的差异。然而，总是能够通过Scala的 **CollectionConverters** 对象来解决这些问题。从Scala 2.13开始，现在有两个 **CollectionConverters**对象：

- Scala代码中使用的扩展方法在 **scala.jdk.Collection Converters** 中。
- Java代码的转换方法在 **scala.jdk.javaapi.Collection Converters** 中。

同样，Scala的 **Option** 和Java的 **Optional** 之间的转换方法也由这些转换对象来处理：

- Scala的扩展方法在 **scala.jdk.OptionConverters** 中。
- Java的转换方法在 **scala.jdk.javaapi.OptionConverters** 中。

这些转换方法在本章的初始小节中展示。

在转换相关的小节之后，小节 22.5和22.6深入探讨了Scala traits和Java接口之间的关系。由于Java 8或更高版本中接口的特性，traits和接口比 *Scala Cookbook* 第一版中更加紧密地结合在一起。

Scala和Java之间的其他方面集成需要使用注解，这些在关于异常（ **@throws** ）、varargs参数（ **@varargs** ）和序列化（ **@SerialVersionUID** ）的小节中都有涉及。

最后，如果对Java很熟悉，但对Scala很陌生，那么有必要提一下，Scala中的所有东西都是一个对象。具体来说就是意味着Scala没有原始的数字数据类型。如图22-1所示，在Scala REPL中输入数字1，然后输入小数点，再按Tab键，REPL就会显示 **Int** 实例上的所有方法。

![1](./images/ch22/1.png)

图 22-1 在Scala中，所有东西都是一个对象，即使整数也是。

## 22.1 在Scala中使用Java集合对象

### 问题

在Scala应用程序中使用Java类，而这些类要么返回Java集合，要么在其方法调用中需要Java集合，需要将这些与Scala集合的使用结合起来。

### 解决方案

在Scala代码中使用 **scala.jdk.CollectionConverters** 对象的扩展方法来实现转换。例如，如果在一个名为 **JavaCollections** 的公有Java类中有一个这样的 **getNumbers** 的方法：

```
    // java 
    public static List<Integer> getNumbers() {
        return new ArrayList<Integer>(List.of(1,2,3));
    }
```

可以在Scala代码中把这个Java列表转换成Scala **Seq**，就像这样：

```
    // scala 
    import scala.jdk.CollectionConverters.* 
    import java.util.List

    def testList =
        println("Using a Java List in Scala") 
        val jlist: java.util.List[Integer] = JavaCollections.getNumbers 
        // jlist.getClass is "class java.util.ArrayList"

        // note that this is `Seq[Integer]` and not `Seq[Int]`: 
        val slist: Seq[Integer] = jlist.asScala.toSeq 
        slist.foreach(println)
```

同样地，如果有一个Java方法，返回一个 **Map** ：

```
    // java 
    public static Map<String, String> getPeeps() { 
        return new HashMap<String, String>(Map.of( 
            "Captain", "Kirk", 
            "Mr.", "Spock" 
        )); 
    }
```

可以像这样将其转换为Scala **Map** ：

```
    // scala 
    import scala.jdk.CollectionConverters.* 
    import java.util.{Map => JavaMap} 
    import scala.collection.mutable.{Map => ScalaMap}
    
    @main def testMap =
        println("use a Java Map in Scala") 
        val jmap: JavaMap[String,String] = JavaCollections.getPeeps 
        val smap: ScalaMap[String,String] = jmap.asScala 
        for (k,v) <- smap do println(s"key: '$k', value: '$v'")
```

同样地，这个例子展示了如何将Java **Properties** 对象转换为Scala **Map** 。

```
    // [1] create and populate a Java Properties object 
    val javaProps = new java.util.Properties 
    javaProps.put("first_name", "Charles") 
    javaProps.put("last_name", "Carmichael")
    
    // [2] convert Java Properties to Scala Map 
    import scala.jdk.CollectionConverters.* 
    val scalaProps = javaProps.asScala println(scalaProps)
```

println语句会打印出这样的输出：

```
    Map(last_name -> Carmichael, first_name -> Charles)
```

### 讨论

本小节展示了如何在Scala中进行集合转换。要在Java代码中进行转换，请看下一个小节。

#### 类型转换

解决方案中的第一个例子展示了如何从 **Java.util.List\<Integer\>** 创建一个Scala **Seq[Integer]** ：

```
    val slist: Seq[Integer] = jlist.asScala.toSeq
```

假设真的想要一个 **Seq[Int]** -而不是 **Seq[Integer]** -需要在代码中添加一个 **Integer** 到 **Int** 的转换过程。

```
    def integer2Int(i: Integer): Int = i

    val jlist2: java.util.List[Integer] = MyJavaClass.getNumbers() 
    val slist2: Seq[Int] = jlist2.asScala.map(i => integer2Int(i)).toSeq
```

这段代码的作用如下：

- 创建一个 **jlist2** 其类型为 **java.util.List[Integer]** 。
- 使用 **asScala** 将该代码转换为Scala的 **Buffer[Integer]** 。
- 用 **map** 方法和 **integer2Int** 函数将 **Buffer[Integer]** 转换为 **Buffer[Int]** 。
- 通过调用 **toSeq** 创建最终的 **Seq[Int]** 。

#### 转换方法

