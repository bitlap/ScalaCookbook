# 函数式编程

Scala同时支持面向对象编程和函数式编程风格。事实上，正如我在网站上记录的那样（ *https://oreil.ly/MOunk* ），在2018年的一次演讲中，Scala语言的创造者Martin Odersky表示，Scala的本质是“在类型化环境中融合了函数式编程和面向对象编程”，“函数用于逻辑，对象用于模块化”。本书中的许多示例都展示了这种融合，本章只关注Scala中的函数式编程技术 —— 我在本章中将其称为 *Scala/FP*。

FP是个大话题，我在 *Functional Programming, Simplified* 一书中写了七百多页。虽然我不能在这一章中涵盖所有的内容，但我将尝试涵盖一些主要的概念。初始的示例将展示如何：
- 编写和理解函数字面量
- 将函数字面量（也称为匿名函数）传递给方法
- 编写一个接受函数作为参数的方法

之后，你会看到一些非常具体的函数式编程技术：
- 部分应用的函数
- 编写返回函数的方法
- 偏函数

本章最后有两个例子，有助于展示这些技术。

如果你对FP不熟悉，一开始可能会感到困惑，所以了解它的目标和动机肯定会有帮助。因此，在接下来的几页中，我将尝试提供我所能提供的关于函数式编程的最佳介绍。*Functional Programming, Simplified* 由130个短的章节组成，这篇介绍是该书前21章的一个极其浓缩的版本。

## 什么是函数式编程？

找到一个一致的FP定义是出乎意料的难，但在写那本书的过程中，我想到了这个：

&nbsp;&nbsp;&nbsp;&nbsp;函数式编程是一种只使用纯函数和不可变值来编写软件应用程序的方式。

正如你在本章中看到的，纯函数是数学函数，就像写代数方程一样。

另一个不错的定义来自于Mary Rose Cook，她说：

&nbsp;&nbsp;&nbsp;&nbsp;函数式代码有一个特点：*没有副作用*。它（纯函数）不依赖当前函数之外的数据，也不改变存在于当前函数之外的数据。所有其他“函数式”事物都可以从这个属性派生出来。

我在 *Functional Programming, Simplified* 一书中对这些定义进行了详细的阐述，但就本章的目的而言，这些定义给了我们一个坚实的起点。

## 纯函数

要理解这些定义，你还必须理解什么是纯函数。在我的世界里，*纯函数* 就是一个函数：
- 其算法和输出 *只* 取决于 (a) 该函数的输入参数 和（b）调用其他纯函数
- 不改变它所给的参数
- 不改变应用程序中其他地方的任何东西（即，任何种类的全局状态)
- 不与外部世界交互，例如与文件、数据库、网络或用户交互

因为这个标准，你也可以对纯函数做这些陈述：
- 它们的内部算法不会调用其他返回随时间变化的函数，如日期、时间和随机数（随机的*任何东西* ）函数。
- 当以相同的输入调用任何次数时，纯函数总是返回相同的值。

数学函数是纯函数的好例子，包括像min、max、sum、sin、cosine、tangent等算法。与列表有关的函数，如filter、map，以及从现有列表中返回一个排序的列表，也是很好的例子。在输入相同的情况下调用任何次数，它们总是返回相同的结果。

相反，不是纯函数的例子是：
- 任何种类的输入/输出（I/O）功能（包括来自用户的输入，向用户的输出，以及从文件、数据库和网络中读出和写入）
- 在不同时间返回不同结果的函数（日期、时间和随机函数）
- 修改应用程序中其他地方的可变状态（如一个类中的可变字段）的函数
- 一个接可变类型（如 **Array** 或 **ArrayBuffer** ）的函数，并修改了 它的元素

纯函数让你感到舒适，因为当你用一组给定的输入来调用它时，你总是会得到完全相同的答案，例如：
```
    "zeus".length // will always be `4`
    sum(2,2) // will always be `4`
    List(4,5,6).max // will always be `6`
```

## 副作用








## 10.1 使用函数字面量（匿名函数）










## 10.2 将函数作为变量传递










## 10.3 定义一个接受简单函数作为参数的方法










## 10.4 声明更复杂的高阶函数










## 10.5 使用部分应用函数










## 10.6 创建返回函数的方法











## 10.7 创建偏函数










## 10.8 实现函数式的错误处理











## 10.9 现实世界的例子：在算法中传递函数










## 10.10 现实世界的例子：函数领域建模