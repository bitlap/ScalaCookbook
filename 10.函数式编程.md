# 函数式编程

Scala同时支持面向对象编程和函数式编程风格。事实上，正如我在网站上记录的那样（ *https://oreil.ly/MOunk* ），在2018年的一次演讲中，Scala语言的创造者Martin Odersky表示，Scala的本质是“在类型化环境中融合了函数式编程和面向对象编程”，“函数用于逻辑，对象用于模块化”。本书中的许多示例都展示了这种融合，本章只关注Scala中的函数式编程技术 —— 我在本章中将其称为 *Scala/FP*。

FP是个大话题，我在 *Functional Programming, Simplified* 一书中写了七百多页。虽然我不能在这一章中涵盖所有的内容，但我将尝试涵盖一些主要的概念。初始的示例将展示如何：
- 编写和理解函数字面量
- 将函数字面量（也称为匿名函数）传递给方法
- 编写一个接受函数作为参数的方法

之后，你会看到一些非常具体的函数式编程技术：
- 部分应用的函数
- 编写返回函数的方法
- 偏函数

本章最后有两个例子，有助于展示这些技术。

如果你对FP不熟悉，一开始可能会感到困惑，所以了解它的目标和动机肯定会有帮助。因此，在接下来的几页中，我将尝试提供我所能提供的关于函数式编程的最佳介绍。*Functional Programming, Simplified* 由130个短的章节组成，这篇介绍是该书前21章的一个极其浓缩的版本。

## 什么是函数式编程？

找到一个一致的FP定义是出乎意料的难，但在写那本书的过程中，我想到了这个：

&nbsp;&nbsp;&nbsp;&nbsp;函数式编程是一种只使用纯函数和不可变值来编写软件应用程序的方式。

正如你在本章中看到的，纯函数是数学函数，就像写代数等式一样。

另一个不错的定义来自于Mary Rose Cook，她说：

&nbsp;&nbsp;&nbsp;&nbsp;函数式代码有一个特点：*没有副作用*。它（纯函数）不依赖当前函数之外的数据，也不改变存在于当前函数之外的数据。所有其他“函数式”事物都可以从这个属性派生出来。

我在 *Functional Programming, Simplified* 一书中对这些定义进行了详细的阐述，但就本章的目的而言，这些定义给了我们一个坚实的起点。

## 纯函数

要理解这些定义，你还必须理解什么是纯函数。在我的世界里，*纯函数* 就是一个函数：
- 其算法和输出 *只* 取决于 (a) 该函数的输入参数 和（b）调用其他纯函数
- 不改变它所给的参数
- 不改变应用程序中其他地方的任何东西（即，任何种类的全局状态)
- 不与外部世界交互，例如与文件、数据库、网络或用户交互

因为这个标准，你也可以对纯函数做这些陈述：
- 它们的内部算法不会调用其他返回随时间变化的函数，如日期、时间和随机数（随机的*任何东西* ）函数。
- 当以相同的输入调用任何次数时，纯函数总是返回相同的值。

数学函数是纯函数的好例子，包括像min、max、sum、sin、cosine、tangent等算法。与列表有关的函数，如filter、map，以及从现有列表中返回一个排序的列表，也是很好的例子。在输入相同的情况下调用任何次数，它们总是返回相同的结果。

相反，不是纯函数的例子是：
- 任何种类的输入/输出（I/O）功能（包括来自用户的输入，向用户的输出，以及从文件、数据库和网络中读出和写入）
- 在不同时间返回不同结果的函数（日期、时间和随机函数）
- 修改应用程序中其他地方的可变状态（如一个类中的可变字段）的函数
- 一个接可变类型（如 **Array** 或 **ArrayBuffer** ）的函数，并修改了 它的元素

纯函数让你感到舒适，因为当你用一组给定的输入来调用它时，你总是会得到完全相同的答案，例如：
```
    "zeus".length // will always be `4`
    sum(2,2) // will always be `4`
    List(4,5,6).max // will always be `6`
```

## 副作用

有人说，一个纯粹的函数式程序是没有副作用的。那么，什么是 *副作用*呢？

一个有副作用的函数会修改状态，改变变量，和/或 与外部世界互动。这包括：
- 向文件、数据库或网络服务中写入（或读取）数据
- 变更作为输入的变量的状态，改变数据结构中的数据，或修改对象中的可变字段的值
- 抛出一个异常，或在发生错误时停止应用程序
- 调用有副作用的其他函数

纯函数更容易测试。想象一下，写一个加法函数，如 **+**。给定两个数字 **1** 和 **2** ，其结果总是 **3**。像这样的纯函数只是一个简单的问题：（a）不可改变的数据进来，（b）结果出来；其他的什么都没有发生。因为像这样的函数没有副作用，也不依赖于其范围之外的某处可变的状态，所以测试起来很简单。

参阅24.1小节，了解“编写纯函数”的更多细节。

## 在FP中进行思考

编写纯函数相对简单，事实上，编写纯函数往往是一种乐趣，因为在编写纯函数时，你不必考虑应用程序的整个状态。你所要考虑的只是什么东西进来了，什么东西出去了。

FP中较难的部分与（a）处理I/O和（b）将你的纯函数粘在一起有关。我发现如果要在FP中取得成功，你必须强烈渴望把你的代码看作是数学，把每个函数看作是一个代数等式，数据进去，数据出来，没有副作用，没有变更，也不会出错。

所发生的是，你写了一个纯函数，然后又写了一个，然后又写了一个。当它们完成后，你通过组合你的纯函数 —— 代数等式 —— 来创建你的应用程序，就像你是一个数学家在黑板上写一系列的等式。我再怎么强调这个渴望的重要性也不为过。你一定想像代数一样写这样的代码。

例如，在数学中，你可能有一个这样的函数：
```
    f(x) = x^2 + 2x + 1
```

在Scala中，这个函数是这样写的：
```
    def f(x: Int): Int = x*x + 2*x + 1
```

请注意关于这个函数的几件事：
- 函数的结果只取决于 **x** 的值和函数的算法。
- 该函数只依赖于 * 和 + 运算符，可以认为是调用其他纯函数。
- 该函数不会更改 **x**。

此外：
- 这个函数并没有在世界任何地方改变任何其他东西。
- 它的范围只涉及将算法应用于输入参数 **x**，并且不改变该范围之外的任何变量。
- 它不从世界上任何其他地方读取或写入任何东西：没有用户输入，没有文件，没有数据库，没有网络，等等。
- 如果你用同样的输入无限次地调用这个函数（比如说 **2** ），它将总是返回相同的值（如 **9** ）。

该函数是一个纯函数，其输出只取决于其输入。FP就是要把你所有的函数都写成这样，然后把它们组合在一起，形成一个完整的应用程序。

## 引用透明性和替代性

FP中的另一个重要概念是引用透明性（ *referential transparency* ，RT），这是一种属性，即一个表达式可以被其结果值取代而不改变程序的行为（反之亦然）。同样，你可以通过使用代数来考察这一点。例如，如果所有这些符号都代表不可变的值：
```
    a = b + c
    d = e + f + b
    x = a + d
```

你可以执行 *替换规则* 来确定 **x** 的值：
```
    x = a + d
    x = (b + c) + d // 取代'a'的作用
    x = (b + c) + (e + f + b) // 取代'd'的作用
    x = b + c + e + f + b // 去除不需要的括号
    x = 2b + c + e + f // 不能再减少表达了
```

当函数式程序员说一个程序“评估出一个结果”，他们的意思是你能通过执行替换规则来运行一个程序。你和编译器都可以执行这些替换。相反，如果像 **b** 这样的值在每次调用时都会返回一个随机值或用户输入值，那么你就不能还原等式。

虽然这个例子使用了代数符号，但你也可以用Scala代码做同样的事情。例如，在Scala/FP中，你写的代码看起来像这样：
```
    val a = f(x)
    val b = g(a)
    val c = h(y)
    val d = i(b, c)
```

假设 **f**、**g**、**h** 和 **i** 是纯函数 —— 假设所有字段都是 **val** 字段 —— 当你写这样的简单表达式时，你和编译器都可以自由地重新编排代码。例如，第一个和第三个表达式可以以任何顺序发生 —— 甚至可以并行运行。唯一的要求是前三个表达式在调用 **i** 之前被评估。

另外，由于 **a** 的值总是与 **f(x)** *完全* 相同，**f(x)** 总是可以被 **a** 取代，反之亦然。对于 **b**、**c** 和 **d** 也是如此。

例如，这个等式：
```
    val b = g(a)
```

与此等式完全相同：
```
    val b = g(f(x))
```

因为所有的字段都是不可变的，而且这些函数是纯函数，所以你和编译器都可以继续移动等式并进行替换，以至于所有的这些表达式都是等价的：
```
    val d = i(b, c)
    val d = i(g(a), h(y))
    val d = i(g(f(x)), h(y))
```

如前所述，函数式编程的一大好处是纯函数比有副作用的函数更容易测试，现在你可以看到第二个好处：用这样的引用透明性的代码，**g(a)** 和 **h(y)** 可以在不同的线程（或更随机的 *fiber* ）上运行，以利用多核的优势。因为所有的字段都是不可变的，而且函数是纯函数，所以你可以安全地进行这些代数式的替换。但是如果字段是可变的（ **var** 字段）或不是纯函数的，那么这些代码块就不能安全地被移动。

*Lisp* —— 原名 ***LISP***，是LISt Processor的缩写 —— 它是一种编程语言，最初于1958年被创造出来，开创了高级编程语言的包括高阶函数在内的许多重要概念。当你以代数/函数风格写代码时，自然会产生一种思维方式，这在Conrad Barski的 *Land of Lisp*（No Starch Press）一书中有所描述：

&nbsp;&nbsp;&nbsp;&nbsp;当有人说一个函数“返回一个值”时，一些高级Lispers会感到害怕。在lambda计算中，你通过对起始程序执行替换规则来“运行”一个程序，以确定一个函数的结果。因此，一组函数的结果只是通过执行替换而神奇地出现；一个函数从未有意识地“决定”返回一个值。正因为如此，Lisp纯粹主义者更愿意说，一个函数“评估出一个结果”。

前面的例子说明了这句话的含义。

## FP是面向表达式编程的一个超集

要使一种语言支持FP，它必须首先支持 *面向表达式的编程（EOP）*。在EOP中，每一行代码都是一个表达式，而不是一个语句。*表达式* 是一行返回一个结果的代码，没有副作用。相反，*语句* 就像调用 **println** 一样：它们不返回结果，只是为了其副作用而被调用。(技术上讲，语句返回一个结果，但它是一个 **Unit** 结果）。

Scala之所以能成为一门伟大的FP语言，一个特点是你所有的代码都可以写成表达式，包括 **if** 表达式：
```
    val a = 1
    val b = 2
    val max = if a > b then a else b
```

**match** 表达式：
```
    val evenOrOdd: String = i match
        case 1 | 3 | 5 | 7 | 9 => "odd"
        case 2 | 4 | 6 | 8 | 10 => "even"
```

**for** 表达式：
```
    val xs = List(1, 2, 3, 4, 5)
    val ys = for
        x <- xs
        if x > 2
    yield
        x * 10
```

甚至 **try/catch** 块也会返回一个值：
```
    def makeInt(s: String): Int =
        try
            s.toInt
        catch
            case _ : Throwable => 0
```

## 我的Scala函数式编程规则

为了帮助读者采用正确的FP思维方式，我在 *Functional Programming, Simplified* 一书中制定了这些编写Scala/FP代码的规则：
- 永远不要使用 **null**。甚至可以忘记Scala有一个 **null** 关键字。
- 只写纯函数。
- 所有字段只使用不可变的值（ **val** ）。
- 每一行代码都必须是一个代数表达式。每当你使用 **if** 的时候，你必须同时使用 **else** 。
- 纯函数不应该抛出异常；相反，它们产生的值是 **Option**、**Try** 和 **Either**。
- 不要创建封装数据和行为的OOP“classes”。相反，应该使用样例类创建不可变的数据结构，然后编写纯函数来操作这些数据结构。

如果你采用了这些简单的规则，你会发现：
- 你的大脑将放弃寻求捷径来对抗这个系统。（偶尔加入 **var** 字段或不纯函数只会减慢你的学习过程。）
- 你的代码会变得像代数一样。
- 随着时间的推移，你会逐渐理解Scala/FP的思维过程；你会发现一个概念在逻辑上可以引出另一个概念。

作为最后一点的例子，你会发现只使用不可变的字段自然会导致递归算法的出现。然后你会发现，并不会经常需要递归，因为所有的函数式方法都内置于不可变的Scala集合类中。

## 是的，使用FP的I/O代码

虽然有不同的方法来处理输入/输出（I/O），但FP代码当然会使用I/O。这包括处理用户的I/O，以及从文件、数据库和网络中读写。没有I/O，任何应用程序都不会有用，所以Scala/FP（以及所有其他函数式语言）都有以“函数式”方式处理I/O的设施。

例如，以函数式方式处理命令行I/O的Scala代码往往是这样的：
```
    def mainLoop: IO[Unit] =
    for
       _ <- putStr(prompt)
       cmd <- getLine.map(Command.parse _)
       _ <- if cmd == Quit then
                IO.unit
            else
                processCommand(cmd) >> mainLoop
    yield
    ()
     
    mainLoop.unsafeRunSync()
```

在这段代码中，**putStr** 是 **println** 的函数式替换，而 **getLine** 是一个让你读取用户输入的函数式方法。另外，注意到 **mainLoop** 是以递归方式调用自己。这就是如何用不可变值创建一个循环。

不幸的是，要解释这些I/O函数背后的技术和理念需要花费一些时间 —— 这可能需要一百页甚至更多篇幅，这取决于你的背景 —— 但我在 *Functional Programming, Simplified* 一书中对它们进行了详细解释。

### 函数式蛋糕和必要的糖衣 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;正如我在本书的第一版中所写的那样，在你使用一个FP库，如Cats（ *https://oreil.ly/L9gn7* ）、ZIO（ *https://oreil.ly/TawQ6* ），或Monix（ *https://monix.io* ），我所能提供给初学函数式编程的人的最好建议是用纯函数来编写你的应用程序的核心。这个纯函数式核心可以被认为是“蛋糕”，然后与外界交互的I/O函数可以被认为是围绕这个核心的“糖衣”。根据不同的应用，你可能最终拥有80%的蛋糕（纯功能）和20%的糖衣（I/O功能），或者可能是相反的情况。也可能是相反的情况。一些开发者将这种技术描述为拥有一个 “函数式核心和命令式外壳”。

## 10.1 使用函数字面量（匿名函数）

你想使用一个匿名函数 —— 也被称为 *函数字面量* —— 所以你可以把它传给一个接受函数为参数的方法，或者把它赋给一个变量。

### 解决方案

给定这个 **List**：
```
    scala> val x = List.range(1, 10)
    val x: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
```

你可以将一个匿名函数传递给list的 **filter** 方法，以创建一个只包含偶数的新 **List**：
```
    val evens = x.filter((i: Int) => i % 2 == 0)
                        ----------------------
```

在这个例子中，匿名函数是下划线的。REPL展示的这个表达式产生了一个新的偶数 **List**：
```
    scala> val evens = x.filter((i: Int) => i % 2 == 0)
    evens: List[Int] = List(2, 4, 6, 8)
```

在这个解决方案中，下面的代码是一个函数字面量，当它被传递到这样的方法中时，它也被称为 *匿名函数*，有些编程语言也将其称为 *lambda*：
```
    (i: Int) => i % 2 == 0
```

虽然这段代码是有效的，但它显示了定义函数字面量的最明确的形式。多亏了几个Scala的快捷方式，这个表达式才可以简化成这样：
```
    val evens = x.filter(_ % 2 == 0)
```

REPL显示，这样做返回的结果是一样的：
```
    scala> val evens = x.filter(_ % 2 == 0)
    evens: List[Int] = List(2, 4, 6, 8)
```

### 讨论

本小节中的第一个例子使用了这个函数字面量：
```
    (i: Int) => i % 2 == 0
```

当你看这段代码时，把 **=>** 符号看作是一个转化器是有帮助的，因为这个表达式把符号左边的参数列表（一个名为 **i** 的 **Int** ）用符号右边的算法（在这个例子中，算法是一个模数的函数，结果是一个 **Boolean** ）转化为一个新的结果。

如前所述，这个例子展示了定义匿名函数的详细形式，它可以通过几种方式简化。第一个例子显示了最明确的形式：
```
    val evens = x.filter((i: Int) => i % 2 == 0)
```

因为Scala可以从列表中确定它包含整数值，所以 **i** 的类型声明就没有必要了：
```
    val evens = x.filter((i) => i % 2 == 0)
```

当一个匿名函数只有一个参数时，就不需要括号了：
```
    val evens = x.filter(i => i % 2 == 0)
```

因为Scala允许你在参数只在函数中出现一次时使用 **_** 符号而不是变量名，所以这段代码可以被进一步简化：
```
    val evens = x.filter(_ % 2 == 0)
```

在其他情况下，你可以进一步简化你的匿名函数。例如，从最明确的形式开始，你可以用这个匿名函数和 **foreach** 方法打印列表中的每个元素：
```
    x.foreach((i: Int) => println(i))
```

和以前一样，不需要声明为 **Int**：
```
    x.foreach((i) => println(i))
```

因为只有一个参数，所以不需要 **i** 输入参数周围的圆括号：
```
    x.foreach(i => println(i))
```

因为 **i** 在函数体中只使用了一次，表达式可以用 **_** 通配符进一步简化：
```
    x.foreach(println(_))
```

最后，如果一个函数字面量由一个接受单一参数的语句组成，你不需要明确地命名和指定参数，所以该语句可以简化为这样：
```
    x.foreach(println)
```

#### 拥有多个参数的匿名函数

**Map** 提供了一个有关匿名函数的好例子，它可以接受多个参数。例如，给定这个 **Map**：
```
    val map = Map(1 -> 10, 2 -> 20, 3 -> 30)
```

这个例子展示了在一个不可变的 **Map** 实例上使用匿名函数和 **transform**方法的语法，其中每个元素的key和value被传递给匿名函数：
```
    val newMap = map.transform((k,v) => k + v)
```

下面REPL中展示了这是如何工作：
```
    scala> val map = Map(1 -> 10, 2 -> 20, 3 -> 30)
    val map: Map[Int, Int] = Map(1 -> 10, 2 -> 20, 3 -> 30)
    scala> val newMap = map.transform((k,v) => k + v)
    val newMap: Map[Int, Int] = Map(1 -> 11, 2 -> 22, 3 -> 33)
```

虽然这不是一个特别有用的算法，重要的是，它展示了如何以键值对的语法处理匿名函数所接受到的条目：
```
    (k,v) => k + v
```

#### 也可以把Map元素当作一个元组来处理 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;根据需要，另一种可能的方法是将每个 **Map** 元素作为一个含有两个元素的二元组：
```
    scala> map.foreach(x => println(s"${x._1} --> ${x._2}"))
    1 --> 10
    2 --> 20
    3 --> 30
```

### 另见

- 有关这个话题的更多细节，请看我的文章“Explaining Scala’s val Function Syntax”（ *https://oreil.ly/nP3ZU* ）。

## 10.2 将函数作为变量传递

### 问题

你想把一个函数创建为一个变量，并把它传递出去，就像你在面向对象的编程语言中传递 **String**、**Int** 和其他变量一样。

### 解决方案

使用10.1小节中的语法来定义一个函数字面量，然后将该字面量分配给一个变量。例如，下面的代码定义了一个函数字面量，它接收一个 **Int** 参数，并返回一个传入 **Int** 的值的两倍：
```
    (i: Int) => i * 2
```

正如10.1小节中提到的，你可以把 **=>** 符号看成是一个 *转换器*。在这种情况下，本例中该函数将 **Int** 值 **i** 转换为一个新的 **Int** 值，新值是 **i** 的两倍。

现在你可以把这个函数的字面量分配给一个变量：
```
    val double = (i: Int) => i * 2
```

当你把这段代码粘贴到REPL中时，如下面代码的划线部分所示，你会看到它将 **double** 识别为一个将 **Int** 转化为另一个 **Int** 的函数：
```
    scala> val double = (i: Int) => i * 2
    val double: Int => Int = Lambda ...
                ----------
```

此时，变量 **double** 是一个变量实例，就像 **String**、**Int** 或其他类型的实例一样，但在这里它是一个函数的实例，它被称为 *函数值*。现在你可以像调用一个方法一样调用 **double**：
```
    double(2) // 4
    double(3) // 6
```

除了像这样调用 **double** 之外，你还可以把它传递给任何一个所需参数符合这个签名的函数。例如，像 **List** 这样的集合类上的 **map** 方法需要一个函数参数，用于将类型 **A** 转换为类型 **B** ，正如其签名所示：
```
    def map[B](f: (A) => B): List[B]
               -----------
```

正因为如此，当你在处理 **List[Int]** 时，你可以给 **map** 一个 **double** 函数，它可以将 **Int** 转化为 **Int**：
```
    scala> val list = List.range(1, 5)
    list: List[Int] = List(1, 2, 3, 4)
    scala> list.map(double)
    res0: List[Int] = List(2, 4, 6, 8)
```

在这个例子中，泛型类型 **A** 是一个 **Int** ，泛型类型 **B** 也恰好是一个 **Int** ，但在更复杂的例子中，它们可以是其他类型。例如，你可以创建一个函数，将一个 **String** 转换为一个 **Int**：
```
    val length = (s: String) => s.length
```

然后，你可以在一个字符串列表上使用 **String-to-Int** 函数和 **map** 方法：
```
    scala> val lengths = List("Mercedes", "Hannah", "Emily").map(length)
    val lengths: List[Int] = List(8, 6, 5)
```

欢迎来到函数式编程世界。

#### 函数和方法通常是可以互换的 -- TODO 鸽子栏

虽然第一个例子展示了一个作为 **val** 变量创建的 **double** 函数，但你也可以使用 **def** 定义方法，且通常可以以相同的方式使用它们。详细信息请参阅讨论部分。

### 讨论

你至少可以用两种不同的方式声明一个函数字面量。下面这个模数函数的值 —— 如果 **i** 是偶数就返回 **true** —— 这意味着函数字面量的返回类型是 **Boolean**：
```
    val f = (i: Int) => { i % 2 == 0 } // 带括号的函数有时更容易阅读
    val f = (i: Int) => i % 2 == 0 // 不带括号的函数
```

在这种情况下的Scala编译器足够聪明，它可以查看函数的主体，并确定它返回一个 **Boolean** 值。

然而，如果你喜欢明确地声明一个函数字面量的返回类型，或者因为你的函数比较复杂而想这样做。下面的例子展示了你可以使用不同的形式来明确声明这个 **isEven** 函数返回一个 **Boolean**：
```
    val isEven: (Int) => Boolean = i => { i % 2 == 0 }
    val isEven: Int => Boolean = i => { i % 2 == 0 }
    val isEven: Int => Boolean = i => i % 2 == 0
    val isEven: Int => Boolean = _ % 2 == 0
```

第二个例子有助于证明这些方法的不同。这些函数都接收两个 **Int** 参数，并返回一个 **Int** 值，即两个输入值之和：
```
    // implicit approach
    val add = (x: Int, y: Int) => { x + y }
    val add = (x: Int, y: Int) => x + y
    
    // explicit approach
    val add: (Int, Int) => Int = (x,y) => { x + y }
    val add: (Int, Int) => Int = (x,y) => x + y
```

在这些例子中，我在方法主体周围提供了大括号，因为我发现这样的代码更容易阅读，尤其是当你第一次接触到函数语法时。当我在这附近时，这里有一个多行函数的例子，它没有大括号：
```
    val addThenDouble: (Int, Int) => Int = (x,y) =>
        val a = x + y
        2 * a
```

#### 使用像val函数一样的def方法

Scala非常灵活，这得益于一种叫做 *Eta Expansion* 的技术，就像你可以定义一个函数并把它赋值给一个 **val** 一样，你也可以用 **def** 定义一个方法，然后把它作为一个实例变量来传递。同样使用模数算法，你可以用任何一种方式定义 **def** 方法：
```
    def isEvenMethod(i: Int) = i % 2 == 0
    def isEvenMethod(i: Int) = { i % 2 == 0 }
    def isEvenMethod(i: Int): Boolean = i % 2 == 0
    def isEvenMethod(i: Int): Boolean = { i % 2 == 0 }
```

当一个方法被传入另一个期望有函数参数的方法时，Eta Expansion会透明地将该方法转化为一个函数。因此，任何一个 **isEven** 方法都可以被传递到另一个接受函数参数的方法中，该方法只需一个 接受 **Int** 并返回一个 **Boolean** 值的函数作为参数。例如，集合类 **List** 的 **filter** 方法被定义为接受一个将泛型类型 **A** 转换为 **Boolean** 的函数。
```
    def filter(p: (A) => Boolean): List[A]
              -----------------
```

因为在下个例子中，你有一个 **List[Int]** ，你可以通过 **isEvenMethod** 方法来 **filter**，该方法将 **Int** 转化为 **Boolean** 值：
```
    val list = List.range(1, 10)
    list.filter(isEvenMethod)
```

下面是在REPL中的样子：
```
    scala> def isEvenMethod(i: Int) = i % 2 == 0
    def isEvenMethod(i: Int): Boolean
    
    scala> val list = List.range(1, 10)
    val list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
    
    scala> list.filter(isEvenMethod)
    val res0: List[Int] = List(2, 4, 6, 8)
```

如前所述，这与定义一个函数字面量并将其分配给一个变量的过程类似。例如，在这里你可以看到 **isEvenFunction** 的工作原理与 **isEvenMethod** 一样：
```
    val isEvenFunction = (i: Int) => i % 2 == 0
    list.filter(isEvenFunction) // List(2, 4, 6, 8)
```

从编程的角度来看，明显的区别是 **isEvenMethod** 是一个 *方法*，而 **isEvenFunction** 是一个被分配给变量的 *函数*。但作为一个程序员，两种方法都能工作真是太好了。

#### 将一个现有的函数/方法分配给一个函数型变量

1. 继续这个探索，你也可以把现有的方法或函数赋值给一个函数变量。例如，你可以从 *scala.math.cos* 方法中创建一个名为 *c* 的新函数，像这样：to function variables
```
    scala> val c = scala.math.cos
    val c: Double => Double = Lambda ...
```

产生的函数值 **c** 被称为 *部分应用函数*。它是部分应用的，因为 **cos** 方法需要一个参数，而你还没有提供这个参数。

现在你有了 **c** 这个函数值，你可以像使用 **cos** 一样使用它：
```
    scala> c(0)
    res0: Double = 1.0
```

#### 在Scala 3中改进的Eta Expansion -- TODO 耗子栏

&nbsp;&nbsp;&nbsp;&nbsp;在Scala 2中，这个例子中需要使用下划线。
```
    val c = scala.math.cos _
```

但由于Scala 3中改进的Eta Expansion技术，已经不再需要这样做了。

接下来的例子展示了如何使用这一技术，使用 **scala.math** 中的 **pow** 方法来创建一个 **square** 函数。注意，**pow** 需要两个参数，其中第二个参数作为第一个参数的幂次：
```
    scala> val square = scala.math.pow(_, 2)
    val square: Double => Double = Lambda ...
```

同样，**square** 是一个部分应用的函数。我提供了power参数（第二个），但没有提供value参数（第一个），所以现在 **square** 在等待接收一个额外的参数，即要被平方的值：
```
    scala> square(3)
    val res0: Double = 9.0
    
    scala> square(4)
    val res1: Double = 16.0
```

这个例子展示了使用这种技术的典型方法：你从一个更一般的方法（ **pow** ）中创建一个更具体的函数（ **square** ）。请参阅10.5小节以了解更多信息。

#### 读取square在REPL的输出 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;注意，当你创建 **square** 时，你可以知道它仍然需要一个参数，因为REPL的输出显示其类型签名为：
```
    val square: Double => Double ...
                ----------------
```

&nbsp;&nbsp;&nbsp;&nbsp;这意味着它是一个接受一个 **Double** 参数并返回一个 **Double** 值。

综上所述，这里有一些关于函数变量的说明：
- 把 **=>** 符号看作是一个转换器。它使用右边的算法将其左边的输入数据转换为一些新的输出数据。
- 使用 **def** 来定义一个方法，**val** 来创建一个函数。
- 当把一个函数分配给一个变量时，*函数字面量* 是表达式右边的代码。

#### 在Map中储存函数

当我说函数是变量时，我的意思是它们可以像 **String** 或 **Int** 变量一样在所有方面被使用。正如本章中的几个示例所示，它们也可以作为函数参数使用。如下面例子所示，你还可以将函数（或方法）存储在 **Map** 中：
```
    def add(i: Int, j: Int) = i + j
    def multiply(i: Int, j: Int) = i * j
    
    // 在Map中存储函数
    val functions = Map(
        "add" -> add,
        "multiply" -> multiply
    )
    // 从Map中获得一个函数并使用它
    val f = functions("add")
    f(2, 2) // 4
```

### 另见

- 有关Eta Expansion的更多信息，请参阅我的文章“Using Scala Methods as If They Were Functions (Eta Expansion)”（ *https://oreil.ly/7v4ch* ）。
- 有关 **val** 函数和 **def** 方法的更多详细信息，可以参阅我的博文“Scala:The Differences Between val and def When Creating Functions” （ *https://oreil.ly/DuK5N* ）。
- 关于部分应用函数的更多例子和细节，请参阅10.5小节。

## 10.3 定义一个接受简单函数作为参数的方法

### 问题

你想创建一个方法，将一个简单的函数作为方法参数。

### 解决方案

此解决方案遵循三步流程：
1. 定义你的方法，方法参数是你想传入的函数的签名。
2. 定义一个或多个与此签名相匹配的函数。
3. 稍后，将这些函数作为参数传递给你的方法。






## 10.4 声明更复杂的高阶函数










## 10.5 使用部分应用函数










## 10.6 创建返回函数的方法











## 10.7 创建偏函数










## 10.8 实现函数式的错误处理











## 10.9 现实世界的例子：在算法中传递函数










## 10.10 现实世界的例子：函数领域建模