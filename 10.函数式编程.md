# 函数式编程

Scala同时支持面向对象编程和函数式编程风格。事实上，正如我在网站上记录的那样（ *https://oreil.ly/MOunk* ），在2018年的一次演讲中，Scala语言的创造者Martin Odersky表示，Scala的本质是“在类型化环境中融合了函数式编程和面向对象编程”，“函数用于逻辑，对象用于模块化”。本书中的许多示例都展示了这种融合，本章只关注Scala中的函数式编程技术 —— 我在本章中将其称为 *Scala/FP*。

FP是个大话题，我在 *Functional Programming, Simplified* 一书中写了七百多页。虽然我不能在这一章中涵盖所有的内容，但我将尝试涵盖一些主要的概念。初始的示例将展示如何：
- 编写和理解函数字面量
- 将函数字面量（也称为匿名函数）传递给方法
- 编写一个接受函数作为参数的方法

之后，你会看到一些非常具体的函数式编程技术：
- 部分应用的函数
- 编写返回函数的方法
- 偏函数

本章最后有两个例子，有助于展示这些技术。

如果你对FP不熟悉，一开始可能会感到困惑，所以了解它的目标和动机肯定会有帮助。因此，在接下来的几页中，我将尝试提供我所能提供的关于函数式编程的最佳介绍。*Functional Programming, Simplified* 由130个短的章节组成，这篇介绍是该书前21章的一个极其浓缩的版本。

## 什么是函数式编程？

找到一个一致的FP定义是出乎意料的难，但在写那本书的过程中，我想到了这个：

&nbsp;&nbsp;&nbsp;&nbsp;函数式编程是一种只使用纯函数和不可变值来编写软件应用程序的方式。

正如你在本章中看到的，纯函数是数学函数，就像写代数等式一样。

另一个不错的定义来自于Mary Rose Cook，她说：

&nbsp;&nbsp;&nbsp;&nbsp;函数式代码有一个特点：*没有副作用*。它（纯函数）不依赖当前函数之外的数据，也不改变存在于当前函数之外的数据。所有其他“函数式”事物都可以从这个属性派生出来。

我在 *Functional Programming, Simplified* 一书中对这些定义进行了详细的阐述，但就本章的目的而言，这些定义给了我们一个坚实的起点。

## 纯函数

要理解这些定义，你还必须理解什么是纯函数。在我的世界里，*纯函数* 就是一个函数：
- 其算法和输出 *只* 取决于 (a) 该函数的输入参数 和（b）调用其他纯函数
- 不改变它所给的参数
- 不改变应用程序中其他地方的任何东西（即，任何种类的全局状态)
- 不与外部世界交互，例如与文件、数据库、网络或用户交互

因为这个标准，你也可以对纯函数做这些陈述：
- 它们的内部算法不会调用其他返回随时间变化的函数，如日期、时间和随机数（随机的*任何东西* ）函数。
- 当以相同的输入调用任何次数时，纯函数总是返回相同的值。

数学函数是纯函数的好例子，包括像min、max、sum、sin、cosine、tangent等算法。与列表有关的函数，如filter、map，以及从现有列表中返回一个排序的列表，也是很好的例子。在输入相同的情况下调用任何次数，它们总是返回相同的结果。

相反，不是纯函数的例子是：
- 任何种类的输入/输出（I/O）功能（包括来自用户的输入，向用户的输出，以及从文件、数据库和网络中读出和写入）
- 在不同时间返回不同结果的函数（日期、时间和随机函数）
- 修改应用程序中其他地方的可变状态（如一个类中的可变字段）的函数
- 一个接可变类型（如 **Array** 或 **ArrayBuffer** ）的函数，并修改了 它的元素

纯函数让你感到舒适，因为当你用一组给定的输入来调用它时，你总是会得到完全相同的答案，例如：
```
    "zeus".length // will always be `4`
    sum(2,2) // will always be `4`
    List(4,5,6).max // will always be `6`
```

## 副作用

有人说，一个纯粹的函数式程序是没有副作用的。那么，什么是 *副作用*呢？

一个有副作用的函数会修改状态，改变变量，和/或 与外部世界互动。这包括：
- 向文件、数据库或网络服务中写入（或读取）数据
- 变更作为输入的变量的状态，改变数据结构中的数据，或修改对象中的可变字段的值
- 抛出一个异常，或在发生错误时停止应用程序
- 调用有副作用的其他函数

纯函数更容易测试。想象一下，写一个加法函数，如 **+**。给定两个数字 **1** 和 **2** ，其结果总是 **3**。像这样的纯函数只是一个简单的问题：（a）不可改变的数据进来，（b）结果出来；其他的什么都没有发生。因为像这样的函数没有副作用，也不依赖于其范围之外的某处可变的状态，所以测试起来很简单。

参阅24.1小节，了解“编写纯函数”的更多细节。

## 在FP中进行思考

编写纯函数相对简单，事实上，编写纯函数往往是一种乐趣，因为在编写纯函数时，你不必考虑应用程序的整个状态。你所要考虑的只是什么东西进来了，什么东西出去了。

FP中较难的部分与（a）处理I/O和（b）将你的纯函数粘在一起有关。我发现如果要在FP中取得成功，你必须强烈渴望把你的代码看作是数学，把每个函数看作是一个代数等式，数据进去，数据出来，没有副作用，没有变更，也不会出错。

所发生的是，你写了一个纯函数，然后又写了一个，然后又写了一个。当它们完成后，你通过组合你的纯函数 —— 代数等式 —— 来创建你的应用程序，就像你是一个数学家在黑板上写一系列的等式。我再怎么强调这个渴望的重要性也不为过。你一定想像代数一样写这样的代码。

例如，在数学中，你可能有一个这样的函数：
```
    f(x) = x^2 + 2x + 1
```

在Scala中，这个函数是这样写的：
```
    def f(x: Int): Int = x*x + 2*x + 1
```

请注意关于这个函数的几件事：
- 函数的结果只取决于 **x** 的值和函数的算法。
- 该函数只依赖于 * 和 + 运算符，可以认为是调用其他纯函数。
- 该函数不会更改 **x**。

此外：
- 这个函数并没有在世界任何地方改变任何其他东西。
- 它的范围只涉及将算法应用于输入参数 **x**，并且不改变该范围之外的任何变量。
- 它不从世界上任何其他地方读取或写入任何东西：没有用户输入，没有文件，没有数据库，没有网络，等等。
- 如果你用同样的输入无限次地调用这个函数（比如说 **2** ），它将总是返回相同的值（如 **9** ）。

该函数是一个纯函数，其输出只取决于其输入。FP就是要把你所有的函数都写成这样，然后把它们组合在一起，形成一个完整的应用程序。

## 引用透明性和替代性

FP中的另一个重要概念是引用透明性（ *referential transparency* ，RT），这是一种属性，即一个表达式可以被其结果值取代而不改变程序的行为（反之亦然）。同样，你可以通过使用代数来考察这一点。例如，如果所有这些符号都代表不可变的值：
```
    a = b + c
    d = e + f + b
    x = a + d
```

你可以执行 *替换规则* 来确定 **x** 的值：
```
    x = a + d
    x = (b + c) + d // 取代'a'的作用
    x = (b + c) + (e + f + b) // 取代'd'的作用
    x = b + c + e + f + b // 去除不需要的括号
    x = 2b + c + e + f // 不能再减少表达了
```

当函数式程序员说一个程序“评估出一个结果”，他们的意思是你能通过执行替换规则来运行一个程序。你和编译器都可以执行这些替换。相反，如果像 **b** 这样的值在每次调用时都会返回一个随机值或用户输入值，那么你就不能还原等式。

虽然这个例子使用了代数符号，但你也可以用Scala代码做同样的事情。例如，在Scala/FP中，你写的代码看起来像这样：
```
    val a = f(x)
    val b = g(a)
    val c = h(y)
    val d = i(b, c)
```

假设 **f**、**g**、**h** 和 **i** 是纯函数 —— 假设所有字段都是 **val** 字段 —— 当你写这样的简单表达式时，你和编译器都可以自由地重新编排代码。例如，第一个和第三个表达式可以以任何顺序发生 —— 甚至可以并行运行。唯一的要求是前三个表达式在调用 **i** 之前被评估。

另外，由于 **a** 的值总是与 **f(x)** *完全* 相同，**f(x)** 总是可以被 **a** 取代，反之亦然。对于 **b**、**c** 和 **d** 也是如此。

例如，这个等式：
```
    val b = g(a)
```

与此等式完全相同：
```
    val b = g(f(x))
```

因为所有的字段都是不可变的，而且函数是纯的，所以你和编译器都可以继续移动等式并进行替换，以至于所有的这些表达式都是等价的：
```
    val d = i(b, c)
    val d = i(g(a), h(y))
    val d = i(g(f(x)), h(y))
```


## FP是面向表达式编程的一个超集

## 我的Scala函数式编程规则

## 是的，使用FP的I/O代码






## 10.1 使用函数字面量（匿名函数）










## 10.2 将函数作为变量传递










## 10.3 定义一个接受简单函数作为参数的方法










## 10.4 声明更复杂的高阶函数










## 10.5 使用部分应用函数










## 10.6 创建返回函数的方法











## 10.7 创建偏函数










## 10.8 实现函数式的错误处理











## 10.9 现实世界的例子：在算法中传递函数










## 10.10 现实世界的例子：函数领域建模