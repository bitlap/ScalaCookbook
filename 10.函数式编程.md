# 函数式编程

Scala同时支持面向对象编程和函数式编程风格。事实上，正如我在网站上记录的那样（ *https://oreil.ly/MOunk* ），在2018年的一次演讲中，Scala语言的创造者Martin Odersky表示，Scala的本质是“在类型化环境中融合了函数式编程和面向对象编程”，“函数用于逻辑，对象用于模块化”。本书中的许多示例都展示了这种融合，本章只关注Scala中的函数式编程技术 —— 我在本章中将其称为 *Scala/FP*。

FP是个大话题，我在 *Functional Programming, Simplified* 一书中写了七百多页。虽然我不能在这一章中涵盖所有的内容，但我将尝试涵盖一些主要的概念。初始的示例将展示如何：
- 编写和理解函数字面量
- 将函数字面量（也称为匿名函数）传递给方法
- 编写一个接受函数作为参数的方法

之后，你会看到一些非常具体的函数式编程技术：
- 部分应用的函数
- 编写返回函数的方法
- 偏函数

本章最后有两个例子，有助于展示这些技术。

如果你对FP不熟悉，一开始可能会感到困惑，所以了解它的目标和动机肯定会有帮助。因此，在接下来的几页中，我将尝试提供我所能提供的关于函数式编程的最佳介绍。*Functional Programming, Simplified* 由130个短的章节组成，这篇介绍是该书前21章的一个极其浓缩的版本。

## 什么是函数式编程？

找到一个一致的FP定义是出乎意料的难，但在写那本书的过程中，我想到了这个：

&nbsp;&nbsp;&nbsp;&nbsp;函数式编程是一种只使用纯函数和不可变值来编写软件应用程序的方式。

正如你在本章中看到的，纯函数是数学函数，就像写代数等式一样。

另一个不错的定义来自于Mary Rose Cook，她说：

&nbsp;&nbsp;&nbsp;&nbsp;函数式代码有一个特点：*没有副作用*。它（纯函数）不依赖当前函数之外的数据，也不改变存在于当前函数之外的数据。所有其他“函数式”事物都可以从这个属性派生出来。

我在 *Functional Programming, Simplified* 一书中对这些定义进行了详细的阐述，但就本章的目的而言，这些定义给了我们一个坚实的起点。

## 纯函数

要理解这些定义，你还必须理解什么是纯函数。在我的世界里，*纯函数* 就是一个函数：
- 其算法和输出 *只* 取决于 (a) 该函数的输入参数 和（b）调用其他纯函数
- 不改变它所给的参数
- 不改变应用程序中其他地方的任何东西（即，任何种类的全局状态)
- 不与外部世界交互，例如与文件、数据库、网络或用户交互

因为这个标准，你也可以对纯函数做这些陈述：
- 它们的内部算法不会调用其他返回随时间变化的函数，如日期、时间和随机数（随机的*任何东西* ）函数。
- 当以相同的输入调用任何次数时，纯函数总是返回相同的值。

数学函数是纯函数的好例子，包括像min、max、sum、sin、cosine、tangent等算法。与列表有关的函数，如filter、map，以及从现有列表中返回一个排序的列表，也是很好的例子。在输入相同的情况下调用任何次数，它们总是返回相同的结果。

相反，不是纯函数的例子是：
- 任何种类的输入/输出（I/O）功能（包括来自用户的输入，向用户的输出，以及从文件、数据库和网络中读出和写入）
- 在不同时间返回不同结果的函数（日期、时间和随机函数）
- 修改应用程序中其他地方的可变状态（如一个类中的可变字段）的函数
- 一个接可变类型（如 **Array** 或 **ArrayBuffer** ）的函数，并修改了 它的元素

纯函数让你感到舒适，因为当你用一组给定的输入来调用它时，你总是会得到完全相同的答案，例如：
```
    "zeus".length // will always be `4`
    sum(2,2) // will always be `4`
    List(4,5,6).max // will always be `6`
```

## 副作用

有人说，一个纯粹的函数式程序是没有副作用的。那么，什么是 *副作用*呢？

一个有副作用的函数会修改状态，改变变量，和/或 与外部世界互动。这包括：
- 向文件、数据库或网络服务中写入（或读取）数据
- 变更作为输入的变量的状态，改变数据结构中的数据，或修改对象中的可变字段的值
- 抛出一个异常，或在发生错误时停止应用程序
- 调用有副作用的其他函数

纯函数更容易测试。想象一下，写一个加法函数，如 **+**。给定两个数字 **1** 和 **2** ，其结果总是 **3**。像这样的纯函数只是一个简单的问题：（a）不可改变的数据进来，（b）结果出来；其他的什么都没有发生。因为像这样的函数没有副作用，也不依赖于其范围之外的某处可变的状态，所以测试起来很简单。

参阅24.1小节，了解“编写纯函数”的更多细节。

## 在FP中进行思考

编写纯函数相对简单，事实上，编写纯函数往往是一种乐趣，因为在编写纯函数时，你不必考虑应用程序的整个状态。你所要考虑的只是什么东西进来了，什么东西出去了。

FP中较难的部分与（a）处理I/O和（b）将你的纯函数粘在一起有关。我发现如果要在FP中取得成功，你必须强烈渴望把你的代码看作是数学，把每个函数看作是一个代数等式，数据进去，数据出来，没有副作用，没有变更，也不会出错。

所发生的是，你写了一个纯函数，然后又写了一个，然后又写了一个。当它们完成后，你通过组合你的纯函数 —— 代数等式 —— 来创建你的应用程序，就像你是一个数学家在黑板上写一系列的等式。我再怎么强调这个渴望的重要性也不为过。你一定想像代数一样写这样的代码。

例如，在数学中，你可能有一个这样的函数：
```
    f(x) = x^2 + 2x + 1
```

在Scala中，这个函数是这样写的：
```
    def f(x: Int): Int = x*x + 2*x + 1
```

请注意关于这个函数的几件事：
- 函数的结果只取决于 **x** 的值和函数的算法。
- 该函数只依赖于 * 和 + 运算符，可以认为是调用其他纯函数。
- 该函数不会更改 **x**。

此外：
- 这个函数并没有在世界任何地方改变任何其他东西。
- 它的范围只涉及将算法应用于输入参数 **x**，并且不改变该范围之外的任何变量。
- 它不从世界上任何其他地方读取或写入任何东西：没有用户输入，没有文件，没有数据库，没有网络，等等。
- 如果你用同样的输入无限次地调用这个函数（比如说 **2** ），它将总是返回相同的值（如 **9** ）。

该函数是一个纯函数，其输出只取决于其输入。FP就是要把你所有的函数都写成这样，然后把它们组合在一起，形成一个完整的应用程序。

## 引用透明性和替代性

FP中的另一个重要概念是引用透明性（ *referential transparency* ，RT），这是一种属性，即一个表达式可以被其结果值取代而不改变程序的行为（反之亦然）。同样，你可以通过使用代数来考察这一点。例如，如果所有这些符号都代表不可变的值：
```
    a = b + c
    d = e + f + b
    x = a + d
```

你可以执行 *替换规则* 来确定 **x** 的值：
```
    x = a + d
    x = (b + c) + d // 取代'a'的作用
    x = (b + c) + (e + f + b) // 取代'd'的作用
    x = b + c + e + f + b // 去除不需要的括号
    x = 2b + c + e + f // 不能再减少表达了
```

当函数式程序员说一个程序“评估出一个结果”，他们的意思是你能通过执行替换规则来运行一个程序。你和编译器都可以执行这些替换。相反，如果像 **b** 这样的值在每次调用时都会返回一个随机值或用户输入值，那么你就不能还原等式。

虽然这个例子使用了代数符号，但你也可以用Scala代码做同样的事情。例如，在Scala/FP中，你写的代码看起来像这样：
```
    val a = f(x)
    val b = g(a)
    val c = h(y)
    val d = i(b, c)
```

假设 **f**、**g**、**h** 和 **i** 是纯函数 —— 假设所有字段都是 **val** 字段 —— 当你写这样的简单表达式时，你和编译器都可以自由地重新编排代码。例如，第一个和第三个表达式可以以任何顺序发生 —— 甚至可以并行运行。唯一的要求是前三个表达式在调用 **i** 之前被评估。

另外，由于 **a** 的值总是与 **f(x)** *完全* 相同，**f(x)** 总是可以被 **a** 取代，反之亦然。对于 **b**、**c** 和 **d** 也是如此。

例如，这个等式：
```
    val b = g(a)
```

与此等式完全相同：
```
    val b = g(f(x))
```

因为所有的字段都是不可变的，而且这些函数是纯函数，所以你和编译器都可以继续移动等式并进行替换，以至于所有的这些表达式都是等价的：
```
    val d = i(b, c)
    val d = i(g(a), h(y))
    val d = i(g(f(x)), h(y))
```

如前所述，函数式编程的一大好处是纯函数比有副作用的函数更容易测试，现在你可以看到第二个好处：用这样的引用透明性的代码，**g(a)** 和 **h(y)** 可以在不同的线程（或更随机的 *fiber* ）上运行，以利用多核的优势。因为所有的字段都是不可变的，而且函数是纯函数，所以你可以安全地进行这些代数式的替换。但是如果字段是可变的（ **var** 字段）或不是纯函数的，那么这些代码块就不能安全地被移动。

*Lisp* —— 原名 ***LISP***，是LISt Processor的缩写 —— 它是一种编程语言，最初于1958年被创造出来，开创了高级编程语言的包括高阶函数在内的许多重要概念。当你以代数/函数风格写代码时，自然会产生一种思维方式，这在Conrad Barski的 *Land of Lisp*（No Starch Press）一书中有所描述：

&nbsp;&nbsp;&nbsp;&nbsp;当有人说一个函数“返回一个值”时，一些高级Lispers会感到害怕。在lambda计算中，你通过对起始程序执行替换规则来“运行”一个程序，以确定一个函数的结果。因此，一组函数的结果只是通过执行替换而神奇地出现；一个函数从未有意识地“决定”返回一个值。正因为如此，Lisp纯粹主义者更愿意说，一个函数“评估出一个结果”。

前面的例子说明了这句话的含义。

## FP是面向表达式编程的一个超集

要使一种语言支持FP，它必须首先支持 *面向表达式的编程（EOP）*。在EOP中，每一行代码都是一个表达式，而不是一个语句。*表达式* 是一行返回一个结果的代码，没有副作用。相反，*语句* 就像调用 **println** 一样：它们不返回结果，只是为了其副作用而被调用。(技术上讲，语句返回一个结果，但它是一个 **Unit** 结果）。

Scala之所以能成为一门伟大的FP语言，一个特点是你所有的代码都可以写成表达式，包括 **if** 表达式：
```
    val a = 1
    val b = 2
    val max = if a > b then a else b
```

**match** 表达式：
```
    val evenOrOdd: String = i match
        case 1 | 3 | 5 | 7 | 9 => "odd"
        case 2 | 4 | 6 | 8 | 10 => "even"
```

**for** 表达式：
```
    val xs = List(1, 2, 3, 4, 5)
    val ys = for
        x <- xs
        if x > 2
    yield
        x * 10
```

甚至 **try/catch** 块也会返回一个值：
```
    def makeInt(s: String): Int =
        try
            s.toInt
        catch
            case _ : Throwable => 0
```

## 我的Scala函数式编程规则

为了帮助读者采用正确的FP思维方式，我在 *Functional Programming, Simplified* 一书中制定了这些编写Scala/FP代码的规则：
- 永远不要使用 **null**。甚至可以忘记Scala有一个 **null** 关键字。
- 只写纯函数。
- 所有字段只使用不可变的值（ **val** ）。
- 每一行代码都必须是一个代数表达式。每当你使用 **if** 的时候，你必须同时使用 **else** 。
- 纯函数不应该抛出异常；相反，它们产生的值是 **Option**、**Try** 和 **Either**。
- 不要创建封装数据和行为的OOP“classes”。相反，应该使用样例类创建不可变的数据结构，然后编写纯函数来操作这些数据结构。

如果你采用了这些简单的规则，你会发现：
- 你的大脑将放弃寻求捷径来对抗这个系统。（偶尔加入 **var** 字段或不纯函数只会减慢你的学习过程。）
- 你的代码会变得像代数一样。
- 随着时间的推移，你会逐渐理解Scala/FP的思维过程；你会发现一个概念在逻辑上可以引出另一个概念。

作为最后一点的例子，你会发现只使用不可变的字段自然会导致递归算法的出现。然后你会发现，并不会经常需要递归，因为所有的函数式方法都内置于不可变的Scala集合类中。

## 是的，使用FP的I/O代码

虽然有不同的方法来处理输入/输出（I/O），但FP代码当然会使用I/O。这包括处理用户的I/O，以及从文件、数据库和网络中读写。没有I/O，任何应用程序都不会有用，所以Scala/FP（以及所有其他函数式语言）都有以“函数式”方式处理I/O的设施。

例如，以函数式方式处理命令行I/O的Scala代码往往是这样的：
```
    def mainLoop: IO[Unit] =
    for
       _ <- putStr(prompt)
       cmd <- getLine.map(Command.parse _)
       _ <- if cmd == Quit then
                IO.unit
            else
                processCommand(cmd) >> mainLoop
    yield
    ()
     
    mainLoop.unsafeRunSync()
```

在这段代码中，**putStr** 是 **println** 的函数式替换，而 **getLine** 是一个让你读取用户输入的函数式方法。另外，注意到 **mainLoop** 是以递归方式调用自己。这就是如何用不可变值创建一个循环。

不幸的是，要解释这些I/O函数背后的技术和理念需要花费一些时间 —— 这可能需要一百页甚至更多篇幅，这取决于你的背景 —— 但我在 *Functional Programming, Simplified* 一书中对它们进行了详细解释。

### 函数式蛋糕和必要的糖衣 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;正如我在本书的第一版中所写的那样，在你使用一个FP库，如Cats（ *https://oreil.ly/L9gn7* ）、ZIO（ *https://oreil.ly/TawQ6* ），或Monix（ *https://monix.io* ），我所能提供给初学函数式编程的人的最好建议是用纯函数来编写你的应用程序的核心。这个纯函数式核心可以被认为是“蛋糕”，然后与外界交互的I/O函数可以被认为是围绕这个核心的“糖衣”。根据不同的应用，你可能最终拥有80%的蛋糕（纯功能）和20%的糖衣（I/O功能），或者可能是相反的情况。也可能是相反的情况。一些开发者将这种技术描述为拥有一个 “函数式核心和命令式外壳”。

## 10.1 使用函数字面量（匿名函数）

你想使用一个匿名函数 —— 也被称为 *函数字面量* —— 所以你可以把它传给一个接受函数为参数的方法，或者把它赋给一个变量。

### 解决方案

给定这个 **List**：
```
    scala> val x = List.range(1, 10)
    val x: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
```

你可以将一个匿名函数传递给list的 **filter** 方法，以创建一个只包含偶数的新 **List**：
```
    val evens = x.filter((i: Int) => i % 2 == 0)
                        ----------------------
```

在这个例子中，匿名函数是下划线的。REPL展示的这个表达式产生了一个新的偶数 **List**：
```
    scala> val evens = x.filter((i: Int) => i % 2 == 0)
    evens: List[Int] = List(2, 4, 6, 8)
```

在这个解决方案中，下面的代码是一个函数字面量，当它被传递到这样的方法中时，它也被称为 *匿名函数*，有些编程语言也将其称为 *lambda*：
```
    (i: Int) => i % 2 == 0
```

虽然这段代码是有效的，但它显示了定义函数字面量的最明确的形式。多亏了几个Scala的快捷方式，这个表达式才可以简化成这样：
```
    val evens = x.filter(_ % 2 == 0)
```

REPL显示，这样做返回的结果是一样的：
```
    scala> val evens = x.filter(_ % 2 == 0)
    evens: List[Int] = List(2, 4, 6, 8)
```

### 讨论

本小节中的第一个例子使用了这个函数字面量：
```
    (i: Int) => i % 2 == 0
```

当你看这段代码时，把 **=>** 符号看作是一个转化器是有帮助的，因为这个表达式把符号左边的参数列表（一个名为 **i** 的 **Int** ）用符号右边的算法（在这个例子中，算法是一个判断奇偶数，结果是一个 **Boolean** ）转化为一个新的结果。

如前所述，这个例子展示了定义匿名函数的详细形式，它可以通过几种方式简化。第一个例子显示了最明确的形式：
```
    val evens = x.filter((i: Int) => i % 2 == 0)
```

因为Scala可以从列表中确定它包含整数值，所以 **i** 的类型声明就没有必要了：
```
    val evens = x.filter((i) => i % 2 == 0)
```

当一个匿名函数只有一个参数时，就不需要括号了：
```
    val evens = x.filter(i => i % 2 == 0)
```

因为Scala允许你在参数只在函数中出现一次时使用 **_** 符号而不是变量名，所以这段代码可以被进一步简化：
```
    val evens = x.filter(_ % 2 == 0)
```

在其他情况下，你可以进一步简化你的匿名函数。例如，从最明确的形式开始，你可以用这个匿名函数和 **foreach** 方法打印列表中的每个元素：
```
    x.foreach((i: Int) => println(i))
```

和以前一样，不需要声明为 **Int**：
```
    x.foreach((i) => println(i))
```

因为只有一个参数，所以不需要 **i** 输入参数周围的圆括号：
```
    x.foreach(i => println(i))
```

因为 **i** 在函数体中只使用了一次，表达式可以用 **_** 通配符进一步简化：
```
    x.foreach(println(_))
```

最后，如果一个函数字面量由一个接受单一参数的语句组成，你不需要明确地命名和指定参数，所以该语句可以简化为这样：
```
    x.foreach(println)
```

#### 拥有多个参数的匿名函数

**Map** 提供了一个很好的匿名函数的例子，它可以接受多个参数。例如，给定这个 **Map**：
```
    val map = Map(1 -> 10, 2 -> 20, 3 -> 30)
```

这个例子展示了在一个不可变的 **Map** 实例上使用匿名函数和 **transform**方法的语法，其中每个元素的key和value被传递给匿名函数：
```
    val newMap = map.transform((k,v) => k + v)
```

下面REPL中展示了这是如何工作：
```
    scala> val map = Map(1 -> 10, 2 -> 20, 3 -> 30)
    val map: Map[Int, Int] = Map(1 -> 10, 2 -> 20, 3 -> 30)
    scala> val newMap = map.transform((k,v) => k + v)
    val newMap: Map[Int, Int] = Map(1 -> 11, 2 -> 22, 3 -> 33)
```

虽然这不是一个特别有用的算法，重要的是，它展示了如何以键值对的语法处理匿名函数所接受到的条目：
```
    (k,v) => k + v
```

#### 也可以把Map元素当作一个元组来处理 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;根据需要，另一种可能的方法是将每个 **Map** 元素作为一个含有两个元素的二元组：
```
    scala> map.foreach(x => println(s"${x._1} --> ${x._2}"))
    1 --> 10
    2 --> 20
    3 --> 30
```

### 另见

- 有关这个话题的更多细节，请看我的文章“Explaining Scala’s val Function Syntax”（ *https://oreil.ly/nP3ZU* ）。

## 10.2 将函数作为变量传递








## 10.3 定义一个接受简单函数作为参数的方法










## 10.4 声明更复杂的高阶函数










## 10.5 使用部分应用函数










## 10.6 创建返回函数的方法











## 10.7 创建偏函数










## 10.8 实现函数式的错误处理











## 10.9 现实世界的例子：在算法中传递函数










## 10.10 现实世界的例子：函数领域建模