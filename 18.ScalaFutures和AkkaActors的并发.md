# 进度 (8/35)

# ScalaFutures和AkkaActors的并发

在Scala中，你仍然能使用Java线程

```scala
val thread = new Thread {
    override def run =
        // put your long-running code here ...
        Thread.sleep(100)
        println("Hello, world")
}
thread.start
```

然而，Future和Actor模型是并发更好的方法：

*Futures*

适合于处理一次性问题："处理相对缓慢且可能长时间运行的计算问题，并且完成后将结果通知".

*Actors*

适合于处理运行在并行中，存活时间长，且在生命周期内可能对多次请求进行响应.

Futures和Actors都可以在比线程更高抽象级别上编码。一旦适应了，可以专注于解决手头问题，而不必担心低级别问题，如线程、锁和共享数据。

> Akka and Scala 3
>
> 在编写本文时，Akka还没有移植到Scala 3。因此，本章所有示例均采用最新版本的Scala 2。





## Future

Future Scaladoc表示: "Future代表当前可能存在可用或者不可用的值，在某些时候是可用的，或者在异常时不可用"。

Scala Future在以下几个方面比Java Thread做了更好的改进:

- 与Thread的典型用法一样，当想要创建一些“口袋并发”且并行运行一个相对较短的任务可以使用Future.
- 当一个 Future 完成时，被称为completed,  当完成时，你可以使用许多不同的回调和转换方法处理其结果，包括onComplete、andThen、foreach、map和recoverWith。



## Akka和Actor模型

Akka是一个面向Scala和Java程序员的Actor模型库。 这本书第一版涵盖了现在被称为Akka Classic Actor。 Classic使用Untyped Actors。我在2013年发现他们很容易上手，而且至今还在支持。

如今一种新的方式被称为Akka Typed，顾名思义，这些Actor比Classic actor要更加类型安全，有助于消除编译时错误 。 本书这版涵盖了Akka Typed。 

### Actor模型

在本章深入研究Akka技巧之前，先了解一下Actor模型。首先要了解的是Actor的概念:

- Actor是构建基于Actor系统的最小单元，如同面向对象系统中的类。
- 如同一个类一样，Actor封装了状态和行为。
- 不能通过进入Actor内部来获取其状态，但可以向Actor发送消息请求状态。就像问一个人感觉如何，但是你无法进入并执行其中一个方法，或访问其字段。
- Actor拥有邮箱—称之为收件箱—它在生命周期中的目的是处理邮箱中的消息。
- 可以通过向Actor发送一个不可变消息来与它通信。像给某人发送邮件消息，这些邮件就进入Actor的邮箱。
- 当一个Actor收到一条消息时，就像从邮箱里取出一封信。会打开信并使用其算法处理消息，然后转到邮箱中的下一封信。如果没有更多消息，Actor会等待直到再次收到消息。

在应用程序中，参与者形成层次结构，类似家庭或商业组织。lightbend公司是akka的创造者和主要维护者。建议将Actor视为一个个体，例如商业组织中的一个个体：

- 一个Actor有一个父级(监督): 用于创建actor。
- Actor可能有子级。设想一个商业组织，董事长下面有有一些副总裁。 那些副总裁会有很多下属等等。
- Actor可能有同级。比如可能有10个副总裁直接隶属于该组织的董事长。

开发Actor系统的最佳实践是委派，委派，委派。尤其是行为会阻塞。在商业中，董事长可能想完成一些事情，所以他将工作委派给副总裁，副总裁委派给管理者等等。直到这项工作最终由一个或多个下属完成。

委派很重要。设想这项工作需要几个人/年的时间，如果董事长必须自己处理这项工作，他就不能处理其他需求，副总裁和其他员工都会空闲。

除了这些关于Actor的概述之外，对Akka实现的Actor模式还有一些重要的事情需要知道:

- 你不能进入Akka Actor去获取状态的信息。当在代码中实例化一个Actor,  Akka提供了ActorRef，这本质上是你和Actor之间的外观。
- 在幕后，Akka Actor运行在真实线程上，许多Actor可能会共享同一个线程。
- 可选择不同的邮箱实现，也可以选择创建自己的邮箱类型。
- 当Actor(有意或无意)终止时，其邮箱中的消息进入系统的“死信邮箱”，如配方18.8所述。

### Actor的好处

通常，Actor模型已经在其他语言实现了，如Erlang和Dart，并且提供了实现长时间运行的并发和并行的高级抽象好处。除此之外，还有Akka Actor库还增加了以下好处:

- 轻量级，事件驱动的进程

  文档表明内存中每GB大约有250万个Actor，每秒可以处理5000万条消息。

- 容错
  Akka Actor可用来创建“自愈系统”。

- 位置透明性

  Akka Actor可以跨越多个jvm和服务器;它们被设计在分布式环境使用纯消息传递的。

"高级别的抽象"也可以认为“易于使用”。不需要花很长时间来理解Actor模型，一旦你这样做了，你能够编写复杂的并发应用程序，这比使用基本的Java库要容易得多。编写Actor如同建模真实世界，所以你可以为披萨店编写Actor做披萨，另一个接受订单，另一个配送订单等等。

而我通常认为Actor就像人类一样可以独立于他人，我也喜欢把它们看作我无法控制的那些别人的web服务。我可以向那个web服务发送消息，请求信息，但我不能进入web服务来修改它的状态或访问它的资源; 我只能通过API工作，这就像用Actor发送不可变消息。

希望这些关于Actor模型和Akka具体实现的注释，将有助于理解本章中的秘方。

## 其余还有：并行集合类

Scala并行集合类曾经主要和Scala发版集成的，但现在可作为单独的项目使用。

这个来自本书第一版的例子让你了解并行集合类是如何工作的:

```scala
import scala.collection.parallel.immutable.ParVector
val v = ParVector.range(0, 10) // ParVector(0,1,2,3,4,5,6,7,8,9)
v.foreach{ e => Thread.sleep(10); print(e) } // 0516273849
```

如foreach输出所示，因为像ParVector这样的集合是真正以并行的方式实现的。即使是像foreach这样简单的方法，它们的方法的输出也是不确定的。要了解更多信息，可参考我的博客文章“如何在Scala中使用并行集合的例子”。

> 并行与并发
>
> 有些关于并发和并行术语的含义有趣的争论。我倾向于交替使用它们，但有一个关于它们的不同之处的有趣讨论比如并发是一台自动售货机有两条生产线，而并行是两台自动售货机有两条生产线，参见Yossi Kreinin发布的博客“并行和并发需要不同的工具”。

# 18.1 创建Future

## 问题

你希望使用一种简单的方式使用Future并行执行任务，并且阻塞应用程序线程直到任务完成。

## 解决方法

Future提供了一种并发运行算法的简单方法。当Future创建时开始并行运行并且在将来某个点返回结果。在Scala中，一个Future最终会返回结果。

下面的例子展示了如何创建一个future，然后阻塞等待结果。在编写并行算法时阻塞不是一件好事—仅当在真的，真的不得已时候使用阻塞。但这作为一个初始例子很有用，首先因为它更容易思考，其次是因为它可以将这种方式不好的东西先展示出来。

这段代码在Future的某个时候执行1+1的计算。当计算完成时，返回结果:

```scala
// 1 - the necessary imports
import scala.concurrent.{Await, Future}
import scala.concurrent.duration.*
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.Random
import Thread.sleep
@main def futures1 =
    // 1: create a Future that runs in a separate thread and
    // returns “eventually”
    val f = Future {
        // this could be any long-running algorithmsleep(Random.nextInt(500))
        1 + 1
    }
    // 2: this is blocking, i.e., pausing the current thread to wait for a
    // result from another thread
    val result = Await.result(f, 1.second)
    println(result)
    sleep(1_000)
```

下面是这段代码的工作过程:

- import语句将代码导入所需的作用域
- ExecutionContext.Implicits.global import语句导入"默认全局执行上下文"，可以将*执行上下文*看作是线程池，这是访问线程池的一种简单方法。
- 在第一个注释之后创建一个Future。可见创造Future很简单;只需要传入你想要运行的代码块。代码将并行执行且在未来的某个时刻返回结果。
- Await. result方法调用声明在Future返回前将等待1秒。如果在指定时间没有返回，将抛出java.util.concurrent.TimeoutException
- 代码最后使用sleep语句，因此当Future结束计算时候程序将会继续运行。在实际程序中不需要这样，但是这样的小例子中，必须保持JVM main线程运行。

值得重申的是阻塞是不好的;除非不得不否则不该写这样的代码。下面配方中的例子展示了更好的方式。

如果Future的等待时间超过指定时间，将得到像这样的异常：

`java.util.concurrent.TimeoutException: Future timed out after [1 second]`

你可以自己演示将例子中的Random.nextInt(500)修改为2_000 之类的值。

## 讨论

虽然使用Future很简单，但背后有很多概念。下面陈述描述了Future的基本概念以及Future所依赖的执行上下文：

- Scala官方网站上的Future和Promises页面将Future定义为“一个为不存在的结果创建的只读占位符对象的类型”。
- 与保存Some[A]或None的容器Option[A]类似，Future[A]是并行执行计算并且在将来某些时间返回结果的容器。如返回(a) a类型的结果或(b)异常。
- 当Future创建后算法在未来之后的某个不确定时间开始运行，在执行上下文中分配的线程上运行。
- 一旦Future完成，计算的结果就可用了。
- 当返回一个结果时，一个Future被称为完成。它可能是成功地完成或失败。
- 如下面几个秘方所示，Future提供了一个 API 用于读取已计算的值，包括回调和转换方法如foreach, onComplete, map等。for的理解也在展示的秘方18.4中所使用。
- ExecutionContext执行给定的任务，你可以当作成线程池一样。

在我的代码中使用了ExecutionContext导入语句提供了默认的全局执行上下文:

```scala
import scala.concurrent.ExecutionContext.Implicits.global
```

在审查这本书的时候，Hermann Hueck指出，有很多方法可以导入和使用一个ExecutionContext。例如，给这个初始import语句:

```scala
import scala.concurrent.ExecutionContext
```

在代码中有多种不同的方式提供ExecutionContext

```scala
// define a given with name 'ec'
given ec: ExecutionContext = ExecutionContext.global

// for this example we just need the type; the name is not relevant
given ExecutionContext = ExecutionContext.global

// imports all givens in Implicits
import ExecutionContext.Implicits.given

// imports the given of the type ExecutionContext
import ExecutionContext.Implicits.{given ExecutionContext}
```

使用ExecutionContext时如需要灵活性时，了解所有这些方法是很有帮助的。

## 另见

- Scala官方网站上的Futures和Promises页面包括Futures(我没有涉及Promises)有许多例子我没有深入。
- Scala文档：scala.concurrent.ExecutionContext .

# 18.2使用Future的回调和转换方法

## 问题

并行运行一个任务，当任务完成时需要有不同的方式来处理结果。

## 解决方法

前面的秘方展示了使用Future的简单方法，但是因为它是阻塞的，所以只应该很少使用这种技术。 这个秘方展示更好的方式。

### 通用代码

为了简化后面代码，请注意以下所有例子都依赖于这些导入语句：

```scala
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.{Failure, Success, Random}
import Thread.sleep
```

### 解决方法1：使用onComplete

Future类拥有三个回调方法：onComplete, andThen, 和 foreach. 下面的例子演示了onComplete：

```scala
def getMeaningOfLife() =
    sleep(Random.nextInt(500))
    42

@main def callbacks1 =

    println("starting calculation ...")
    val f = Future {
    	getMeaningOfLife()
    }
    println("before onComplete")
    f.onComplete {
        case Success(value) => println(s"Got the callback, meaning = $value")
        case Failure(e) => e.printStackTrace
    }

    // do the rest of your work
    println("A ..."); sleep(100)
    println("B ..."); sleep(100)
    println("C ..."); sleep(100)
    println("D ..."); sleep(100)
    println("E ..."); sleep(100)
    println("F ..."); sleep(100)

    sleep(2_000)
```



## 讨论







# 18.3编写返回Future的方法

## 问题



## 解决方法



## 讨论





# 18.4 并行运行多个Future

## 问题



## 解决方法



## 讨论





# 18.5 创建面向对象风格的Actor

## 问题



## 解决方法



## 讨论



# 18.6 创建函数式风格的Actor

## 问题



## 解决方法



## 讨论





# 18.7 给Actor发消息

## 问题



## 解决方法



## 讨论



## 另见





# 18.8 创建多种状态的Actor(FSM)



## 问题



## 解决方法



## 讨论