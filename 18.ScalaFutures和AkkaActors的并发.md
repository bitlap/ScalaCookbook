# 进度 (1/35)



# ScalaFutures和AkkaActors的并发

在Scala中，你仍然能使用Java线程

```scala
val thread = new Thread {
    override def run =
        // put your long-running code here ...
        Thread.sleep(100)
        println("Hello, world")
}
thread.start
```

然而，Future和Actor模型是并发更好的方法：

*Futures*

适合于处理一次性问题："处理相对缓慢且可能长时间运行的计算问题，并且完成后将结果通知".

*Actors*

适合于处理运行在并行中，存活时间长，且在生命周期内可能对多次请求进行响应.

Futures和Actors都可以在比线程更高抽象级别上编码。一旦适应了，可以专注于解决手头问题，而不必担心低级别问题，如线程、锁和共享数据。

> Akka and Scala 3
>
> 在编写本文时，Akka还没有移植到Scala 3。因此，本章所有示例均采用最新版本的Scala 2。





## Future

Future Scaladoc表示: "Future代表当前可能存在可用或者不可用的值，在某些时候是可用的，或者在异常时不可用"。

Scala Future在以下几个方面比Java Thread做了更好的改进:

- 与Thread的典型用法一样，当想要创建一些“口袋并发”且并行运行一个相对较短的任务可以使用Future.
- 当一个 Future 完成时，被称为completed,  当完成时，你可以使用许多不同的回调和转换方法处理其结果，包括onComplete、andThen、foreach、map和recoverWith。



## Akka和Actor模型

Akka是一个面向Scala和Java程序员的Actor模型库。 这本书第一版涵盖了现在被称为Akka Classic Actor。 Classic使用Untyped Actors。我在2013年发现他们很容易上手，而且至今还在支持。

如今一种新的方式被称为Akka Typed，顾名思义，这些Actor比Classic actor要更加类型安全，有助于消除编译时错误 。 本书这版涵盖了Akka Typed。 

### Actor模型

在本章深入研究Akka技巧之前，先了解一下Actor模型。首先要了解的是Actor的概念:

- Actor是构建基于Actor系统的最小单元，如同面向对象系统中的类。
- 如同一个类一样，Actor封装了状态和行为。
- 不能通过进入Actor内部来获取其状态，但可以向Actor发送消息请求状态。就像问一个人感觉如何，但是你无法进入并执行其中一个方法，或访问其字段。
- Actor拥有邮箱—称之为收件箱—它在生命周期中的目的是处理邮箱中的消息。
- 可以通过向Actor发送一个不可变消息来与它通信。像给某人发送邮件消息，这些邮件就进入Actor的邮箱。
- 当一个Actor收到一条消息时，就像从邮箱里取出一封信。会打开信并使用其算法处理消息，然后转到邮箱中的下一封信。如果没有更多消息，Actor会等待直到再次收到消息。

在应用程序中，参与者形成层次结构，类似家庭或商业组织。lightbend公司是akka的创造者和主要维护者。建议将Actor视为一个个体，例如商业组织中的一个个体：

- 一个Actor有一个父级(监督): 用于创建actor。
- Actor可能有子级。设想一个商业组织，董事长下面有有一些副总裁。 那些副总裁会有很多下属等等。
- Actor可能有同级。比如可能有10个副总裁直接隶属于该组织的董事长。

开发Actor系统的最佳实践是委派，委派，委派。尤其是行为会阻塞。在商业中，董事长可能想完成一些事情，所以他将工作委派给副总裁，副总裁委派给管理者等等。直到这项工作最终由一个或多个下属完成。

委派很重要。设想这项工作需要几个人/年的时间，如果董事长必须自己处理这项工作，他就不能处理其他需求，副总裁和其他员工都会空闲。

除了这些关于Actor的概述之外，对Akka实现的Actor模式还有一些重要的事情需要知道:

- 你不能进入Akka Actor去获取状态的信息。当在代码中实例化一个Actor,  Akka提供了ActorRef，这本质上是你和Actor之间的外观。
- 在幕后，Akka Actor运行在真实线程上，许多Actor可能会共享同一个线程。
- 可选择不同的邮箱实现，也可以选择创建自己的邮箱类型。
- 当Actor(有意或无意)终止时，其邮箱中的消息进入系统的“死信邮箱”，如配方18.8所述。



### Actor的好处





## 其余还有：并行集合类







# 18.1 创建Future



## 问题



## 解决方法





## 讨论





## 另见







# 18.2使用Future的回调和转换方法

## 问题



## 解决方法



## 讨论







# 18.3编写返回Future的方法

## 问题



## 解决方法



## 讨论





# 18.4 并行运行多个Future

## 问题



## 解决方法



## 讨论





# 18.5 创建面向对象风格的Actor

## 问题



## 解决方法



## 讨论



# 18.6 创建函数式风格的Actor

## 问题



## 解决方法



## 讨论





# 18.7 给Actor发消息

## 问题



## 解决方法



## 讨论



## 另见





# 18.8 创建多种状态的Actor(FSM)



## 问题



## 解决方法



## 讨论