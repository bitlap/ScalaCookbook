# 进度 (5/35)

# ScalaFutures和AkkaActors的并发

在Scala中，你仍然能使用Java线程

```scala
val thread = new Thread {
    override def run =
        // put your long-running code here ...
        Thread.sleep(100)
        println("Hello, world")
}
thread.start
```

然而，Future和Actor模型是并发更好的方法：

*Futures*

适合于处理一次性问题："处理相对缓慢且可能长时间运行的计算问题，并且完成后将结果通知".

*Actors*

适合于处理运行在并行中，存活时间长，且在生命周期内可能对多次请求进行响应.

Futures和Actors都可以在比线程更高抽象级别上编码。一旦适应了，可以专注于解决手头问题，而不必担心低级别问题，如线程、锁和共享数据。

> Akka and Scala 3
>
> 在编写本文时，Akka还没有移植到Scala 3。因此，本章所有示例均采用最新版本的Scala 2。





## Future

Future Scaladoc表示: "Future代表当前可能存在可用或者不可用的值，在某些时候是可用的，或者在异常时不可用"。

Scala Future在以下几个方面比Java Thread做了更好的改进:

- 与Thread的典型用法一样，当想要创建一些“口袋并发”且并行运行一个相对较短的任务可以使用Future.
- 当一个 Future 完成时，被称为completed,  当完成时，你可以使用许多不同的回调和转换方法处理其结果，包括onComplete、andThen、foreach、map和recoverWith。



## Akka和Actor模型

Akka是一个面向Scala和Java程序员的Actor模型库。 这本书第一版涵盖了现在被称为Akka Classic Actor。 Classic使用Untyped Actors。我在2013年发现他们很容易上手，而且至今还在支持。

如今一种新的方式被称为Akka Typed，顾名思义，这些Actor比Classic actor要更加类型安全，有助于消除编译时错误 。 本书这版涵盖了Akka Typed。 

### Actor模型

在本章深入研究Akka技巧之前，先了解一下Actor模型。首先要了解的是Actor的概念:

- Actor是构建基于Actor系统的最小单元，如同面向对象系统中的类。
- 如同一个类一样，Actor封装了状态和行为。
- 不能通过进入Actor内部来获取其状态，但可以向Actor发送消息请求状态。就像问一个人感觉如何，但是你无法进入并执行其中一个方法，或访问其字段。
- Actor拥有邮箱—称之为收件箱—它在生命周期中的目的是处理邮箱中的消息。
- 可以通过向Actor发送一个不可变消息来与它通信。像给某人发送邮件消息，这些邮件就进入Actor的邮箱。
- 当一个Actor收到一条消息时，就像从邮箱里取出一封信。会打开信并使用其算法处理消息，然后转到邮箱中的下一封信。如果没有更多消息，Actor会等待直到再次收到消息。

在应用程序中，参与者形成层次结构，类似家庭或商业组织。lightbend公司是akka的创造者和主要维护者。建议将Actor视为一个个体，例如商业组织中的一个个体：

- 一个Actor有一个父级(监督): 用于创建actor。
- Actor可能有子级。设想一个商业组织，董事长下面有有一些副总裁。 那些副总裁会有很多下属等等。
- Actor可能有同级。比如可能有10个副总裁直接隶属于该组织的董事长。

开发Actor系统的最佳实践是委派，委派，委派。尤其是行为会阻塞。在商业中，董事长可能想完成一些事情，所以他将工作委派给副总裁，副总裁委派给管理者等等。直到这项工作最终由一个或多个下属完成。

委派很重要。设想这项工作需要几个人/年的时间，如果董事长必须自己处理这项工作，他就不能处理其他需求，副总裁和其他员工都会空闲。

除了这些关于Actor的概述之外，对Akka实现的Actor模式还有一些重要的事情需要知道:

- 你不能进入Akka Actor去获取状态的信息。当在代码中实例化一个Actor,  Akka提供了ActorRef，这本质上是你和Actor之间的外观。
- 在幕后，Akka Actor运行在真实线程上，许多Actor可能会共享同一个线程。
- 可选择不同的邮箱实现，也可以选择创建自己的邮箱类型。
- 当Actor(有意或无意)终止时，其邮箱中的消息进入系统的“死信邮箱”，如配方18.8所述。

### Actor的好处

通常，Actor模型已经在其他语言实现了，如Erlang和Dart，并且提供了实现长时间运行的并发和并行的高级抽象好处。除此之外，还有Akka Actor库还增加了以下好处:

- 轻量级，事件驱动的进程

  文档表明内存中每GB大约有250万个Actor，每秒可以处理5000万条消息。

- 容错
  Akka Actor可用来创建“自愈系统”。

- 位置透明性

  Akka Actor可以跨越多个jvm和服务器;它们被设计在分布式环境使用纯消息传递的。

"高级别的抽象"也可以认为“易于使用”。不需要花很长时间来理解Actor模型，一旦你这样做了，你能够编写复杂的并发应用程序，这比使用基本的Java库要容易得多。编写Actor如同建模真实世界，所以你可以为披萨店编写Actor做披萨，另一个接受订单，另一个配送订单等等。

而我通常认为Actor就像人类一样可以独立于他人，我也喜欢把它们看作我无法控制的那些别人的web服务。我可以向那个web服务发送消息，请求信息，但我不能进入web服务来修改它的状态或访问它的资源; 我只能通过API工作，这就像用Actor发送不可变消息。

希望这些关于Actor模型和Akka具体实现的注释，将有助于理解本章中的秘方。

## 其余还有：并行集合类

Scala并行集合类曾经主要和Scala发版集成的，但现在可作为单独的项目使用。

这个来自本书第一版的例子让你了解并行集合类是如何工作的:

```scala
import scala.collection.parallel.immutable.ParVector
val v = ParVector.range(0, 10) // ParVector(0,1,2,3,4,5,6,7,8,9)
v.foreach{ e => Thread.sleep(10); print(e) } // 0516273849
```

如foreach输出所示，因为像ParVector这样的集合是真正以并行的方式实现的。即使是像foreach这样简单的方法，它们的方法的输出也是不确定的。要了解更多信息，可参考我的博客文章“如何在Scala中使用并行集合的例子”。

> 并行与并发
>
> 有些关于并发和并行术语的含义有趣的争论。我倾向于交替使用它们，但有一个关于它们的不同之处的有趣讨论比如并发是一台自动售货机有两条生产线，而并行是两台自动售货机有两条生产线，参见Yossi Kreinin发布的博客“并行和并发需要不同的工具”。

# 18.1 创建Future

## 问题

你希望使用一种简单的方式使用Future并行执行任务，并且阻塞应用程序线程直到任务完成。

## 解决方法

Future提供了一种并发运行算法的简单方法。当Future创建时开始并行运行并且在将来某个点返回结果。在Scala中，一个Future最终会返回结果。

下面的例子展示了如何创建一个future，然后阻塞等待结果。在编写并行算法时阻塞不是一件好事—仅当在真的，真的不得已时候使用阻塞。但这作为一个初始例子很有用，首先因为它更容易思考，其次是因为它可以将这种方式不好的东西先展示出来。

这段代码在Future的某个时候执行1+1的计算。当计算完成时，返回结果:

```scala
// 1 - the necessary imports
import scala.concurrent.{Await, Future}
import scala.concurrent.duration.*
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.Random
import Thread.sleep
@main def futures1 =
    // 1: create a Future that runs in a separate thread and
    // returns “eventually”
    val f = Future {
        // this could be any long-running algorithmsleep(Random.nextInt(500))
        1 + 1
    }
    // 2: this is blocking, i.e., pausing the current thread to wait for a
    // result from another thread
    val result = Await.result(f, 1.second)
    println(result)
    sleep(1_000)
```



## 讨论





## 另见







# 18.2使用Future的回调和转换方法

## 问题



## 解决方法



## 讨论







# 18.3编写返回Future的方法

## 问题



## 解决方法



## 讨论





# 18.4 并行运行多个Future

## 问题



## 解决方法



## 讨论





# 18.5 创建面向对象风格的Actor

## 问题



## 解决方法



## 讨论



# 18.6 创建函数式风格的Actor

## 问题



## 解决方法



## 讨论





# 18.7 给Actor发消息

## 问题



## 解决方法



## 讨论



## 另见





# 18.8 创建多种状态的Actor(FSM)



## 问题



## 解决方法



## 讨论