# 进度 (18/35) 

# ScalaFutures和AkkaActors的并发

在Scala中，你仍然能使用Java线程

```scala
val thread = new Thread {
    override def run =
        // put your long-running code here ...
        Thread.sleep(100)
        println("Hello, world")
}
thread.start
```

然而，Future和Actor模型是并发更好的方法：

*Futures*

适合于处理一次性问题："处理相对缓慢且可能长时间运行的计算问题，并且完成后将结果通知".

*Actors*

适合于处理运行在并行中，存活时间长，且在生命周期内可能对多次请求进行响应.

Futures和Actors都可以在比线程更高抽象级别上编码。一旦适应了，可以专注于解决手头问题，而不必担心低级别问题，如线程、锁和共享数据。

> Akka and Scala 3
>
> 在编写本文时，Akka还没有移植到Scala 3。因此，本章所有示例均采用最新版本的Scala 2。





## Future

Future Scaladoc表示: "Future代表当前可能存在可用或者不可用的值，在某些时候是可用的，或者在异常时不可用"。

Scala Future在以下几个方面比Java Thread做了更好的改进:

- 与Thread的典型用法一样，当想要创建一些“口袋并发”且并行运行一个相对较短的任务可以使用Future.
- 当一个 Future 完成时，被称为completed,  当完成时，你可以使用许多不同的回调和转换方法处理其结果，包括onComplete、andThen、foreach、map和recoverWith。



## Akka和Actor模型

Akka是一个面向Scala和Java程序员的Actor模型库。 这本书第一版涵盖了现在被称为Akka Classic Actor。 Classic使用Untyped Actors。我在2013年发现他们很容易上手，而且至今还在支持。

如今一种新的方式被称为Akka Typed，顾名思义，这些Actor比Classic actor要更加类型安全，有助于消除编译时错误 。 本书这版涵盖了Akka Typed。 

### Actor模型

在本章深入研究Akka技巧之前，先了解一下Actor模型。首先要了解的是Actor的概念:

- Actor是构建基于Actor系统的最小单元，如同面向对象系统中的类。
- 如同一个类一样，Actor封装了状态和行为。
- 不能通过进入Actor内部来获取其状态，但可以向Actor发送消息请求状态。就像问一个人感觉如何，但是你无法进入并执行其中一个方法，或访问其字段。
- Actor拥有邮箱—称之为收件箱—它在生命周期中的目的是处理邮箱中的消息。
- 可以通过向Actor发送一个不可变消息来与它通信。像给某人发送邮件消息，这些邮件就进入Actor的邮箱。
- 当一个Actor收到一条消息时，就像从邮箱里取出一封信。会打开信并使用其算法处理消息，然后转到邮箱中的下一封信。如果没有更多消息，Actor会等待直到再次收到消息。

在应用程序中，参与者形成层次结构，类似家庭或商业组织。lightbend公司是akka的创造者和主要维护者。建议将Actor视为一个个体，例如商业组织中的一个个体：

- 一个Actor有一个父级(监督): 用于创建actor。
- Actor可能有子级。设想一个商业组织，董事长下面有有一些副总裁。 那些副总裁会有很多下属等等。
- Actor可能有同级。比如可能有10个副总裁直接隶属于该组织的董事长。

开发Actor系统的最佳实践是委派，委派，委派。尤其是行为会阻塞。在商业中，董事长可能想完成一些事情，所以他将工作委派给副总裁，副总裁委派给管理者等等。直到这项工作最终由一个或多个下属完成。

委派很重要。设想这项工作需要几个人/年的时间，如果董事长必须自己处理这项工作，他就不能处理其他需求，副总裁和其他员工都会空闲。

除了这些关于Actor的概述之外，对Akka实现的Actor模式还有一些重要的事情需要知道:

- 你不能进入Akka Actor去获取状态的信息。当在代码中实例化一个Actor,  Akka提供了ActorRef，这本质上是你和Actor之间的外观。
- 在幕后，Akka Actor运行在真实线程上，许多Actor可能会共享同一个线程。
- 可选择不同的邮箱实现，也可以选择创建自己的邮箱类型。
- 当Actor(有意或无意)终止时，其邮箱中的消息进入系统的“死信邮箱”，如配方18.8所述。

### Actor的好处

通常，Actor模型已经在其他语言实现了，如Erlang和Dart，并且提供了实现长时间运行的并发和并行的高级抽象好处。除此之外，还有Akka Actor库还增加了以下好处:

- 轻量级，事件驱动的进程

  文档表明内存中每GB大约有250万个Actor，每秒可以处理5000万条消息。

- 容错
  Akka Actor可用来创建“自愈系统”。

- 位置透明性

  Akka Actor可以跨越多个jvm和服务器;它们被设计在分布式环境使用纯消息传递的。

"高级别的抽象"也可以认为“易于使用”。不需要花很长时间来理解Actor模型，一旦你这样做了，你能够编写复杂的并发应用程序，这比使用基本的Java库要容易得多。编写Actor如同建模真实世界，所以你可以为披萨店编写Actor做披萨，另一个接受订单，另一个配送订单等等。

而我通常认为Actor就像人类一样可以独立于他人，我也喜欢把它们看作我无法控制的那些别人的web服务。我可以向那个web服务发送消息，请求信息，但我不能进入web服务来修改它的状态或访问它的资源; 我只能通过API工作，这就像用Actor发送不可变消息。

希望这些关于Actor模型和Akka具体实现的注释，将有助于理解本章中的秘方。

## 其余还有：并行集合类

Scala并行集合类曾经主要和Scala发版集成的，但现在可作为单独的项目使用。

这个来自本书第一版的例子让你了解并行集合类是如何工作的:

```scala
import scala.collection.parallel.immutable.ParVector
val v = ParVector.range(0, 10) // ParVector(0,1,2,3,4,5,6,7,8,9)
v.foreach{ e => Thread.sleep(10); print(e) } // 0516273849
```

如foreach输出所示，因为像ParVector这样的集合是真正以并行的方式实现的。即使是像foreach这样简单的方法，它们的方法的输出也是不确定的。要了解更多信息，可参考我的博客文章“如何在Scala中使用并行集合的例子”。

> 并行与并发
>
> 有些关于并发和并行术语的含义有趣的争论。我倾向于交替使用它们，但有一个关于它们的不同之处的有趣讨论比如并发是一台自动售货机有两条生产线，而并行是两台自动售货机有两条生产线，参见Yossi Kreinin发布的博客“并行和并发需要不同的工具”。

# 18.1 创建Future

## 问题

你希望使用一种简单的方式使用Future并行执行任务，并且阻塞应用程序线程直到任务完成。

## 解决方法

Future提供了一种并发运行算法的简单方法。当Future创建时开始并行运行并且在将来某个点返回结果。在Scala中，一个Future最终会返回结果。

下面的例子展示了如何创建一个future，然后阻塞等待结果。在编写并行算法时阻塞不是一件好事—仅当在真的，真的不得已时候使用阻塞。但这作为一个初始例子很有用，首先因为它更容易思考，其次是因为它可以将这种方式不好的东西先展示出来。

这段代码在Future的某个时候执行1+1的计算。当计算完成时，返回结果:

```scala
// 1 - the necessary imports
import scala.concurrent.{Await, Future}
import scala.concurrent.duration.*
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.Random
import Thread.sleep
@main def futures1 =
    // 1: create a Future that runs in a separate thread and
    // returns “eventually”
    val f = Future {
        // this could be any long-running algorithmsleep(Random.nextInt(500))
        1 + 1
    }
    // 2: this is blocking, i.e., pausing the current thread to wait for a
    // result from another thread
    val result = Await.result(f, 1.second)
    println(result)
    sleep(1_000)
```

下面是这段代码的工作过程:

- import语句将代码导入所需的作用域
- ExecutionContext.Implicits.global import语句导入"默认全局执行上下文"，可以将*执行上下文*看作是线程池，这是访问线程池的一种简单方法。
- 在第一个注释之后创建一个Future。可见创造Future很简单;只需要传入你想要运行的代码块。代码将并行执行且在未来的某个时刻返回结果。
- Await. result方法调用声明在Future返回前将等待1秒。如果在指定时间没有返回，将抛出java.util.concurrent.TimeoutException
- 代码最后使用sleep语句，因此当Future结束计算时候程序将会继续运行。在实际程序中不需要这样，但是这样的小例子中，必须保持JVM main线程运行。

值得重申的是阻塞是不好的;除非不得不否则不该写这样的代码。下面配方中的例子展示了更好的方式。

如果Future的等待时间超过指定时间，将得到像这样的异常：

`java.util.concurrent.TimeoutException: Future timed out after [1 second]`

你可以自己演示将例子中的Random.nextInt(500)修改为2_000 之类的值。

## 讨论

虽然使用Future很简单，但背后有很多概念。下面陈述描述了Future的基本概念以及Future所依赖的执行上下文：

- Scala官方网站上的Future和Promises页面将Future定义为“一个为不存在的结果创建的只读占位符对象的类型”。
- 与保存Some[A]或None的容器Option[A]类似，Future[A]是并行执行计算并且在将来某些时间返回结果的容器。如返回(a) a类型的结果或(b)异常。
- 当Future创建后算法在未来之后的某个不确定时间开始运行，在执行上下文中分配的线程上运行。
- 一旦Future完成，计算的结果就可用了。
- 当返回一个结果时，一个Future被称为完成。它可能是成功地完成或失败。
- 如下面几个秘方所示，Future提供了一个 API 用于读取已计算的值，包括回调和转换方法如foreach, onComplete, map等。for的理解也在展示的秘方18.4中所使用。
- ExecutionContext执行给定的任务，你可以当作成线程池一样。

在我的代码中使用了ExecutionContext导入语句提供了默认的全局执行上下文:

```scala
import scala.concurrent.ExecutionContext.Implicits.global
```

在审查这本书的时候，Hermann Hueck指出，有很多方法可以导入和使用一个ExecutionContext。例如，给这个初始import语句:

```scala
import scala.concurrent.ExecutionContext
```

在代码中有多种不同的方式提供ExecutionContext

```scala
// define a given with name 'ec'
given ec: ExecutionContext = ExecutionContext.global

// for this example we just need the type; the name is not relevant
given ExecutionContext = ExecutionContext.global

// imports all givens in Implicits
import ExecutionContext.Implicits.given

// imports the given of the type ExecutionContext
import ExecutionContext.Implicits.{given ExecutionContext}
```

使用ExecutionContext时如需要灵活性时，了解所有这些方法是很有帮助的。

## 另见

- Scala官方网站上的Futures和Promises页面包括Futures(我没有涉及Promises)有许多例子我没有深入。
- Scala文档：scala.concurrent.ExecutionContext .

# 18.2使用Future的回调和转换方法

## 问题

并行运行一个任务，当任务完成时需要有不同的方式来处理结果。

## 解决方法

前面的秘方展示了使用Future的简单方法，但是因为它是阻塞的，所以只应该很少使用这种技术。 这个秘方展示更好的方式。

### 通用代码

为了简化后面代码，请注意以下所有例子都依赖于这些导入语句：

```scala
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.{Failure, Success, Random}
import Thread.sleep
```

### 解决方法1：使用onComplete

Future类拥有三个回调方法：onComplete, andThen, 和 foreach. 下面的例子演示了onComplete：

```scala
def getMeaningOfLife() =
    sleep(Random.nextInt(500))
    42

@main def callbacks1 =

    println("starting calculation ...")
    val f = Future {
    	getMeaningOfLife()
    }
    println("before onComplete")
    f.onComplete {
        case Success(value) => println(s"Got the callback, meaning = $value")
        case Failure(e) => e.printStackTrace
    }

    // do the rest of your work
    println("A ..."); sleep(100)
    println("B ..."); sleep(100)
    println("C ..."); sleep(100)
    println("D ..."); sleep(100)
    println("E ..."); sleep(100)
    println("F ..."); sleep(100)

    sleep(2_000)
```

这个例子在随机延迟之后返回getMeaningOfLife值42。重要的部分是f.oncomplete方法调用及其后面的代码。下面是代码的工作原理:

- Future f被创建后会尽可能快的运行(尽管开始运行的实际时间是不确定的)。
- f的类型是Future[Int]。
- f.oncomplete方法设置了回调，当Future完成时候将会发生调用。
- onComplete的类型签名表明它接受一个函数来转换Try输入参数到Unit结果。因此，在f.onComplete代码块中，代码处理Future的结果是Success或Failure。
- 稍有延迟的println语句代表代码的其余工作可能在主线程上执行，而Future在并行的线程上关闭或者运行。
  线。

因为Future在其他线程上并发运行，但是无法精确知道何时计算出结果，所以代码的输出是不确定的，看起来像这样：

```scala
starting calculation ...
before onComplete
A ...
B ...
C ...
D ...
E ...
Got the callback, meaning = 42
F ...
```

因为Future最终会返回——在某个不确定的时间——“得到回调”消息可能出现在输出的任何位置。

如前所述，onComplete类型签名表明它接受一个函数转换Try参数:

```scala
def onComplete[U](f: (Try[T]) => U)(implicit executor: ExecutionContext): Unit
```

因此，这里可以使用另一种方式是在Try参数上调用fold来替换前面f.onComplete的代码:

```scala
f.onComplete (_.fold(
        _.printStackTrace,
        value => println(s"Got the callback, meaning = $value")
    )
)
```

在这个例子中，fold接受两个参数

- 第一个参数是在Try为失败时应用的函数。
- 第二个参数是在Try为Success时应用的函数。

有关这种方法的更多细节，请参考Scaladoc的Try类。

### 解决方法2：使用andThen或foreach

有时候，onComplete并不是你想要的，在这种情况下可以使用回调方法andThen和foreach。这里有一个如何使用andThen的例子:

```scala
@main def callbacks2 =
    println("Creating the future")
    val f: Future[Int] = Future {
        // sleep for a random time before returning 42
        val sleepTime = Random.nextInt(500)
        sleep(sleepTime)
        println("Leaving the future")
        if sleepTime > 250 then throw new Exception("Ka-boom")
        42
    }
    // handle the result of f with andThen
    println("Before andThen")
    f andThen {
        case Success(x) =>
            val y = x * 2
            println(s"andThen: $y")
        case Failure(t) =>
        	println(s"andThen: ${t.getMessage}")
    }
    println("After andThen")
	sleep(1_000)
```

这段代码类似于onComplete的例子，但有以下变化：

- Future代码块大约有一半的时间被连接到抛出异常。如果不抛出异常，最终得到值42。
- andThen代码块在Future完成时候运行
- andThen代码块用部分函数实现的。如果不想实现case语句的Failure部分，则不必这样做。

当一个异常抛出时，应用程序的输出是:

```scala
Creating the future
Before andThen
After andThen
Leaving the future
andThen: Ka-boom
```

当没有异常抛出时，输出是：

```scala
Creating the future
Before andThen
After andThen
Leaving the future
andThen: 84 
```

接下来，这是前一个例子的简短版本，使用foreach而不是andThen：

```scala
@main def callbacks3 =
    val f: Future[Int] = Future {
    val sleepTime = Random.nextInt(500)
    sleep(sleepTime)
    if sleepTime > 250 then throw new Exception("Ka-boom")
    42
}
    f.foreach(println)
    sleep(1_000)
```

在本例中，当未抛出异常时输出42，抛出异常时候什么也不输出。Future类的Scaladoc告诉我们为什么什么也没有输出:“警告: (foreach)将不会被调用，如果这个Future永不完成或者以失败完成。因为这个方法是异步执行且不产生返回值，抛出任何非致命异常将报告给ExecutionContext”。

Future还有更多被归类为转换方法的回调方法，包括transform、collect、fallbackTo、map、recover和recoverWith。下面是使用fallbackTo的一个简短例子：

```scala
def getMeaningOfLife() = Future {
    sleep(Random.nextInt(500))
    42
}
val meaning = getMeaningOfLife() fallbackTo Future(0)
meaning.foreach(println)
```

Future类的Scaladoc为其它转换方法提供了很好的例子。

## 讨论

下面的声明描述了Future的使用可以和回调和转换方法一起使用：

- 当Future完成时回调和转换方法被异步调用。
- 在该秘方中演示了onComplete, andThen, foreach, 和fallbackTo。
- 在Future完成一段时间后由某个线程执行回调方法。在Scala官方网站的Futures和Promises页面上写道：“没有保证回调函数被完成Future的线程调用或创建回调的线程所调用”。
- 回调的执行顺序不能保证。
- onComplete接收类型为Try[a] =>B的回调函数。
- andThen接收部分函数，只需要处理所需的情况。(见Recipe 10.7，“创建部分函数”，获取关于部分函数的更多信息）
- onComplete和foreach的返回类型是Unit，所以它们不能被链接在一起。

# 18.3编写返回Future的方法

## 问题

想要写一个返回Future的方法或函数。

## 解决方法

在实际中，需要创建返回future的方法。以下例子定义了名为longRunningComputation的方法，该方法返回一个
Future(Int)：

```scala
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.{Failure, Success, Random}
import Thread.sleep
@main def futuresFunction =
    // a function that returns a Future
    def longRunningComputation(i: Int): Future[Int] = Future {
        sleep(100)
        i + 1
	}
    // this does not block
    longRunningComputation(11).onComplete {
        case Success(result) => println(s"result = $result")
        case Failure(e) => e.printStackTrace
	}
    // keep the jvm from shutting down
    sleep(1_000)
```

在这个例子中，将longRunningComputation的方法体创建在Future包装的代码块中。代码块传递给Future对象的apply方法。这会启动异步计算并返回Future[A]，这个例子将保存计算结果到Future[Int]。这是定义方法返回Future的常用方法。

## 讨论

在类似的技术中，因为Future将代码块作为其输入参数，可以将已有方法中未并行执行的包装在Future内部：

```scala
// some existing function that does not run concurrently
def getMeaningOfLife() = ???
// wrap that existing function in a Future
val meaning = Future { getMeaningOfLife() }
```

同样，这种方式生效是因为:

- 该方法传递给scala.concurrent.Future中的apply方法(Future对象，而不是Future类)。

- apply方法接受名称调用块代码作为参数，可以从Future对象的Scaladoc页面上的签名可以看出：

  ```scala
  final def apply[T](body: => T)(implicit executor: ExecutionContext): Future[A]
  ```

- 因为方法(或函数)等价于名称调用块，所以可以用Future封装非并发方法如上所示。

# 18.4 并行运行多个Future

## 问题

Future通常在创建后就开始运行，你想看看如何并行运行多个Future，并当它们全部完成时，将结果合并在一起。

## 解决方法

如果想创建多个Scala future并在for表达式中将它们的结果合并在一起获得结果，正确的方式是:

- 创建多个Future
- 在for表达式中合并结果
- 使用onComplete或类似的技术提取合并的结果

### 正确的方式（简化）

我将在下面代码展示for表达式中使用多个Future的正确方式。最重要的是按照步骤A创建Future，在步骤B的for表达式中使用它们:

```scala
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.{Failure, Success}
import Thread.sleep
@main def multipleFutures1 =
    // (a) create the futures
    val f1 = Future { sleep(800); 1 }
    val f2 = Future { sleep(200); 2 }
    val f3 = Future { sleep(400); 3 }
    // (b) run them simultaneously in a for-comprehension
    val result = for
        r1 <- f1
        r2 <- f2
        r3 <- f3
    yield (r1 + r2 + r3)
    // (c) process the result
    result.onComplete {
        case Success(x) => println(s"result = $x")
        case Failure(e) => e.printStackTrace
	}
    // important for a little parallel demo: keep the jvm alive
    sleep(3_000)
```

### 一个完整的验证示例

没有办法通过阅读代码来判断这是正确的方式，所以还创建了下一个示例来展示它是如何工作的：

```scala
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.{Failure, Success}
import Thread.sleep

def slowlyDouble(
    x: Int,
    startTime: Long,
    delay: Int,
    name: String
): Future[Int] = Future {
    println(s"entered $name: ${delta(startTime)}")
    sleep(delay)
    println(s"leaving $name: ${delta(startTime)}")
    x * 2
}
// time-related functions that are used in the code
def delta(t: Long) = System.currentTimeMillis - t
def time() = System.currentTimeMillis

@main def multipleFutures2 =
    val t0 = System.currentTimeMillis
    // Future #1
    println(s"creating f1: ${delta(t0)}")
    val f1 = slowlyDouble(x=1, t0, delay=1500, name="f1")
    // Future #2
    sleep(100)
    println(s"\ncreating f2: ${delta(t0)}")
    val f2 = slowlyDouble(x=2, t0, delay=250, name="f2")
    // Future #3
    sleep(100)
    println(s"\ncreating f3: ${delta(t0)}")
    val f3 = slowlyDouble(x=3, t0, delay=500, name="f3")
    println(s"\nentering `for`: ${delta(t0)}")
    val result = for
        r1 <- f1
        r2 <- f2
        r3 <- f3
    yield (r1 + r2 + r3)
    println("\nBEFORE onComplete")
    result.onComplete {
        case Success(x) => {
            println(s"\nresult = $x (delta = ${delta(t0)})")
            println("note: you don’t get the result until the last future completes")
        }
        case Failure(e) => e.printStackTrace
        }
    println("AFTER onComplete\n")
    // important for a little parallel demo: keep the jvm alive
    sleep(3_000)
```



如果运行这段代码，会看到这样的输出:

```
creating f1: 0
entered f1: 0

creating f2: 105
entered f2: 105

creating f3: 210
entering `for`: 211
entered f3: 211

BEFORE onComplete
AFTER onComplete

leaving f2: 359
leaving f3: 713
leaving f1: 1501

result = 12 (delta = 1502)
note: you don’t get the result until the last future completes
```

输出显示了几个有趣的点:

- f1、f2和f3立即开始运行。从这段代码虽然看不出来，但是会立即在新线程上开始运行。
- 输出快速传递到onComplete语句。
- 在短暂的停顿之后，leaving语句被打印，紧接着是结果。
- 注意到f1打印结果的delta仅比 delta多一点。，那是因为 f1的睡眠时间最长。 这是有道理的，三个future并行运行运行的时间只是运行最长的futrue时间久一点。

我鼓励你使用该代码并使其成为自己的代码，直到完全理解Scala Future如何使用 for 表达式感到满意为止。

## 讨论

也可以通过执行错误的操作来确认之前的方法是正确的。给定和前面例子同样的包导入以及slowDouble、delta 和 time 方法。以下代码展示了在 for 表达式中用错误的方式使用Future：

```scala
@main def multipleFuturesWrong =
    val t0 = System.currentTimeMillis
    // WARNING: THIS IS THE INTENTIONALLY WRONG APPROACH
    println(s"\nentering `for`: ${delta(t0)}")
    val result = for
        r1 <- slowlyDouble(x=1, t0, delay=1500, name="f1")
        r2 <- slowlyDouble(x=2, t0, delay=250, name="f2")
        r3 <- slowlyDouble(x=3, t0, delay=500, name="f3")
    yield (r1 + r2 + r3)
    println("\nBEFORE onComplete")
    result.onComplete {
        case Success(x) => {
            println(s"\nresult = $x (delta = ${delta(t0)})")
            println("note that you don't get the result until the last future completes")
        }
        case Failure(e) => e.printStackTrace
        }
    println("AFTER onComplete\n")
    // important for a little parallel demo: keep the jvm alive
    sleep(3_000)
```

当运行这段代码时，你会看到类似这样的输出:

```scala
entering `for`: 0
entered f1: 1

BEFORE onComplete
AFTER onComplete

leaving f1: 1503
entered f2: 1503
leaving f2: 1758
entered f3: 1758
leaving f3: 2260

result = 12 (delta = 2261)
```

输出显示了：

- f1 future快速进入(在delta=1时)。
- f1 future在1500毫秒后退出。
- f2在f1完成之后那个时间进入，并且退出时间不超过250毫秒
- 在f2完成后，f3进入，并且代码又暂停了500多毫秒

这表明 f1、f2 和 f3 不是并行运行，而是一个在另一个之后的串行运行。 需要明确的是，这是错误的，并不是想要的。

### 警告：Future 不是引用透明的

如果对函数式编程感兴趣，关键要知道Scala的Future不是引用透明的，因此不适合 FP。 因为Future 是eager的并且立即开始运行，因此不能重构代码来用结果替换表达式（反之亦然）。

如果对编写类似Future代码的函数方式感兴趣，请参阅 ZIO 库，Cats Effect IO monad—在 Typelevel Scala 博客文章“Concurrency in Cats Effect 3”有讨论—以及 Monix task，因为他们编写函数式、惰性、异步代码。

# 18.5 创建面向对象风格的Actor

## 问题

从本章节的介绍中，知道可以创建OOP或者FP风格的Akka Typed Actor，并且想看到和理解OOP风格。

## 解决方法

OOP解决方案是类和伴生对象的组合：

- 在对象中定义 (a) Actor可以处理的消息和  (b) apply工厂方法。
-  该类继承了Akka AbstractBehavior 类并实现了onMessage 方法。
- 该类被定义为私有的，因此无法访问其构造函数，调用者必须使用对象的 apply 方法。

这是一个名为Tom的对象示例，它基于电影*50 First Dates*中的 Tom角色。定义了一个 Message trait和以及扩展它的Hello样例对象。 基于这些定义和类中展示的匹配表达式，Hello 是这个actor可以唯一处理的消息。

> Sealed Traits的说明
> 对于这个简单的例子，sealed trait 不是必需的；可以为消息只使用一个样例对象。 但在现实中会遵循这样的模式，所以我在这个例子展示了它。

该对象还定义了一个**apply**方法，其它地方用这个方法来构造Actor。正如我在5.4小节中提到的，“为类定义辅助构造函数”，对象中的**apply**方法的工作方式类似于工厂方法，允许构造实例类。

注意，**apply**方法使用Akka Behaviors.setup方法创建了一个新的Tom类的实例:

```scala
object Tom {
    // “messages” that Tom can handle
    sealed trait Message
    case object Hello extends Message
    // the factory/constructor method
    def apply(): Behavior[Message] =
    Behaviors.setup(context => new Tom(context))
}
```

根据Scaladoc，**Behaviors.setup** “是行为工厂。 行为实例的创建被推迟到actor启动……工厂函数通过传递ActorContext 作为参数，可用于生成子actor。 **setup**是通常在生成actor时用作最外层的行为。”

创建完该对象后，这样定义 Tom 类：

```scala
import Tom.{Message, Hello}
private class Tom(context: ActorContext[Message]) extends AbstractBehavior[Message](context) {
    override def onMessage(message: Message): Behavior[Message] = {
        message match {
            case Hello => println("Hi, I’m Tom.")
            this // return the current behavior
            // Behaviors.same
        }
	}
}
```

关于这个类的几点：

- 首先从Tom对象导入消息使得这个类的其余部分易读。
- 将类的构造函数设为私有，因此只有伴生对象可以访问它。
- 构造函数接收一个ActorContext实例，类型为Message且伴生对象中定义。
- 该类继承了**Akka AbstractBehavior**类，并实现了抽象方法**onMessage**。
- **onMessage**接收**Message**实例。
- **onMessage**的返回类型为**Behavior[Message]**，所以返回了**Behavior.same**。虽然在这个例子中使用有些过度了，但是**Behavior Scala文档**表明“建议系统复用以前的行为”。当处理拥有多种行为的复杂actor时会更有意义，并且可以根据所需使用返回值来更改行为。 18.8小节有关于更改状态的详细信息。

在这个例子中，使用匹配表达式来处理**Message**。 虽然在这个例子中并不是必需的，但它是处理消息的常用方式，所以我展示它。

现在我们拥有了Tom类和伴生对象，这个App例子展示了是如何工作的：

```scala
import akka.actor.typed.Behavior
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.ActorContext
import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.scaladsl.AbstractBehavior
object HiImTomOop extends App {
    val actorSystem: ActorSystem[Tom.Message] = ActorSystem.create(Tom(), "50FirstDatesSystem")
    actorSystem ! Tom.Hello
    actorSystem ! Tom.Hello
    actorSystem ! Tom.Hello
    Thread.sleep(500)
    actorSystem.terminate()
}
```

关于这段代码的几点说明：





## 讨论



# 18.6 创建函数式风格的Actor

## 问题



## 解决方法



## 讨论





# 18.7 给Actor发消息

## 问题



## 解决方法



## 讨论



## 另见





# 18.8 创建多种状态的Actor(FSM)



## 问题



## 解决方法



## 讨论