# 集合：介绍

这是涵盖Scala集合类的五章中的第一章。 因为集合对任何编程语言都非常重要，这些章节提供了深入的
覆盖了Scala 的集合类和方法。 此外，这些章节在 *Scala Cookbook* 的第二版中已经完全重新组织，以
让您更容易找到诀窍。

集合的第一章介绍了集合类。 这本章的目的如何按照具体的需求，挑选并组织一个适合的集合类。 例如，如果你想要一个索引，不可变的序列，推荐使用 **Vector** 作为首选序列，但如果您想用索引，可变的序列则推荐**ArrayBuffer**。

本章之后，第 12 章介绍了最常用的 Scala 序列类，包括 **Vector**，**ArrayBuffer**，**List** 和 **Array**。 其他小节覆盖**ListBuffer**和**LazyList**。

第 13 章提供了最常用的方法，这些方法在Scala 序列类。 集合类以其内置可用的方法的深度而闻名，并且这章演示了这些方法。

第 14 章介绍了 Map 类型。 Scala Map类似于 Java **Map**、Ruby **Hash** 或Python **Dictionary**,因为它们由键值对组成，其中键必须唯一。 Scala 同时有可变和不可变的Map，它们都包含在这章。

最后，第 15 章介绍了其他集合类型，包括常用的**Tuple**和**Range**类型，以及Set、Queue和Stack。



## Scala不是Java

Scala的集合类设计既深且广，和其他语言，比如说Java的集合类有很大不同。刚接触使用的时候，有可能有些不太适应，但一定用起来，你会感受到它们的优雅。

由于这些方法的深入，很少需要写(或读)自定义的for循环。事实证明，许多自定义开发循环的人员一直遵循特定的循环模式，因此这些循环被封装集合的内置方法中，如filter, map, foreach等。当第一版Scala Cookbook于2013年发布，丰富的集合方法对于有Java背景的人来说是相当震惊的，但是现在Java集合有很多函数式接口，转化会容易很多。

然而，当你开始使用Scala时，最好还是忘记Java集合类，并专注于Scala集合。例如，当Java开发人员第一次使用Scala时，他们可能会想，“好的，我要使用列表和数组，对吧? ”嗯,不,不是真的。Scala List类与Java List类非常不同，其中包括Scala List是不可变的部分。虽然Scala Array是围绕Java Array的包装器。并且提供了许多用于处理数组的内置方法，但是不推荐它作为顺序集合类。

根据我的的经验，我从 Java 转到 Scala 并一直尝试在我的Scala应用中使用 Java 集合。 这太浪费时间了。 虽然Java 集合在 Scala 中工作良好，此功能仅适用于与 Java 代码互相操作。 现在回想起来，尝试使用 Java 集合类作为我的Scala 应用程序中默认的集合只会减慢我的学习进度。与其和我一样， 我鼓励你直接正确深入和学习Scala的方式！ 本章将帮助你找到那些需要的类。

## Scala 2.13 集合全面改造

作为最后介绍性说明，Scala 2.13 版本（于 2018 年结束）以其对集合的全面改造而闻名。 而这些集合实现的”幕后“涉及特质和类型继承的重大变化，这些变化在多数情况下对用户是透明的。

这是一件好事，因为 Scala 开发人员享受集合的最终结果。因此，你使用外部 API的类，如 List、Vector、ArrayBuffer、Map 和 Set—基本保持不变。 如果有的话，Scala 2.13 和 Scala 3 已经简化了这些内部表示，因此你的代码和类型比之前都简单。

提到这次全面改造是因为 Scala 3 的集合库是紧随着 Scala 2.13集合库而变化，所以随着除了元组（在 Scala 3 中已明显更新）之外，许多集合就像在 Scala 2.13 中一样工作。 同样，这是一件好事。如果你对 Scala 2.13 全面改造的细节感兴趣，这有三个很好的资源讲述这些变化背后的故事：

- [Scala 3 页面Scala 2.13的集合]()
- [Scala 3 页面关于Scala 2.13的集合架构]()
- [Scala 2.13 类层次结构概述]()

# 理解集合的层次

关于集合，需要了解的第一件事是它们都包含在表11-1的包中。一般来说，集合中的scala.collection是scala.collection.immutable和scala.collection.mutable的超类 (或者准确地说是超类型)。这意味着基本操作由scala.collection所提供。并且不可变和可变操作被添加到其它两个包的类型中。

Table 11-1.

| 字符序列                   | 描述                                                   |
| -------------------------- | ------------------------------------------------------ |
| scala.collection           | 集合是不可变或者可变的                                 |
| scala.collection.immutable | 不可变集合。创建之后永远不变。                         |
| scala.collection.mutable   | 可变集合。它们有一些（或许多）方法允许更改集合的元素。 |



## 集合即深且广

Scala集合层次结构非常丰富-即深且广。当你选择一个类或者方法解决问题时候，理解它们如何组织的将会非常有用。图11-1显示了Vector类继承的特质，并展示了Scala集合层次结构的复杂性。



![](images\ch11\Figure11-1.png)

Figure11-1


因为（a）Scala类可以从traits继承，（b）精心设计的traits是粒度的，类层次结构可以如下所示。然而，不要让图11-1让你陷入困境：使用Vector不需要知道所有这些traits。事实上，使用Vector很直接：

```scala
val x = Vector(1, 2, 3)
x.sum // 6
x.filter(_ > 1) // Vector(2, 3)
x.map(_ * 2) // Vector(2, 4, 6)
x.takeWhile(_ < 3) // Vector(1, 2)
```

在高层次上，Scala的集合类以Iterable trait开始并扩展到序列(Seq)、集合(Set)和映射(Map)的三个主要类别。序列进一步分支成索引序列和线性序列，如图11-2所示。


![](images/ch11/Figure11-2.png)

Figure11-2

Iterable trait定义了一个迭代器，它允许你循环中一次遍历集合中一个元素。但在使用迭代器时，只能遍历集合

一次，因为每个元素都是在迭代过程中消耗的。

### Sequences

深入一点挖掘*sequence*层次结构，Scala包含大量的序列类型。最常见的不可变序列如图11-3所示，最常见的可变序列如图11-4所示。

![](images/ch11/Figure11-3.png)

Figure11-3  部分Scala不可变序列层次结构





![](images/ch11/Figure11-4.png)

Figure11-4  部分Scala可变序列层次结构



如图11-3所示，不可变序列分成两大类: 索引序列和线性序列(链表)。IndexedSeq显示元素的随机访问是有效的，例如访问Vector元素为xs(1 _000_000)。默认情况下，指定使用Scala 3的IndexedSeq将创建一个Vector：

```scala
scala> val x = IndexedSeq(1,2,3)
x: IndexedSeq[Int] = Vector(1, 2, 3)
```



LinearSeq意味着一个集合可以被有效地分割成头部和尾部组件，通常使用时候用head, tail和isEmpty方法。注意，在Scala 3中创建LinearSeq会创建一个List，这是一个单链表:

```scala
scala> val xs = scala.collection.immutable.LinearSeq(1,2,3)
xs: scala.collection.immutable.LinearSeq[Int] = List(1, 2, 3)
```



在图11-4所示的可变序列中，ArrayBuffer是最常见的。当需要可变序列时，建议使用。这里快速浏览一下
如何使用ArrayBuffer:

```scala
scala> import scala.collection.mutable.ArrayBuffer

scala> val xs = ArrayBuffer(1,2,3)
val xs: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3)

scala> xs.addOne(4)
val res0: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4)

scala> xs.addAll(List(5,6,7))
val res1: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7)
```

上面展示了addOne和addAll方法，但那是相对新添加的; 从历史上看，通常使用+=和++=也能达到上面目的:

```scala
scala> xs += 8
val res2: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8)
scala> xs ++= List(9,10)
val res3: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
```



### Maps

和Java Map、Ruby Hash或Python字典一样，Scala Map是键/值集合，其中所有键必须唯一。最常见的不可变和

可变Map类分别如图11-5和11-6所示。

![](images/ch11/Figure11-5.png)



Figure 11-5 常用的不可变Map类



![](images/ch11/Figure11-6.png)

Figure 11-5 常用的可变Map类



Map类型在Recipe 14.1“创建和使用Map”中有介绍，但只是简介。当只需要一个简单的不可变Map时，可以不需要import语句创建Map:

```scala
scala> val m = Map(1 -> "a", 2 -> "b")
val m: Map[Int, String] = Map(1 -> a, 2 -> b)
```

可变Map默认不在作用域内，必须导入或指定完整路径去使用:

```scala
scala> val mm = collection.mutable.Map(1 -> "a", 2 -> "b")
val mm: scala.collection.mutable.Map[Int, String] = HashMap(1 -> a, 2 -> b)
```

### Sets

和Java Set一样，Scala Set是包含唯一元素的集合。常用不可变的和可变**Set**类分别如图11-7和11-8所示。

![](images/ch11/Figure11-7.png)

Figure 11-7.  常用不可变Set类

![](images/ch11/Figure11-8.png)

Figure 11-8.  常用可变Set类



集合特质和类在15.3小节“创建集合和添加元素”中有介绍，但作为快速浏览，如果只是需要一个不可变Set，你可以不需要import语句创建：

```scala
scala> val set = Set(1, 2, 3)
val set: Set[Int] = Set(1, 2, 3)
```

和Map一样，如果你想使用一个可变的Set，必须导入或指定完整路径去使用：

```scala
scala> val mset = collection.mutable.Set(1, 2, 3)
val mset: scala.collection.mutable.Set[Int] = HashSet(1, 2, 3)
```

总结下，以上是Scala集合层次结构的概述。

# 选择一个集合类

## 问题

你想选择Scala集合类去解决特定的问题.

## 解决方法

集合类有三大类可选择:

-  Sequence
-  Map
-  Set

Sequence是可被索引或线性(链表)的元素组成的集合，Map包含唯一键的键/值对的集合，就像Java map，
Ruby Hash，或者Python字典。集合是一个不包含重复元素的Sequence。

除了这三个主要类别外，还有其余有用的集合类型，包括Range,、Stack和Queue。其它一些有些像集合，包括
Tuples和Option、Try和Either错误处理类。

### 选择Sequence

在选择一个Sequence时(一个连续的元素集合)，有两个主要考虑:

- 序列是否应该被索引，且允许快速访问任何元素，还是应该作为一个去链表实现?
- 想要一个可变的还是不可变的集合?

从Scala 2.10到Scala 3，一般顺序集合推荐可变/不可变和索引/线性的组合，如表11-2所显示。

Table 11-2. Scala推荐的通用目的顺序集合

|                       | Immutable | Mutable     |
| --------------------- | --------- | ----------- |
| Indexed               | Vector    | ArrayBuffer |
| Linear (Linked lists) | List      | ListBuffer  |

读取表可以作为一个例子，如果你想要一个不可变的，索引的集合一般来说，应该使用Vector，如果您想要一个可变的、索引的集合，请使用ArrayBuffer等。

虽然这是一般性的建议，但是序列还有更多可选项。Table 11-3中显示了最常见的不可变序列的选项。

Table 11-3. 主要不可变序列选择

| Class    | IndexedSeq | LinearSeq | Description |
| -------- | ---------- | --------- | ----------- |
| LazyList |            | √         |             |
| List     |            | √         |             |
| Queue    |            | √         |             |
| Range    | √          |           |             |
| Vector   | √          |           |             |

最常见的可变序列选择如表11-4所示。 Queue 和 Stack 也在其中，因为这些类有不可变和可变版本。 描述中的所有引用都来自每个类的Scaladoc。

Table 11-4. 主要可变序列选择

| Class         | IndexedSeq | LinearSeq | Buffer | Description |
| ------------- | ---------- | --------- | ------ | ----------- |
| Array         | √          |           |        |             |
| ArrayBuffer   | √          |           | √      |             |
| ArrayDeque    | √          |           |        |             |
| ListBuffer    |            | √         | √      |             |
| Queue         | √          |           |        |             |
| Stack         | √          |           |        |             |
| StringBuilder | √          |           |        |             |

注意我在两列下列举了 **ArrayBuffer** 和 **ListBuffer**。 因为虽然它们都是 **Buffer** 的后代——一个可以增长和缩减的 **Seq**——**ArrayBuffer** 的行为类似于 **IndexedSeq**，而 **ListBuffer** 的行为类似于 **LinearSeq**。

除了表中显示的内容外，性能也是一个考虑因素。 如果在选择过程中注重性能，可以参考11.2小节。

在为库创建API时，也许希望通过序列的超类来引用序列。 表11-5显示了在API中集合经常使用的特质。 注意，描述中的所有引用都来自每个类的Scaladoc。

Table 11-5. 类库API中常用的特质

| Trait      | Description |
| ---------- | ----------- |
| IndexedSeq |             |
| LinearSeq  |             |
| Seq        |             |
| Iterable   |             |

### 选择Map

虽然通常可以使用基本的不可变或可变**Map**类，但还有更多类型可以使用。 **Map**类选择如表 11-6 所示。 注意，描述中的所有引用都来自每个类的Scaladoc。

表11-6 常见的Map选择

| Class                 | Immutable | Mutable | Description |
| --------------------- | --------- | ------- | ----------- |
| CollisionProofHashMap |           | √       |             |
| HashMap               | √         | √       |             |
| LinkedHashMap         |           | √       |             |
| ListMap               | √         | √       |             |
| Map                   | √         | √       |             |
| SeqMap                |           | √       |             |
| SortedMap             | √         | √       |             |
| TreeMap               | √         | √       |             |
| TreeSeqMap            | √         |         |             |
| VectorMap             | √         |         |             |
| WeakHashMap           |           | √       |             |

关于基本**Map**类的细节，参考14.1节“创建和使用**Map**”，关于选择Map类的更多内容，参考14.2节“选择**Map**实现”。关于排序**Map**类的详细信息，参考14.10节“按键或值对现有**Map**进行排序” 。

### 选择Set

当选择**Set**时，有基本的可变和不可变集合类，**SortedSet**按键顺序返回元素，**LinkedHashSet**按插入顺序存储元素，以及其他用于特殊目的集合。常用类如表11-7所示。注意描述中的所有引用都来自于每个类的Scaladoc。

表11-7 常见的Set选择

| Class         | Immutable | Mutable | Description |
| ------------- | --------- | ------- | ----------- |
| BitSet        | √         | √       |             |
| HashSet       | √         | √       |             |
| LinkedHashSet |           | √       |             |
| ListSet       | √         |         |             |
| TreeSet       | √         | √       |             |
| Set           | √         | √       |             |
| SortedSet     | √         | √       |             |

关于基本**Set**类的详细内容，参考15.3 节“创建集合并添加元素”，关于可排序**Set**的详细内容，参考15.5 节“按排序顺序在Set中存储值”。

### 类似于集合的类型

Scala提供了其他集合类型，有些类型类似于集合，因为它们有map、filter等方法。表11-8提供了几种类型的描述，这些类型类似于集合但并不是。

表 11-8  其他集合类（以及类似于集合的类型）

| Class/Trait | Description |
| ----------- | ----------- |
| Iterator    |             |
| Option      |             |
| Tuple       |             |

因为在表11-8中提到了**Option**，所以值得注意的是，**Either/Left/Right** 和 **Try/Success/Failure** 类也有些类似集合的方法，例如 **flatten** 和 **map**，但没有 **Option** 提供的这么多。

### 严格和惰性集合



## 另见

除了本人使用集合的经验外，用于创建这些表的大部分内容来自每个类型的Scaladoc，以及这些Scala页面：

- The Scala documentation on mutable and immutable collections
- “The Architecture of Scala Collections”

# 理解集合的性能

## 问题

当给应用程序选择集合时，如果性能很重要，希望为算法选择正确的集合。

## 解决方法

在许多情况下，可以通过了解集合的基本结构来理解集合的性能。 例如**List**是一个单链表，且没有索引，如果需要访问 **list(1_000_000)** 这样的元素，则需要遍历一百万个元素。 所以比访问 **Vector** 的第一百万位的元素要慢得多，因为 **Vector** 是索引的。

在其他情况下，查看表格会有所帮助。例如表11-10显示了对 **Vector** 的*append*操作是 eC，或者有效常量时间。所以在我的电脑REPL中，一秒内可以创建一个很大的**Vector**，如下所示：

```scala
var a = Vector[Int]()
for i <- 1 to 50_000 do a = a :+ i
```

但是如表格所示，对**List**进行*append*操作需要线性时间，因此尝试创建相同大小的**List**需要更长的时间——超过15秒。

注意这些方式都不推荐用于实际代码。 使用它们只是来演示**Vector**和**List**在*append*操作方面的性能差异。

### 性能特征键

在查看性能表之前，表11-9显示了后面的表中使用的性能特征键。

表11-9  后续表格的性能特征键

| Key  | Description |
| ---- | ----------- |
| Con  |             |
| eC   |             |
| aC   |             |
| Log  |             |
| Lin  |             |
| -    |             |



### 顺序集合的性能特征

表11-10展示了对不可变和可变顺序集合操作的性能特征。

表11-10  顺序集合的性能特征

|               | head | tail | apply | update | prepend | append | insert |
| ------------- | ---- | ---- | ----- | ------ | ------- | ------ | ------ |
| **Immutable** |      |      |       |        |         |        |        |
| List          | Con  | Con  | Lin   | Lin    | Con     | Lin    | -      |
| LazyList      | Con  | Con  | Lin   | Lin    | Con     | Lin    | -      |
| ArraySeq      | Con  | Lin  | Con   | Lin    | Lin     | Lin    | -      |
| Vector        | eC   | eC   | eC    | eC     | eC      | eC     | -      |
| Queue         | aC   | aC   | Lin   | Lin    | Lin     | Con    | -      |
| Range         | Con  | Con  | Con   | -      | -       | -      | -      |
| String        | Con  | Lin  | Con   | Lin    | Lin     | Lin    | -      |
| **Mutable**   |      |      |       |        |         |        |        |
| ArrayBuffer   | Con  | Lin  | Con   | Con    | Lin     | aC     | Lin    |
| ListBuffer    | Con  | Lin  | Lin   | Lin    | Con     | Con    | Lin    |
| StringBuilder | Con  | Lin  | Con   | Con    | Lin     | aC     | Lin    |
| Queue         | Con  | Lin  | Lin   | Lin    | Con     | Con    | Lin    |
| ArraySeq      | Con  | Lin  | Con   | Con    | -       | -      | -      |
| Stack         | Con  | Lin  | Lin   | Lin    | Con     | Lin    | Lin    |
| Array         | Con  | Lin  | Con   | Con    | -       | -      | -      |
| ArrayDeque    | Con  | Lin  | Lin   | Con    | aC      | aC     | Lin    |

表11-10中列标题的含义如表11-11所示。

表11-11  表11-10中列标题的描述

| Operation | Description |
| --------- | ----------- |
| head      |             |
| tail      |             |
| apply     |             |
| update    |             |
| prepend   |             |
| append    |             |
| insert    |             |

### Map和Set的性能特征

表11-12展示了Scala 的常见Map和Set类型的性能特征，并且使用表11-9中的键。

表11-12. Map和Set的性能特征

|                 | lookup | add  | remove | min  |
| --------------- | ------ | ---- | ------ | ---- |
| **Immutable**   |        |      |        |      |
| HashSet/HashMap | eC     | eC   | eC     | Lin  |
| TreeSet/TreeMap | Log    | Log  | Log    | Log  |
| BitSet          | Con    | Lin  | Lin    | eC   |
| VectorMap       | eC     | eC   | eC     | Lin  |
| ListMap         | Lin    | Lin  | Lin    | Lin  |
| **Mutable**     |        |      |        |      |
| HashSet/HashMap | eC     | eC   | eC     | Lin  |
| WeakHashMap     | eC     | eC   | eC     | Lin  |
| BitSet          | Con    | aC   | Con    | eC   |
| TreeSet         | Log    | Log  | Log    | Log  |

表 11-13提供了对表11-12 中使用的列标题（操作）的描述。

表 11-13  表11-12中列标题的描述

| Operation | Description |
| --------- | ----------- |
| lookup    |             |
| add       |             |
| remove    |             |
| min       |             |

## 讨论

从表11-9中对键的描述可以看出，在选择集合时，通常想找到Con、eC和aC键以获得最佳性能。

例如，由于**List**是一个单链表，访问头部和尾部元素是快速操作，prepend元素的过程也是如此，所以这些操作在表11-10 中用Con键显示。 但是将元素append到**List**是一个很慢的操作———与List的大小成线性关系—所以append操作使用Lin键显示。  

## 另见·

- 经过EPFL许可，本小节的表格从Scala 性能特征文档页面重新生成而来。

# 理解可变变量与不可变集合

## 问题

你可能见过将不可变集合设置为可变变量时看起来是可变的。例如，当把一个不可变的Vector赋给一个可变变量（var）时，似乎可以给它添加元素：

```scala
var x = Vector(1) // x: Vector(1)
x = x :+ 2 // x: Vector(1, 2)
x = x ++ List(3, 4) // x: Vector(1, 2, 3, 4)
```

怎么会这样？

## 解决方法

尽管看起来在改变一个不可变集合，但实际上每次添加元素时，变量x都指向一个新的序列。x是可变的——就像java中的非**final**字段——因此每次执行时实际上会重新赋值一个新序列。最终结果类似于下面代码：

```scala
var x = Vector(1)
x = Vector(1, 2) // reassign x
x = Vector(1, 2, 3, 4) // reassign x again
```

上面代码的第二和第三行，x的引用赋值给一个新的序列。

可以证明**Vector**本身是不可变的。 试图改变其中的一个元素，将不会重新赋值给变量，会产生错误：

```scala
scala> x(0) = 100
1	|x(0) = 100
    |^
    |value update is not a member of Vector[Int] - did you mean
    |Vector[Int].updated?
```



## 讨论

初学Scala时，本节包含在第一个与集合相关的小节中，你可能对不可变集合拥有可变变量的行为感到惊讶，要明确关于变量：

- 可变变量（**var**）可以重赋值给新数据。
- 不可变变量（**val**）就如Java中的**final**变量，不能被重新赋值。

要明确的是**collections**中：

- 可变集合中的元素可以被改变（如**ArrayBuffer**）。
- 不可变集合中的元素不可被改变（如**Vector**或**List**）。

在纯函数式编程中，可以把不可变变量和不可变集合结合使用，在不太严格的编程风格中，可以使用其他组合。 比如下面两种组合也很常见：

- 不可变变量和可变集合（如 **val ArrayBuffer**）。
- 可变变量和不可变集合（如 **var Vector**）。

集合章节中的这些小节，以及领域建模章节，均展示了这些技术。

# 在集合上创建惰性视图

## 问题

处理一个大集合，并希望创建惰性版本，在需要时计算和返回结果。

## 解决方法

通过调用**view**方法在集合上创建*view*。 这将创建一个新集合，其*transformer methods*以非严格或惰性的方式实现。 例如给定一个大列表：

```scala
val xs = List.range(0, 3_000_000) // a list from 0 to 2,999,999
```

假想在它上面调用一些转换方法，比如**map**和**filter**。 这是人为的例子，但说明了一个问题：

```scala
val ys = xs.map(_ + 1)
  .map(_ * 10)
  .filter(_ > 1_000)
  .filter(_ < 10_000)
```

如果尝试在REPL中运行这个例子，可能会出现致命的错误“out of memory”：

```scala
scala> val ys = xs.map(_ + 1)
java.lang.OutOfMemoryError: GC overhead limit exceeded
```

相反，下面例子几乎会立即返回并且不会抛出错误，因为所做的只是创建一个视图，然后创建四个惰性转换器方法：

```scala
val ys = xs.view
  .map(_ + 1)
  .map(_ * 10)
  .filter(_ > 1_000)
  .filter(_ < 10_000)
// result: ys: scala.collection.View[Int] = View(<not computed>)
```

现在可以使用**ys**而不会耗尽内存：

```scala
scala> ys.take(3).foreach(println)
1010
1020
1030
```



## 讨论







