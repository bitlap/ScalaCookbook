# 23. 类型

看一眼集合类的Scaladoc就能知道，Scala有一个强大的类型系统。然而，除非你是一个类库的创建者，否则你可以在Scala中走很长的路，而不必深入地去了解Scala类型的深处。但是一旦你开始为其他用户创建类库，你就需要学习它们。

本章为你会遇到的最常见的类型相关问题提供了示例，但当你需要深入了解时，我强烈推荐 *Programming in Scala*（Artima）这本书。这本书的作者之一 Martin Odersky 是Scala编程语言的创建者，我认为这本书是Scala的“参考指南”。

Scala的类型系统使用一组符号（symbols）来表达不同的泛型（generic）类型概念，包括 *边界（bounds）*、*形变（variance）* 和 *约束（constraints）* 等概念。在进入本章正文之前，我在下面几个小节总结了最常见的这些符号。

### 关于编程水平和类型的说明 -- TODO 鸽子栏

早在2011年1月，Martin Odersky就定义了不同类型的Scala程序员需要的六个知识层次（ *https://oreil.ly/FGTc2* ）。他将A1-A3级别用于应用程序员，L1-L3级别用于类库设计者。本章所展示的类型相关技术与他的L1至L3级别相对应。

## 泛型类型参数

当你刚开始写Scala代码时，你会使用 **Int**、**String**等类型，以及你创建的自定义类型，如**Person**、**Employee** 和 **Pizza**。然后，你会创建特质、类和使用这些类型的方法。下面是一个使用 **Int** 类型以及 **Seq[Int]** 的例子：
```scala
    // 忽略可能发生的错误
    def first(xs: Seq[Int]): Int = xs(0)
```

**Seq[Int]** 是一种容器类型，它可以作为另一种类型的容器。同样地，**List[String]** 和 **Option[Int]** 也是容器类型。

随着你在处理类型方面的经验越来越丰富，当你看 **first** 方法时，你会发现它的返回类型与 **Seq** 容器中的内容完全没有关系。**Seq** 可以包含 **Int**、**String**、**Fish**、**Bird** 等类型，而方法的主体不会改变。因此，你可以用一个泛型类型重写这个方法，就像这样：
```scala
    def first[A](xs: Seq[A]): A = xs(0) 
             ___         _    _
```

代码中的下划线部分显示了如何指定一个泛型类型。在代码中从右向左阅读：
- 如前所述，方法主体中没有引用该类型；只有 **xs(0)**。
- **A** 被用作方法的返回类型，而不是 **Int**。
- 在 **Seq** 中使用了 **A**，而不是 **Int** 。
- 在方法声明之前的括号中指定了 **A**。

关于最后一点，在方法签名前的括号中指定泛型类型，是告诉编译器和代码的读者，泛型类型可以用在（a）方法签名，（b）返回类型，或（c）方法主体，或这三个地方的任何组合。

这样编写泛型代码能使你的代码对更多的人有用。这个方法不再仅仅适用于 **Seq[Int]**，而是适用于 **Seq[Fish]**、**Seq[Bird]**，以及一般来说 —— 也就是 *generic* 这个词 —— 任何类型的 **Seq**。

按照惯例，当你在Scala中声明泛型时，第一个被指定的泛型使用字母 **A**，第二个泛型是 **B**，以此类推。例如，如果Scala不包括元祖，而你想声明一个自己的元祖类，以包含两种不同的类型，此时可以这样声明它：
```scala
    class Pair[A,B](val a: A, val b: B)
```

这里有几个例子说明如何使用该类：
```scala
    Pair(1, 2)        // A and B are both Int
    Pair(1, "1")      // A is Int, B is String
    Pair("1", 2.2)    // A is String, B is Double
```

在第一个例子中，**A**和 **B** 刚好有相同的类型，而在后两个例子中，**A** 和 **B** 是不同的类型。

最后，为了完善我们的第一个泛型例子，让我们创建一个使用泛型参数的特质，然后创建一个实现该特质的类。首先，让我们创建两个简单的类，这个例子将需要这些简单的类，还有我们之前的 **Pair** 类：
```scala
    class Cat
    class Dog
    class Pair[A,B](val a: A, val b: B)
```

在这个的背景下，你可以使用两个泛型类型参数来创建参数化特质：
```scala
    trait Foo[A,B]:
        def pair(): Pair[A, B]
```

请注意，你在特质名称后面声明了你需要的类型，然后在特质中引用了这些类型。

接下来，这是一个为狗和猫实现特质的类：
```scala
    class Bar extends Foo[Cat, Dog]:
        def pair(): Pair[Cat, Dog] = Pair(Cat(), Dog())
```

这第一行代码声明 **Bar** 适用于 **Cat** 和 **Dog** 类型，**Cat** 是 **A** 的特定替换，**Dog** 是 **B** 的替换：
```scala
    class Bar extends Foo[Cat, Dog]:
```

如果你想创建另一个继承 **Foo** 的类，并对 **String** 和 **Int** 进行操作。你可以这样写：
```scala
    class Baz extends Foo[String, Int]:
        def pair(): Pair[String, Int] = Pair("1", 2)
```

这些例子展示了在不同情况下如何使用泛型类型参数。

随着你更多地使用泛型类型，你会发现，你想对这些类型定义某些期望和限制。为了处理这些情况，你将使用边界、形变和类型约束，这些将在接下来讨论。

## 边界

边界让你能对类型参数进行限制。例如，想象一下，你想写一个方法来返回一个类型的 **name** 字段的大写版本：
```scala
    // this code won’t compile
    def upperName[A](a: A) = a.name.toUpperCase
```

这段代码与你想要的差不多，但它不会工作，因为不能保证类型 **A** 有一个 **name** 字段。作为这个问题的解决方案，如果你有一个像 **SentientBeing** 这样的类型，它声明了一个 **name** 字段：
```scala
    trait SentientBeing:
        def name: String
```

你可以通过使用一个边界来正确实现 **upperName** 方法，如下面的代码所示：
```scala
    def upperName[A <: SentientBeing](a: A) = a.name.toUpperCase
                  ------------------
```

这告诉编译器，无论 **A** 类型是什么，它必须是 **SentientBeing** 的一个子类，它被保证有一个 **name** 字段。因此，如果你有这样的类，它们是 **SentientBeing** 的子类：
```scala
    case class Dog(name: String) extends SentientBeing
    case class Person(name: String, age: Int) extends SentientBeing
    case class Snake(name: String) extends SentientBeing
```

**upperName** 方法在所有这些情况下都能如愿以偿地工作：
```scala
    upperName(Dog("rover"))       // "ROVER"
    upperName(Person("joe", 25))  // "JOE"
    upperName(Snake("Noodles"))   // "NOODLES"
```

这就是使用边界工作的本质。它们给你提供了一种方法来定义限制 —— 边界，或者说是泛型类型的可能性的边界。表23-1提供了常见边界符号的描述。

*表23-1. Scala的边界符号的描述*

|                     | Bound     | Description          |
|---------------------|-----------|----------------------|
| A <: B              | 上界        | A必须是B的一个子类型，见23.5小节。 |
| A >: B              | 下界        | A必须是B的一个超类型（父类型）。    |
| A <: Upper >: Lower | 下界和上界一起使用 | 类型A既有上界又有下界。         |

下界在集合类的一些方法中有示范。要找到它们的例子，可以在 **List**（ *https://oreil.ly/Q5pMd* ）等类的Scaladoc中搜索 **>:** 符号。

## 形变

## 类型约束
