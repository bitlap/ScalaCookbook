# 23. 类型

看一眼集合类的Scaladoc就能知道，Scala有一个强大的类型系统。然而，除非你是一个类库的创建者，否则你可以在Scala中走很长的路，而不必深入地去了解Scala类型的深处。但是一旦你开始为其他用户创建类库，你就需要学习它们。

本章为你会遇到的最常见的类型相关问题提供了示例，但当你需要深入了解时，我强烈推荐 *Programming in Scala*（Artima）这本书。这本书的作者之一 Martin Odersky 是Scala编程语言的创建者，我认为这本书是Scala的“参考指南”。

Scala的类型系统使用一组符号（symbols）来表达不同的泛型（generic）类型概念，包括 *边界（bounds）*、*形变（variance）* 和 *约束（constraints）* 等概念。在进入本章正文之前，我在下面几个小节总结了最常见的这些符号。

### 关于编程水平和类型的说明 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;早在2011年1月，Martin Odersky就定义了不同类型的Scala程序员需要的六个知识层次（ *https://oreil.ly/FGTc2* ）。他将A1-A3级别用于应用程序员，L1-L3级别用于类库设计者。本章所展示的类型相关技术与他的L1至L3级别相对应。

## 泛型类型参数

当你刚开始写Scala代码时，你会使用 **Int**、**String**等类型，以及你创建的自定义类型，如**Person**、**Employee** 和 **Pizza**。然后，你会创建特质、类和使用这些类型的方法。下面是一个使用 **Int** 类型以及 **Seq[Int]** 的例子：
```scala
    // 忽略可能发生的错误
    def first(xs: Seq[Int]): Int = xs(0)
```

**Seq[Int]** 是一种容器类型，它可以作为另一种类型的容器。同样地，**List[String]** 和 **Option[Int]** 也是容器类型。

随着你在处理类型方面的经验越来越丰富，当你看 **first** 方法时，你会发现它的返回类型与 **Seq** 容器中的内容完全没有关系。**Seq** 可以包含 **Int**、**String**、**Fish**、**Bird** 等类型，而方法的主体不会改变。因此，你可以用一个泛型类型重写这个方法，就像这样：
```scala
    def first[A](xs: Seq[A]): A = xs(0) 
             ___         _    _
```

代码中的下划线部分显示了如何指定一个泛型类型。在代码中从右向左阅读：
- 如前所述，方法主体中没有引用该类型；只有 **xs(0)**。
- **A** 被用作方法的返回类型，而不是 **Int**。
- 在 **Seq** 中使用了 **A**，而不是 **Int** 。
- 在方法声明之前的括号中指定了 **A**。

关于最后一点，在方法签名前的括号中指定泛型类型，是告诉编译器和代码的读者，泛型类型可以用在（a）方法签名，（b）返回类型，或（c）方法主体，或这三个地方的任何组合。

这样编写泛型代码能使你的代码对更多的人有用。这个方法不再仅仅适用于 **Seq[Int]**，而是适用于 **Seq[Fish]**、**Seq[Bird]**，以及一般来说 —— 也就是 *generic* 这个词 —— 任何类型的 **Seq**。

按照惯例，当你在Scala中声明泛型时，第一个被指定的泛型使用字母 **A**，第二个泛型是 **B**，以此类推。例如，如果Scala不包括元祖，而你想声明一个自己的元祖类，以包含两种不同的类型，此时可以这样声明它：
```scala
    class Pair[A,B](val a: A, val b: B)
```

这里有几个例子说明如何使用该类：
```scala
    Pair(1, 2)        // A and B are both Int
    Pair(1, "1")      // A is Int, B is String
    Pair("1", 2.2)    // A is String, B is Double
```

在第一个例子中，**A**和 **B** 刚好有相同的类型，而在后两个例子中，**A** 和 **B** 是不同的类型。

最后，为了完善我们的第一个泛型例子，让我们创建一个使用泛型参数的特质，然后创建一个实现该特质的类。首先，让我们创建两个简单的类，这个例子将需要这些简单的类，还有我们之前的 **Pair** 类：
```scala
    class Cat
    class Dog
    class Pair[A,B](val a: A, val b: B)
```

在这个的背景下，你可以使用两个泛型类型参数来创建参数化特质：
```scala
    trait Foo[A,B]:
        def pair(): Pair[A, B]
```

请注意，你在特质名称后面声明了你需要的类型，然后在特质中引用了这些类型。

接下来，这是一个为狗和猫实现特质的类：
```scala
    class Bar extends Foo[Cat, Dog]:
        def pair(): Pair[Cat, Dog] = Pair(Cat(), Dog())
```

这第一行代码声明 **Bar** 适用于 **Cat** 和 **Dog** 类型，**Cat** 是 **A** 的特定替换，**Dog** 是 **B** 的替换：
```scala
    class Bar extends Foo[Cat, Dog]:
```

如果你想创建另一个继承 **Foo** 的类，并对 **String** 和 **Int** 进行操作。你可以这样写：
```scala
    class Baz extends Foo[String, Int]:
        def pair(): Pair[String, Int] = Pair("1", 2)
```

这些例子展示了在不同情况下如何使用泛型类型参数。

随着你更多地使用泛型类型，你会发现，你想对这些类型定义某些期望和限制。为了处理这些情况，你将使用边界、形变和类型约束，这些将在接下来讨论。

## 边界

边界让你能对类型参数进行限制。例如，想象一下，你想写一个方法来返回一个类型的 **name** 字段的大写版本：
```scala
    // 这段代码无法编译
    def upperName[A](a: A) = a.name.toUpperCase
```

这段代码与你想要的差不多，但它不会工作，因为不能保证类型 **A** 有一个 **name** 字段。作为这个问题的解决方案，如果你有一个像 **SentientBeing** 这样的类型，它声明了一个 **name** 字段：
```scala
    trait SentientBeing:
        def name: String
```

你可以通过使用一个边界来正确实现 **upperName** 方法，如下面的代码所示：
```scala
    def upperName[A <: SentientBeing](a: A) = a.name.toUpperCase
                  ------------------
```

这告诉编译器，无论 **A** 类型是什么，它必须是 **SentientBeing** 的一个子类，它被保证有一个 **name** 字段。因此，如果你有这样的类，它们是 **SentientBeing** 的子类：
```scala
    case class Dog(name: String) extends SentientBeing
    case class Person(name: String, age: Int) extends SentientBeing
    case class Snake(name: String) extends SentientBeing
```

**upperName** 方法在所有这些情况下都能如愿以偿地工作：
```scala
    upperName(Dog("rover"))       // "ROVER"
    upperName(Person("joe", 25))  // "JOE"
    upperName(Snake("Noodles"))   // "NOODLES"
```

这就是使用边界工作的本质。它们给你提供了一种方法来定义限制 —— 边界，或者说是泛型类型的可能性的边界。表23-1提供了常见边界符号的描述。

*表23-1. Scala的边界符号的描述*

|               | Bound     | Description          |
|---------------|-----------|----------------------|
| A <: B        | 上界        | A必须是B的一个子类型，见23.5小节。 |
| A >: B        | 下界        | A必须是B的一个超类型（父类型）。    |
| A <: 上界 >: 下界 | 下界和上界一起使用 | 类型A既有上界又有下界。         |

下界在集合类的一些方法中有示范。要找到它们的例子，可以在 **List**（ *https://oreil.ly/Q5pMd* ）等类的Scaladoc中搜索 **>:** 符号。

## 形变

顾名思义，形变是一个概念，它与泛型类型参数在创建类型的子类时如何变化有关。Scala使用了所谓的 *声明端形变*，这意味着 —— 你作为库的创建者 —— 在创建新类型时，在泛型类型参数上声明了形变注释，例如特质和类。(这与Java相反，Java使用的是 *使用端形变*，这意味着库的使用者要负责理解这些注释）。

我发现，在创建的新类型像这样我们一直使用的 **List** 和 **ArrayBuffer** 的集合时，最容易展示形变。所以作为一个例子，我将创建一个名为 **Container** 的新类型，它包含一个元素。当我定义 **Container** 时，形变与我是否将其泛型类型参数 **A** 定义为 **A**、**+A** 或 **-A** 有关。
```scala
    class Container[A](a: A) ...  // invariant
    class Container[+A](a: A) ... // covariant
    class Container[-A](a: A) ... // contravariant
```

我 *现在* 如何声明 **A** 会影响到 *以后* 如何使用 **Container** 实例。例如，在这样的讨论中，形变会发挥作用：
    
    当我使用这些注释之一定义一个新的Container类型时，如果我还定义了一个Dog类，它是Animal的一个子类型，那么Container[Dog]是Container[Animal]的一个子类型吗？


具体来说，这意味着如果你有这样一个方法，它被定义为接受 **Container[Animal]** 类型的参数：
```scala
    def foo(c: Container[Animal]) = ???
```

你能把一个 **Container[Dog]** 传给 **foo** 吗？

### 简化形变的两种方法

形变的解释可能需要几个步骤，因为你必须同时谈论（a）泛型参数最初是如何声明的，以及（b）你的container的实例后来是如何使用的，但我发现有两种方法可以简化这个话题。

**1. 如果所有东西都是不可变的。**    简化形变的第一个方法是，如果Scala中的所有东西都是不可变的，那么就没有必要进行形变了。具体来说，在一个完全不可变的世界里，所有的字段都是 **val**，所有的集合都是不可变的（比如 **List** ），如果 **Dog** 是 **Animal** 的子类，**Container[Dog]** 肯定是 **Container[Animal]** 的子类。

### 在一个不可改变的世界中，不需要形变 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp; 在下面的讨论中，在一个完全不可改变的世界中，对形变的需求就消失了。


这在下面的代码中得到了证明。首先，我创建了一个 **Animal** 特质，然后创建了一个继承自动物的 **Dog** 样例类：
```scala
    sealed trait Animal:
        def name: String
    case class Dog(name: String) extends Animal
```

现在我定义了我的 **Container** 类，将其泛型类型参数声明为 **+A**，使其成为 *协变* 的。虽然这是一个花哨的数学术语，但它只是意味着当一个方法被声明为接受一个 **Container[Animal]** 时，你可以把一个 **Container[Dog]** 传给它。因为类型是协变的，所以它是灵活的，允许在这个方向上变化（即，允许接受一个子类型）：
```scala
    class Container[+A](a: A):
        def get: A = a
```

然后我创建了一个 **Dog** 的实例以及一个 **Container[Dog]** ，然后验证 **Container** 中的 **get** 方法是否如愿以偿：
```scala
    val d = Dog("Fido")
    val h = Container[Dog](d)
    h.get   // Dog(Fido)
```

为了完成这个例子，我定义了一个方法，它接受一个 **Container[Animal]** 参数：
```scala
    def printName(c: Container[Animal]) = println(c.get.name)
```

最后，我向该方法传递了一个 **Container[Dog]** 变量，该方法如愿以偿：
```scala
    printName(h)   // "Fido"
```

简而言之，所有这些代码都是有效的，因为所有东西都是不可变的，我用泛型参数 **+A** 定义了 **Container**。

请注意，如果我把该参数只定义为 **A** 或定义为 **-A** ，该代码就不会被编译。(关于这方面的更多信息，请继续阅读)。

**2. 形变与类型的“入”和“出”的位置有关。**    还有第二种方法来简化形变的概念，我将其总结为以下三段话：

正如你刚才看到的，**Container** 类中的 **get** 方法只使用 **A** 类型作为其返回类型。这并不是巧合：只要你把一个参数声明为 **+A** ，它就永远只能作为 **Container** 方法的返回类型。你可以认为这是一个 *输出（out）* 位置，可以说你的容器是一个 *生产者*：像 **get** 这样的方法会产生 **A** 类型值。除了刚才展示的 **Container[+A]** 类，其他生产者的例子是Scala的 **List[+A]** 和 **Vector[+A]** 类。对于这些类，一旦它们的实例被创建，你就不能再向它们添加更多的 **A** 值。相反，它们是不可变的和只读的，你只能通过内置的方法访问它们的 **A** 值。你可以把 **List** 和 **Vector** 看作是 **A** 类型元素（以及 **A** 的派生）的生产者。

相反，如果你指定的泛型类型参数只用作容器中的方法的输入参数，那么就用 **-A** 声明该参数是 *逆变（contravariant）* 的。这个声明告诉编译器，**A** 类型的值将只被传递到消费者（consumer）的方法中 —— “in”的位置 —— 并且它们永远不会被当作返回值。因此，你的容器被说成是一个 *消费者* 。(请注意，与其他两种可能性相比，这种情况很罕见，但在生产者/消费者的讨论中，最容易提到它。）

最后，如果泛型参数既被用于方法的返回类型位置，又被用作容器内的方法参数，那么通过用符号 **A** 来声明该类型是 *不变的（invariant）*。当你使用这种类型来声明类的泛型参数时，类既是 **A** 类型的生产者也是消费者，作为这种灵活性的副作用，该类型是不变的（invariant） —— 这意味着它不能变化。当一个方法被声明为接受 **Container[Dog]** 时，它只能接受一个 **Container[Dog]** 。这种类型在定义可变容器时使用，比如 **ArrayBuffer[A]** 类，你可以在其中添加新元素、编辑元素和访问元素。

下面是这三种生产者/消费者情况的例子。

在第一种情况下，当泛型只被用作方法的返回类型时，容器是生产者，你用 **+A** 标记该类型为协变：
```scala
    // 协变: A只在“Out”的位置使用。
    trait Producer[+A]:
        def get: A
```

请注意，对于这个用例，C#和Kotlin语言 —— 它们也使用声明端形变 —— 在定义 **A** 时使用了关键字 **out**。如果Scala使用 **out** 而不是 **+**，代码会是这样的：
```scala
    trait Producer[out A]:   // if Scala used 'out' instead
        def get: A
```

对于第二种情况，如果泛型参数只被用作容器方法的输入参数，那么可以把容器看作是一个 *消费者*。使用 **-A** 将泛型标记为逆变：
```scala
    // 逆变: A只在“in”的位置使用。
    trait Consumer[-A]:
        def consume(a: A): Unit
```

在这种情况下，C#和Kotlin使用关键字 **in** 来表示 **A** 只作为方法的输入参数（“in”的位置）。如果Scala有这个关键字，你的代码会是这样的：
```scala
    trait Consumer[in A]:   // if Scala used 'in' instead
        def consume(a: A): Unit
```

最后，当一个泛型类型的参数既被用作方法的输入参数又被用作方法的返回参数时，它被认为是不变的 —— 不允许变化，并被设计为 **A**：
```scala
    // 不变: A用于“in”和“Out”的位置
    trait ProducerConsumer[A]:
        def consume(a: A): Unit
        def produce(): A
```

### 一种记住形变符号的方法 -- TODO 耗子栏

&nbsp;&nbsp;&nbsp;&nbsp;虽然我一般喜欢用关键字 **out** 和 **in** 来声明泛型参数的变化 —— 至少在简单的、单参数的声明中，我发现这样可以记住Scala的符号：
- **+** 表示允许在正（子类型）方向上有变化。
- **-** 表示允许在负数（超类型）方向上有变化。
- 没有附加符号意味着不允许有变化。

表23-2提供了这些术语的摘要，包括Scala标准库中的每个例子。

*表23-2. Scala类型变化（形变）的描述和例子*

| Variance      | Symbol | In or Out | Producer/Consumer | Examples                                           |
|---------------|--------|-----------|-------------------|----------------------------------------------------|
| Covariant     | +A     | Out       | Producer          | **List[+A]**、**Vector[+A]**                        |
| Contravariant | -A     | In        | Consumer          | **Function1[-T1,+R]** 中的 **T1** 参数                 |
| Invariant     | A      | Both      | Both              | **Array[A]**、**ArrayBuffer[A]**、**mutable.Set[A]** |

实际上很难找到这些形变术语的一致定义，但微软的这个“通用术语中的协变和逆变”页面（ *https://oreil.ly/uZj51* ）提供了很好的定义，我在这里稍作重新表述：

*协变（Scala中的+A）* <br/>
让你使用一个比指定类型更“派生”的类型。这意味着你可以在声明了一个父类型的地方使用一个子类型。在我的例子中，这意味着你可以在声明了 **Container[Animal]** 方法参数的地方传递一个 **Container[Dog]**。

*逆变（-A）* <br/>
本质上与协变相反，你可以使用一个比指定的类型更通用（更少的派生）的类型。例如，你可以在指定使用 **Container[Dog]** 的地方使用 **Container[Animal]**。

*不变（A）* <br/>
这意味着类型不能变化 —— 你只能使用指定的类型。如果一个方法需要一个 **Container[Dog]** 类型的参数，你只能给它一个 **Container[Dog]**；如果你试图给它一个 **Container[Animal]**，它将不会被编译成功。

### 用implicitly测试形变

正如Stack Overflow的这篇帖子（ *https://oreil.ly/lYWr4* ）以及John De Goes和Adam Fraser（Ziverge）的 *Zionomicon* 一书中所展示的那样，你可以使用 **implicitly** 方法 —— 它被定义在 **Predef** 对象（ Scaladoc *https://oreil.ly/FB6Zw* ）中，你所的有代码都可访问它 —— 以此来测试形变的定义。

例如，使用我最初的形变例子中的这段代码：
```scala
    sealed trait Animal:
        def name: String
    case class Dog(name: String) extends Animal
    class Container[+A](a: A):
        def get: A = a
```

这些REPL例子表明，通过使用 **implicitly**，Scala编译器确认了 **Container[Dog]** 是 **Container[Animal]** 的一个子类型：
```scala
    scala> implicitly[Dog <:< Animal]
    val res0: Dog <:< Animal = generalized constraint
    
    scala> implicitly[Container[Dog] <:< Container[Animal]]
    val res1: Container[Dog] <:< Container[Animal] = generalized constraint
```

你可以说这些例子是有效的，因为代码的编译没有错误。相反，如果你用 **-A** 或 **A** 来定义 **Container**，就像在这个例子中：
```scala
    class Container[A](a: A):
        def get: A = a
```

**implicitly** 相关代码将无法编译：
```scala
    scala> implicitly[Container[Dog] <:< Container[Animal]] 
    1 |implicitly[Container[Dog] <:< Container[Animal]]
      |                                                ^
      |                   Cannot prove that Container[Dog] <:< Container[Animal].
```

这变成了一个很好的技巧/技术，你可以用来测试与形变有关的代码。

请注意，在这个例子中，表达式 **A <:< B** 意味着在处理隐式参数时，**A** 必须是 **B** 的子类型。这个 *类型关系（type relation）* 符号在本书中没有讨论，但请看Twitter的Scala School关于高级类型的页面（ *https://oreil.ly/ply5e* ），以了解关于在什么时候（什么地方）需要它的好例子。

### 很少使用逆变

为了保持一致，我在前面的讨论中第二次提到了逆变，但在实际中，逆变类型很少被使用。例如，Scala **Function1** 类（ *https://oreil.ly/xI64U* ）是标准库中少数几个声明泛型参数为逆变的类之一，如本例中的 **T1** 参数：
```scala
    Function1[-T1, +R]
```

因为不经常使用，所以本书没有涉及逆变，但在免费的 *Scala 3 Book* 的“Variance”部分有一个很好的例子（ *https://oreil.ly/jCrB7* ）。

### 具有形变的多个泛型类型参数 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;从 **Function1** 的例子中还可以注意到，一个类可以接受多个用形变声明的泛型参数。**-T1** 是一个只在 **Function1** 类中消耗的参数，而 **+R** 是一个只在 **Function1** 中产生的类型。

鉴于所有这些背景信息，在23.3和23.4小节中展示了常见的形变问题的两种解决方案。

## 类型约束

除了边界和形变之外，Scala还允许你指定额外的类型约束。这些都是用这些符号写的：
```scala
    A =:= B   // A必须与B相等
    A <:< B   // A必须是B的子类型
```

这些符号在本书中没有涉及。详情和例子见 *Programming in Scala*。在Twitter的Scala School的高级类型页面（ *https://oreil.ly/ply5e* ）也展示了使用它们的简要例子，其中它们被称为 *类型关系运算符（type relation operators）*。
 
### 其他几个类型的例子 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;在第一版Scala Cookbook中，我写了关于如何创建一个计时器以及如何创建自己的 **Try** 类（ *https://oreil.ly/QRdZr* ）。(我把它摘录在我的网站上）。那段代码大量使用了类型，它在Scala 3仍然适用。