# 23. 类型

看一眼集合类的Scaladoc就能知道，Scala有一个强大的类型系统。你可以顺畅的使用Scala很久，而不必去深入了解Scala的类型系统，除非你是一个类库的创建者。但是，一旦开始为其他用户创建类库，你就需要学习它们。

本章为你会遇到的最常见的类型相关问题提供了示例，但当你需要深入了解时，我强烈推荐 *Programming in Scala*（Artima）这本书。这本书的作者之一 Martin Odersky 是Scala编程语言的创建者，我认为这本书是Scala的“参考指南”。

Scala的类型系统使用一组符号（symbols）来表达不同的泛型（generic）类型概念，包括 *边界（bounds）*、*形变（variance）* 和 *约束（constraints）* 等概念。在进入本章正文之前，我在下面几个小节总结了最常见的这些符号。

### 关于编程水平和类型的说明 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;早在2011年1月，Martin Odersky就定义了不同类型的Scala程序员需要的六个知识层级（ *https://oreil.ly/FGTc2* ）。他将A1-A3级别用于应用程序员，L1-L3级别用于类库设计者。本章所展示的类型相关技术与他的L1至L3级别相对应。

## 泛型类型参数（泛型参数）

当你刚开始写Scala代码时，你会使用 **Int**、**String**等类型，以及你创建的自定义类型，如**Person**、**Employee** 和 **Pizza**。然后，你会创建特质、类和使用这些类型的方法。下面是一个使用 **Int** 类型以及 **Seq[Int]** 的例子：
```scala
    // 忽略可能发生的错误
    def first(xs: Seq[Int]): Int = xs(0)
```

**Seq[Int]** 是一种容器类型，它可以作为另一种类型的容器。同样地，**List[String]** 和 **Option[Int]** 也是容器类型。

随着你在处理类型方面的经验越来越丰富，当你看 **first** 方法时，你会发现它的返回类型与 **Seq** 容器中的内容完全没有关系。**Seq** 可以包含 **Int**、**String**、**Fish**、**Bird** 等类型，而方法的主体不会改变。因此，你可以用一个泛型类型参数重写这个方法，就像这样：
```scala
    def first[A](xs: Seq[A]): A = xs(0) 
             ___         _    _
```

代码中的下划线部分显示了如何指定一个泛型类型参数。在代码中从右向左阅读：
- 如前所述，方法主体中没有引用该类型；只有 **xs(0)**。
- **A** 被用作方法的返回类型，而不是 **Int**。
- 在 **Seq** 中使用了 **A**，而不是 **Int** 。
- 在方法声明之前的括号中指定了 **A**。

关于最后一点，在方法签名前的括号中指定泛型类型参数，是告诉编译器和代码的读者，泛型类型参数可以用在（a）方法签名，（b）返回类型，或（c）方法主体，或这三个地方的任何组合。

这样编写泛型代码能使你的代码对更多的人有用。这个方法不再仅仅适用于 **Seq[Int]**，而是适用于 **Seq[Fish]**、**Seq[Bird]**，以及一般来说 —— 也就是 *generic* 这个词 —— 任何类型的 **Seq**。

按照惯例，当你在Scala中声明泛型时，第一个被指定的泛型使用字母 **A**，第二个泛型是 **B**，以此类推。例如，如果Scala不包括元祖，而你想声明一个自己的元祖类，以包含两种不同的类型，此时可以这样声明它：
```scala
    class Pair[A,B](val a: A, val b: B)
```

这里有几个例子说明如何使用该类：
```scala
    Pair(1, 2)        // A and B are both Int
    Pair(1, "1")      // A is Int, B is String
    Pair("1", 2.2)    // A is String, B is Double
```

在第一个例子中，**A**和 **B** 刚好有相同的类型，而在后两个例子中，**A** 和 **B** 是不同的类型。

最后，为了完善我们的第一个泛型例子，让我们创建一个使用泛型参数的特质，然后创建一个实现该特质的类。首先，让我们创建两个简单的类，这个例子将需要这些简单的类，还有我们之前的 **Pair** 类：
```scala
    class Cat
    class Dog
    class Pair[A,B](val a: A, val b: B)
```

在这个的背景下，你可以使用两个泛型类型参数来创建参数化特质：
```scala
    trait Foo[A,B]:
        def pair(): Pair[A, B]
```

请注意，你在特质名称后面声明了你需要的类型，然后在特质中引用了这些类型。

接下来，这是一个为狗和猫实现特质的类：
```scala
    class Bar extends Foo[Cat, Dog]:
        def pair(): Pair[Cat, Dog] = Pair(Cat(), Dog())
```

这第一行代码声明 **Bar** 适用于 **Cat** 和 **Dog** 类型，**Cat** 是 **A** 的特定替换，**Dog** 是 **B** 的替换：
```scala
    class Bar extends Foo[Cat, Dog]:
```

如果你想创建另一个继承 **Foo** 的类，并对 **String** 和 **Int** 进行操作。你可以这样写：
```scala
    class Baz extends Foo[String, Int]:
        def pair(): Pair[String, Int] = Pair("1", 2)
```

这些例子展示了在不同情况下如何使用泛型类型参数。

随着你越来越多的使用泛型类型参数，你可能想对这些类型定义某些期望和限制。为了处理这些情况，你将使用边界、形变和类型约束，这些将在接下来讨论。

## 边界

边界让你能对类型参数进行限制。例如，想象一下，你想写一个方法来返回一个类型的 **name** 字段的大写版本：
```scala
    // 这段代码无法编译
    def upperName[A](a: A) = a.name.toUpperCase
```

这段代码与你想要的差不多，但它不会工作，因为不能保证类型 **A** 有一个 **name** 字段。作为这个问题的解决方案，如果你有一个像 **SentientBeing** 这样的类型，它声明了一个 **name** 字段：
```scala
    trait SentientBeing:
        def name: String
```

你可以通过使用一个边界来正确实现 **upperName** 方法，如下面的代码所示：
```scala
    def upperName[A <: SentientBeing](a: A) = a.name.toUpperCase
                  ------------------
```

这告诉编译器，无论 **A** 类型是什么，它必须是 **SentientBeing** 的一个子类，它被保证有一个 **name** 字段。因此，如果你有这样的类，它们是 **SentientBeing** 的子类：
```scala
    case class Dog(name: String) extends SentientBeing
    case class Person(name: String, age: Int) extends SentientBeing
    case class Snake(name: String) extends SentientBeing
```

**upperName** 方法在所有这些情况下都能如愿以偿地工作：
```scala
    upperName(Dog("rover"))       // "ROVER"
    upperName(Person("joe", 25))  // "JOE"
    upperName(Snake("Noodles"))   // "NOODLES"
```

这就是使用边界工作的本质。它们给你提供了一种方法来定义限制 —— 边界，或者说是泛型类型的可能性的边界。表23-1提供了常见边界符号的描述。

*表23-1. Scala的边界符号的描述*

|               | Bound     | Description          |
|---------------|-----------|----------------------|
| A <: B        | 上界        | A必须是B的一个子类型，见23.5小节。 |
| A >: B        | 下界        | A必须是B的一个超类型（父类型）。    |
| A <: 上界 >: 下界 | 下界和上界一起使用 | 类型A既有上界又有下界。         |

下界在集合类的一些方法中有示范。要找到它们的例子，可以在 **List**（ *https://oreil.ly/Q5pMd* ）等类的Scaladoc中搜索 **>:** 符号。

## 形变

顾名思义，形变是一个概念，它与创建类型的子类时，泛型类型参数是如何变化的有关。Scala使用了所谓的 *声明端形变*，这意味着 —— 你作为库的创建者 —— 在创建新类型时，在泛型类型参数上声明了形变注释，例如特质和类。(这与Java相反，Java使用的是 *使用端形变*，这意味着库的使用者要负责理解这些注释）。

我发现，在创建的新类型像这样我们一直使用的 **List** 和 **ArrayBuffer** 的集合时，最容易展示形变。所以作为一个例子，我将创建一个名为 **Container** 的新类型，它包含一个元素。当我定义 **Container** 时，形变与我是否将其泛型类型参数 **A** 定义为 **A**、**+A** 或 **-A** 有关。
```scala
    class Container[A](a: A) ...  // invariant
    class Container[+A](a: A) ... // covariant
    class Container[-A](a: A) ... // contravariant
```

我 *现在* 如何声明 **A** 会影响到 *以后* 如何使用 **Container** 实例。例如，在这样的讨论中，形变会发挥作用：
    
    当我使用这些注释之一定义一个新的Container类型时，如果我还定义了一个Dog类，它是Animal的一个子类型，那么Container[Dog]是Container[Animal]的一个子类型吗？


具体来说，这意味着如果你有这样一个方法，它被定义为接受 **Container[Animal]** 类型的参数：
```scala
    def foo(c: Container[Animal]) = ???
```

你能把一个 **Container[Dog]** 传给 **foo** 吗？

### 简化形变的两种方法

形变的解释可能需要几个步骤，因为你必须同时谈论（a）泛型参数最初是如何声明的，以及（b）你的container的实例后来是如何使用的，但我发现有两种方法可以简化这个话题。

**1. 如果所有东西都是不可变的。**    简化形变的第一个方法是，如果Scala中的所有东西都是不可变的，那么就没有必要进行形变了。具体来说，在一个完全不可变的世界里，所有的字段都是 **val**，所有的集合都是不可变的（比如 **List** ），如果 **Dog** 是 **Animal** 的子类，**Container[Dog]** 肯定是 **Container[Animal]** 的子类。

### 在一个不可改变的世界中，不需要形变 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp; 在下面的讨论中，在一个完全不可改变的世界中，对形变的需求就消失了。


这在下面的代码中得到了证明。首先，我创建了一个 **Animal** 特质，然后创建了一个继承自动物的 **Dog** 样例类：
```scala
    sealed trait Animal:
        def name: String
    case class Dog(name: String) extends Animal
```

现在我定义了我的 **Container** 类，将其泛型类型参数声明为 **+A**，使其成为 *协变* 的。虽然这是一个花哨的数学术语，但它只是意味着当一个方法被声明为接受一个 **Container[Animal]** 时，你可以把一个 **Container[Dog]** 传给它。因为类型是协变的，所以它是灵活的，允许在这个方向上变化（即，允许接受一个子类型）：
```scala
    class Container[+A](a: A):
        def get: A = a
```

然后我创建了一个 **Dog** 的实例以及一个 **Container[Dog]** ，然后验证 **Container** 中的 **get** 方法是否如愿以偿：
```scala
    val d = Dog("Fido")
    val h = Container[Dog](d)
    h.get   // Dog(Fido)
```

为了完成这个例子，我定义了一个方法，它接受一个 **Container[Animal]** 参数：
```scala
    def printName(c: Container[Animal]) = println(c.get.name)
```

最后，我向该方法传递了一个 **Container[Dog]** 变量，该方法如愿以偿：
```scala
    printName(h)   // "Fido"
```

简而言之，所有这些代码都是有效的，因为所有东西都是不可变的，我用泛型参数 **+A** 定义了 **Container**。

请注意，如果我把该参数只定义为 **A** 或定义为 **-A** ，该代码就无法编译。(关于这方面的更多信息，请继续阅读)。

**2. 形变与类型的“输入”和“输出”的位置有关。**    还有第二种方法来简化形变的概念，我将其总结为以下三段话：

正如你刚才看到的，**Container** 类中的 **get** 方法只使用 **A** 类型作为其返回类型。这并不是巧合：只要你把一个参数声明为 **+A** ，它就永远只能作为 **Container** 方法的返回类型。你可以认为这是一个 *输出（out）* 位置，可以说你的容器是一个 *生产者*：像 **get** 这样的方法会产生 **A** 类型值。除了刚才展示的 **Container[+A]** 类，其他生产者的例子是Scala的 **List[+A]** 和 **Vector[+A]** 类。对于这些类，一旦它们的实例被创建，你就不能再向它们添加更多的 **A** 值。相反，它们是不可变的和只读的，你只能通过内置的方法访问它们的 **A** 值。你可以把 **List** 和 **Vector** 看作是 **A** 类型元素（以及 **A** 的派生）的生产者。

相反，如果你指定的泛型类型参数只用作容器中的方法的输入参数，那么就用 **-A** 声明该参数是 *逆变（contravariant）* 的。这个声明告诉编译器，**A** 类型的值将只被传递到消费者（consumer）的方法中 —— “输入”的位置 —— 并且它们永远不会被当作返回值。因此，你的容器被说成是一个 *消费者* 。(请注意，与其他两种可能性相比，这种情况很罕见，但在生产者/消费者的讨论中，最容易提到它。）

最后，如果泛型参数既被用于方法的返回类型位置，又被用作容器内的方法参数，那么通过用符号 **A** 来声明该类型是 *不变的（invariant）*。当你使用这种类型来声明类的泛型参数时，类既是 **A** 类型的生产者也是消费者，作为这种灵活性的副作用，该类型是不变的（invariant） —— 这意味着它不能变化。当一个方法被声明为接受 **Container[Dog]** 时，它只能接受一个 **Container[Dog]** 。这种类型在定义可变容器时使用，比如 **ArrayBuffer[A]** 类，你可以在其中添加新元素、编辑元素和访问元素。

下面是这三种生产者/消费者情况的例子。

在第一种情况下，当泛型只被用作方法的返回类型时，容器是生产者，你用 **+A** 标记该类型为协变：
```scala
    // 协变: A只在“输出”的位置使用。
    trait Producer[+A]:
        def get: A
```

请注意，对于这个用例，C#和Kotlin语言 —— 它们也使用声明端形变 —— 在定义 **A** 时使用了关键字 **out**。如果Scala使用 **out** 而不是 **+**，代码会是这样的：
```scala
    trait Producer[out A]:   // if Scala used 'out' instead
        def get: A
```

对于第二种情况，如果泛型参数只被用作容器方法的输入参数，那么可以把容器看作是一个 *消费者*。使用 **-A** 将泛型标记为逆变：
```scala
    // 逆变: A只在“输入”的位置使用。
    trait Consumer[-A]:
        def consume(a: A): Unit
```

在这种时候，C#和Kotlin使用关键字 **in** 来表示 **A** 只作为方法的输入参数（“输入”的位置）。如果Scala有这个关键字，你的代码会是这样的：
```scala
    trait Consumer[in A]:   // if Scala used 'in' instead
        def consume(a: A): Unit
```

最后，当一个泛型类型参数既被用作方法的输入参数又被用作方法的返回参数时，它被认为是不变的 —— 不允许变化，并被设计为 **A**：
```scala
    // 不变: A用于“输入”和“输出”的位置
    trait ProducerConsumer[A]:
        def consume(a: A): Unit
        def produce(): A
```

### 一种记住形变符号的方法 -- TODO 耗子栏

&nbsp;&nbsp;&nbsp;&nbsp;虽然我一般喜欢用关键字 **out** 和 **in** 来声明泛型参数的变化 —— 至少在简单的、单参数的声明中，我发现这样可以记住Scala的符号：
- **+** 表示允许在正（子类型）方向上有变化。
- **-** 表示允许在负数（超类型）方向上有变化。
- 没有附加符号意味着不允许有变化。

表23-2提供了这些术语的摘要，包括Scala标准库中的每个例子。

*表23-2. Scala类型变化（形变）的描述和例子*

| Variance      | Symbol | In or Out | Producer/Consumer | Examples                                           |
|---------------|--------|-----------|-------------------|----------------------------------------------------|
| Covariant     | +A     | Out       | Producer          | **List[+A]**、**Vector[+A]**                        |
| Contravariant | -A     | In        | Consumer          | **Function1[-T1,+R]** 中的 **T1** 参数                 |
| Invariant     | A      | Both      | Both              | **Array[A]**、**ArrayBuffer[A]**、**mutable.Set[A]** |

实际上很难找到这些形变术语的一致定义，但微软的这个“通用术语中的协变和逆变”页面（ *https://oreil.ly/uZj51* ）提供了很好的定义，我在这里稍作重新表述：

*协变（Scala中的+A）* <br/>
让你使用一个比指定类型更“派生”的类型。这意味着你可以在声明了一个父类型的地方使用一个子类型。在我的例子中，这意味着你可以在声明了 **Container[Animal]** 方法参数的地方传递一个 **Container[Dog]**。

*逆变（-A）* <br/>
本质上与协变相反，你可以使用一个比指定的类型更通用（更少的派生）的类型。例如，你可以在指定使用 **Container[Dog]** 的地方使用 **Container[Animal]**。

*不变（A）* <br/>
这意味着类型不能变化 —— 你只能使用指定的类型。如果一个方法需要一个 **Container[Dog]** 类型的参数，你只能给它一个 **Container[Dog]**；如果你试图给它一个 **Container[Animal]**，它将编译失败。

### 用implicitly测试形变

正如Stack Overflow的这篇帖子（ *https://oreil.ly/lYWr4* ）以及John De Goes和Adam Fraser（Ziverge）的 *Zionomicon* 一书中所展示的那样，你可以使用 **implicitly** 方法 —— 它被定义在 **Predef** 对象（ Scaladoc *https://oreil.ly/FB6Zw* ）中，你所的有代码都可访问它 —— 以此来测试形变的定义。

例如，使用我最初的形变例子中的这段代码：
```scala
    sealed trait Animal:
        def name: String
    case class Dog(name: String) extends Animal
    class Container[+A](a: A):
        def get: A = a
```

这些REPL例子表明，通过使用 **implicitly**，Scala编译器确认了 **Container[Dog]** 是 **Container[Animal]** 的一个子类型：
```scala
    scala> implicitly[Dog <:< Animal]
    val res0: Dog <:< Animal = generalized constraint
    
    scala> implicitly[Container[Dog] <:< Container[Animal]]
    val res1: Container[Dog] <:< Container[Animal] = generalized constraint
```

如你所见，这些例子均是有效的，因为代码的编译通过了。相反，如果你用 **-A** 或 **A** 来定义 **Container**，就像在这个例子中：
```scala
    class Container[A](a: A):
        def get: A = a
```

**implicitly** 相关代码将无法编译：
```scala
    scala> implicitly[Container[Dog] <:< Container[Animal]] 
    1 |implicitly[Container[Dog] <:< Container[Animal]]
      |                                                ^
      |                   Cannot prove that Container[Dog] <:< Container[Animal].
```

这变成了一个很好的技巧/技术，你可以用来测试与形变有关的代码。

请注意，在这个例子中，表达式 **A <:< B** 意味着在处理隐式参数时，**A** 必须是 **B** 的子类型。这个 *类型关系（type relation）* 符号在本书中没有讨论，但请看Twitter的Scala School关于高级类型的页面（ *https://oreil.ly/ply5e* ），以了解关于在什么时候（什么地方）需要它的好例子。

### 很少使用逆变

为了保持一致，我在前面的讨论中第二次提到了逆变，但在实际中，逆变类型很少被使用。例如，Scala **Function1** 类（ *https://oreil.ly/xI64U* ）是标准库中少数几个声明泛型参数为逆变的类之一，如本例中的 **T1** 参数：
```scala
    Function1[-T1, +R]
```

因为不经常使用，所以本书没有涉及逆变，但在免费的 *Scala 3 Book* 的“Variance”部分有一个很好的例子（ *https://oreil.ly/jCrB7* ）。

### 具有形变的多个泛型类型参数 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;从 **Function1** 的例子中还可以注意到，一个类可以接受多个用形变声明的泛型参数。**-T1** 是一个只在 **Function1** 类中消耗的参数，而 **+R** 是一个只在 **Function1** 中产生的类型。

鉴于所有这些背景信息，在23.3和23.4小节中展示了常见的形变问题的两种解决方案。

## 类型约束

除了边界和形变之外，Scala还允许你指定额外的类型约束。这些都是用这些符号写的：
```scala
    A =:= B   // A必须与B相等
    A <:< B   // A必须是B的子类型
```

这些符号在本书中没有涉及。详情和例子见 *Programming in Scala*。在Twitter的Scala School的高级类型页面（ *https://oreil.ly/ply5e* ）也展示了使用它们的简要例子，其中它们被称为 *类型关系运算符（type relation operators）*。
 
### 其他几个类型的例子 -- TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;在第一版Scala Cookbook中，我写了关于如何创建一个计时器以及如何创建自己的 **Try** 类（ *https://oreil.ly/QRdZr* ）。(我把它摘录在我的网站上）。那段代码大量使用了类型，它在Scala 3仍然适用。

## 23.1 创建一个接受简单泛型类型参数的方法

### 问题

你不关心类型的差异，同时想创建一个接受泛型类型参数的方法（或函数），比如一个接受 **Seq[A]** 参数的方法。

### 解决方案

在括号中指定泛型参数，如 **[A]**。例如，当创建一个抽奖式的应用程序，从一个名字列表中抽出一个随机的名字时，你可能会遵循“尽可能做最简单的工作”的信条，最初创建一个没有使用泛型的方法：
```scala
    def randomName(names: Seq[String]): String =
        val randomNum = util.Random.nextInt(names.length)
        names(randomNum)
```

正如所写的那样，这对一个值为 **String** 的序列起作用：
```scala
    val names = Seq("Aleka", "Christina", "Emily", "Hannah")
    val winner = randomName(names)
```

然后在未来的某个时刻，你意识到你真的需要使用一个通用用途的方法，以从任何类型的序列中返回一个随机元素。所以，你修改了这个方法，像这样下面这样使用一个泛型类型参数：
```scala
    def randomElement[A](seq: Seq[A]): A =
        val randomNum = util.Random.nextInt(seq.length)
        seq(randomNum)
```

有了这个变化，现在你可以用不可变序列中的各种类型调用该方法：
```scala
    randomElement(Seq("Emily", "Hannah", "Aleka", "Christina"))
    randomElement(List(1,2,3))
    randomElement(List(1.0,2.0,3.0))
    randomElement(Vector.range('a', 'z'))
```

### 讨论

这是一个相对简单的例子，它展示了如何将一个泛型集合传递给一个不会尝试修改集合的方法。关于你可能遇到的更复杂的情况，请参阅23.3和23.4小节。

## 23.2 创建一个使用简单的泛型类型的类

### 问题

你想创建一个使用简单泛型的类（和相关的方法）。

### 解决方案

作为一个类库的作者，你在声明类时要定义泛型类型参数。例如，这里有一个小型的链接列表（linked-list）类，它被写成可以向其添加新的元素。这样的链表是可变的，就像 **ArrayBuffer**：
```scala
    class LinkedList[A]:

        private class Node[A] (elem: A):
            var next: Node[A] = _
            override def toString = elem.toString

        private var head: Node[A] = _

        def add(elem: A): Unit =
            val n = new Node(elem)
            n.next = head
            head = n

        private def printNodes(n: Node[A]): Unit =
            if n != null then
                println(n)
                printNodes(n.next)

        def printAll() = printNodes(head)
```

请注意泛型类型参数 **A** 是如何出现在整个类定义中的。这个泛型类型参数是实际类型的占位符，比如 **Int** 和 **String**，你的类的用户可以指定这些类型。

例如，要用这个类创建一个整数列表，首先要创建一个实例，并声明它所包含的类型是 **Int** 类型：
```scala
    val ints = LinkedList[Int]()
```

然后用 **Int** 值来填充它：
```scala
    ints.add(1)
    ints.add(2)
```

因为该类使用了一个泛型类型参数，所以你也可以创建一个 **String** 类型的 **LinkedList**：
```scala
    val strings = LinkedList[String]()
    strings.add("Emily")
    strings.add("Hannah")
    strings.printAll()
```

或任何你想使用的其他类型：
```scala
    val doubles = LinkedList[Double]()
    doubles.add(1.1)
    doubles.add(2.2)
```

这展示了创建类时泛型类型参数的基本用法。

### 讨论

当你在定义一个类的时候使用一个简单的泛型参数如 **A**，你也可以在这个类的内部和外部定义方法，这些方法正是使用这个类型。为了解释这意味着什么，我们从这个类型的层次结构开始说明：
```scala
    trait Person { def name: String }
    class Employee(val name: String) extends Person
    class StoreEmployee(name: String) extends Employee(name)
```

当你为一家披萨连锁店的销售点应用程序建模时，你可能会使用这种类型层次结构，其中 **StoreEmployee** 是在一个商店地点工作的人。(你可能还有一个 **OfficeEmployee** 类型，用于在公司办公室工作的人。）

这种关系在图23-1的类图中得到了直观的表达。

![23-1](./images/ch23/Figure23-1.png)

*图23-1. 个人和雇员类的类图*

考虑到这个类型层次结构，你可以创建一个方法来打印一个 **LinkedList[Employee]**，就像下面这样：
```scala
    def printEmps(es: LinkedList[Employee]) = es.printAll()
```

现在你可以给 **printEmps**方法传递一个 **LinkedList[Employee]**，它将如愿以偿地工作：
```scala
    // works
    val emps = LinkedList[Employee]()
    emps.add(Employee("Al"))
    printEmps(emps)
```

到目前为止，情况还不错；这能如愿以偿地工作。

#### 这种方式的局限性

这种简单的方法不奏效的地方是，如果你试图给 **printEmps** 一个 **LinkList[StoreEmployee]()**：
```scala
    val storeEmps = LinkedList[StoreEmployee]()
    storeEmps.add(StoreEmployee("Fred"))
    // this line won’t compile
    printEmps(storeEmps)
```

这就是你试图写这段代码时得到的编译错误：
```scala
   printEmps(storeEmps)
             ^^^^^^^^^
             Found:    (storeEmps : LinkedList[StoreEmployee])
             Required: LinkedList[Employee]
```

最后一行无法编译，因为：
- **printEmps** 期望接受一个 **LinkedList[Employee]**参数。
- **storeEmps** 是一个 **LinkedList[StoreEmployee]**。
- 链接列表的元素是可变的。
- 如果编译器允许这样做，**printEmps** 可以在 **storeEmps** 中的 **StoreEmployee** 元素中添加普通的 **Employee** 元素。这是不被允许的。

正如在“形变”中所讨论的，这里的问题是，当一个泛型参数在像 **LinkedList** 这样的类中被声明为 **A** 时，该参数是不变的，这意味着 **A** 在像 **printEmps** 这样的方法中使用时，其类型不允许变化。在23.3小节中展示了这个问题的详细解决方案。

### 类型参数的符号

如果一个类需要一个以上的类型参数，请使用表23-3中的符号。例如，在关于泛型类型的官方Java文档（ *https://oreil.ly/J5QvL* ）中，Oracle展示了一个名为 **Pair** 的接口，它需要两种类型：
```java
    public interface Pair<K, V> {
        public K getKey();
        public V getValue();
    }
```

你可以将该接口移植到Scala，并使用Scala特质实现它，具体方法如下：
```scala
    trait Pair[K, V]:
        def getKey: K
        def getValue: V
```

如果你要进一步实现 **Pair** 类（或特质）的主体，类型参数 **K** 和 **V** 将分布在你的类中，就像 **LinkedList** 例子中使用的符号 **A**一样。

### 泛型符号标准 --TODO 鸽子栏

&nbsp;&nbsp;&nbsp;&nbsp;我一般喜欢在类的前两个泛型类型参数声明中使用符号 **A** 和 **B** ，但在这种时候 —— 比如在 **Map** 类中，我更喜欢 **K** 和 **V**，因为类型明显指的是 *键* 和 *值*。

上述文档还列出了Java类型参数的命名方式。这些在Scala中也是类似的，只是Java在命名简单的类型参数时先用字母 **T**，然后用 **U** 和 **V** 来命名后续类型。Scala的标准是，第一个类型应该被声明为 **A**，接下来是 **B**，以此类推，如表23-3所示。

*表23-3. Scala中泛型类型参数的标准符号*

| Symbol | Description                                                                                             |
|--------|---------------------------------------------------------------------------------------------------------|
| A      | 指的是一个简单的类型，例如List[A]。                                                                                   |
| B、C、D  | 用于第二、第三、第四个类型等。例如：<br/>class List[A]: <br/>&nbsp;&nbsp;&nbsp;&nbsp;def map[B](f: A => B): List[B] = ??? |
| K      | 通常是指Java map中的一个键。(这种时候，我也更喜欢K）。                                                                        |
| N      | 指的是一个数字值。                                                                                               |
| V      | 通常是指Java map中的一个值。(这种时候，我也更喜欢V）。                                                                        |

### 另见

- Oracle关于泛型类型的Java文档（ *https://oreil.ly/J5QvL* ）。

## 23.3 将不可变的泛型参数改为协变

### 问题

你想创建一个类，其泛型参数不能被改变（它们是immutable的），并想了解如何指定泛型参数。

### 解决方案

想要声明泛型类型参数的元素不能被修改，可以用前面的 **+** 符号定义它们，如 **+A**，从而声明它们是 *协变* 的。作为一个例子，像 **List**、**Vector** 和 **Seq** 这样的不可变的集合类都被定义为使用协变的泛型类型参数：
```scala
    class List[+T]
    class Vector[+A]
    trait Seq[+A]
```

通过使类型参数成为协变的，泛型参数不能被改变，但好处是以后可以以更灵活的方式使用该类。

为了证明这一点的用处，请稍微修改一下前面小节中的例子。首先，定义类的层次结构：
```scala
    trait Animal:
        def speak(): Unit

    class Dog(var name: String) extends Animal:
        def speak() = println("Dog says woof")

    class SuperDog(name: String) extends Dog(name):
        override def speak() = println("I’m a SuperDog")
```

接下来，定义一个 **makeDogsSpeak** 方法，但不是像前面的示例那样接受一个 _可变的_ **ArrayBuffer[Dog]**，而是接受一个 *不可变的* **Seq[Dog]**：
```scala
    def makeDogsSpeak(dogs: Seq[Dog]): Unit = dogs.foreach(_.speak())
```

就像前面示例中的 **ArrayBuffer** 一样，你可以毫无问题地将 **Seq[Dog]** 传入 **makeDogsSpeak**：
```scala
    // 这样做是可行的
    val dogs = Seq(Dog("Nansen"), Dog("Joshu"))
    makeDogsSpeak(dogs)
```

然而，在这种时候，你也可以成功地将一个 **Seq[SuperDog]** 传入 **makeDogsSpeak** 方法：
```scala
   // 这样做也是可行的
    val superDogs = Seq(
        SuperDog("Wonder Dog"),
        SuperDog("Scooby")
    )
    makeDogsSpeak(superDogs)
```

因为 **Seq** 是不可变的，并且 **Seq[+A]** 拥有协变的泛型类型参数 **+A**，所以 **makeDogsSpeak** 可以同时接受 **Seq[Dog]** 和 **Seq[SuperDog]**，而没有23.4小节那样的形式了冲突。

### 讨论

你可以通过创建一个带有协变的泛型参数的自定义类来进一步证明这一点。要做到这一点 —— 为了保持简单 —— 创建一个可以容纳一个元素的集合类。因为你不希望集合元素被修改，所以将参数定义为一个 **val**，并用 **+A** 使其成为协变的：
```scala
    class Container[+A] (val elem: A)
                   ----
```

使用与解决方案中相同的类型层次结构，修改 **makeDogsSpeak** 方法，以接受一个 **Container[Dog]**：
```scala
    def makeDogsSpeak(dogHouse: Container[Dog]): Unit = dogHouse.elem.speak()
```

有了这个设置，你就可以把一个 **Container[Dog]** 传入 **makeDogsSpeak**：
```scala
    val dogHouse = Container(Dog("Xena"))
    makeDogsSpeak(dogHouse)
```

最后，因为你用“+”符号声明该元素是协变的，所以你也可以将一个 **Container[SuperDog]** 传入 **makeDogsSpeak**：
```scala
    val superDogHouse = Container(SuperDog("Wonder Dog"))
    makeDogsSpeak(superDogHouse)
```

因为 **Container** 的元素是不可变的，而且它的泛型类型参数被标记为协变的，因此所有这些代码都能成功运行。注意，如果你把 **Container** 的类型参数从 **+A** 改为 **A**，最后一行代码就不能编译了。

正如在“形变”中所讨论的以及在这些例子中所展示的，用一个不可变的泛型类型参数来定义一个容器类型类，使得集合在整个代码中更加灵活和有用。如本例所示，你可以将一个 **Container[SuperDog]** 传递给一个期望接收 **Container[Dog]** 的方法。

### +A指的是“输出”的位置 -- TODO 鸽子栏

上面开头“形变”一小节还指出，**+A** 符号是你告诉编译器泛型参数 **A** 将只作为这个类中方法的返回类型（即“输出”位置）的方式。例如，在这个例子中，这段代码是有效的：
```scala
    class Container[+A] (val elem: A):
        // 使用正确，'A'在“输出”的位置上
        def getElemAsTuple: (A) = (elem)
```

但是任何试图在类中使用 **A** 类型的元素作为方法输入参数的尝试都会因为这个错误而失败：
```scala
    class Container[+A] (val elem: A):
        def foo(a: A) = ???
                ^^^^
    error: covariant type A occurs in contravariant position
    in type A of parameter a
```

正如那段代码所示，尽管我甚至没有尝试实现 **foo** 方法的主体，但编译器指出 **A** 类型不能用在“输入”的位置。

## 23.4 创建一个元素类型可以变化的类

### 问题

你想创建一个类似于集合的类，其元素可以被改变，并想知道如何为其元素指定泛型类型参数。

### 解决方案

当定义一个可以改变（mutated）的参数时，它的泛型类型参数应该被声明为不变的 **[A]**。因此，本小节与23.2小节中的例子类似。

一个例子是，Scala **Array** 或 **ArrayBuffer** 中的元素可以被修改，这样声明其签名：
```scala
    class Array[A] ...
    class ArrayBuffer[A] ...
```

### 讨论

将一个类型声明为不变主要有两个影响：
- 容器可以容纳指定的类型，以及该类型的子类型。
- 后来对方法如何使用容器有了限制。

为了创造一个关于第一点的例子，下面的类层次结构指出，**Dog** 和 **SuperDog** 类都扩展了 **Animal**特质：
```scala
    trait Animal:
        def speak(): Unit

    class Dog(var name: String) extends Animal:
        def speak() = println("woof")
        override def toString = name

    class SuperDog(name: String) extends Dog(name):
        def useSuperPower() = println("Using my superpower!")
```

考虑到这些类，你可以创建一只 **Dog** 和一只 **SuperDog**：
```scala
    val fido = Dog("Fido")
    val wonderDog = SuperDog("Wonder Dog")
```

当你以后声明一个 **ArrayBuffer[Dog]** 时，你可以把 **Dog** 和 **SuperDog** 的实例都添加到其中：
```scala
    import collection.mutable.ArrayBuffer

    val dogs = ArrayBuffer[Dog]()
    dogs += fido
    dogs += wonderDog
```

所以一个有不变类型参数的集合可以包含（a）基本类型的元素和（b）基本类型的子类型。

声明不变类型的第二个效果是，对该类型以后的使用方式有限制。给出同样的代码，你可以定义一个接受 **ArrayBuffer[Dog]** 的方法，然后让每个 **Dog** 说话。
```scala
    import collection.mutable.ArrayBuffer
    def makeDogsSpeak(dogs: ArrayBuffer[Dog]) =
        dogs.foreach(_.speak())
```

当你传递给它一个 **ArrayBuffer[Dog]** 时，这个工作很好：
```scala
    val dogs = ArrayBuffer[Dog]()
    dogs += fido
    makeDogsSpeak(dogs)
```

然而，如果你试图传递给它一个 **ArrayBuffer[SuperDog]**，**makeDogsSpeak** 的调用就会编译失败：
```scala
    val superDogs = ArrayBuffer[SuperDog]()
    superDogs += wonderDog
    makeDogsSpeak(superDogs)  // ERROR: won't compile
```

由于这种情况下形式的冲突，这段代码不会被编译：
- **ArrayBuffer** 中的元素可以被修改。
- **makeDogsSpeak** 被定义为接受一个 **ArrayBuffer[Dog]** 类型的参数。
- 你试图传入 **superDogs**，其类型是 **ArrayBuffer[SuperDog]**。
- 如果编译器允许，**makeDogsSpeak** 可以用普通的 **Dog** 元素替换 **superDogs** 中的 **SuperDog** 元素。显然，这是不被允许的。

### 另见

## 23.5 创建一个参数实现了基类型的类

## 23.6 使用Duck类型（结构化类型）

## 23.7 使用不透明类型创建有意义的类型名称

## 23.8 使用given和using的术语推断

## 23.9 使用联合类型模拟动态类型

## 23.10 声明一个值是多种类型的组合

## 23.11 控制类如何使用多元等价进行比较

## 23.12 使用CanEqual类型类限制等价比较


