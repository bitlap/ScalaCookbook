# 23. 类型

看一眼集合类的Scaladoc就能知道，Scala有一个强大的类型系统。然而，除非你是一个类库的创建者，否则你可以在Scala中走很长的路，而不必深入地去了解Scala类型的深处。但是一旦你开始为其他用户创建类库，你就需要学习它们。

本章为你会遇到的最常见的类型相关问题提供了示例，但当你需要深入了解时，我强烈推荐 *Programming in Scala*（Artima）这本书。这本书的作者之一 Martin Odersky 是Scala编程语言的创建者，我认为这本书是Scala的“参考指南”。

Scala的类型系统使用一组符号（symbols）来表达不同的泛型（generic）类型概念，包括 *边界（bounds）*、*形变（variance）* 和 *约束（constraints）* 等概念。在进入本章正文之前，我在下面几个小节总结了最常见的这些符号。

### 关于编程水平和类型的说明 -- TODO 鸽子栏

早在2011年1月，Martin Odersky就定义了不同类型的Scala程序员需要的六个知识层次（ *https://oreil.ly/FGTc2* ）。他将A1-A3级别用于应用程序员，L1-L3级别用于类库设计者。本章所展示的类型相关技术与他的L1至L3级别相对应。

## 泛型类型参数

当你刚开始写Scala代码时，你会使用 **Int**、**String**等类型，以及你创建的自定义类型，如**Person**、**Employee** 和 **Pizza**。然后，你会创建特质、类和使用这些类型的方法。下面是一个使用 **Int** 类型以及 **Seq[Int]** 的例子：
```scala
    // 忽略可能发生的错误
    def first(xs: Seq[Int]): Int = xs(0)
```

**Seq[Int]** 是一种容器类型，它可以作为另一种类型的容器。同样地，**List[String]** 和 **Option[Int]** 也是容器类型。

随着你在处理类型方面的经验越来越丰富，当你看 **first** 方法时，你会发现它的返回类型与 **Seq** 容器中的内容完全没有关系。**Seq** 可以包含 **Int**、**String**、**Fish**、**Bird** 等类型，而方法的主体不会改变。因此，你可以用一个泛型类型重写这个方法，就像这样：
```scala
    def first[A](xs: Seq[A]): A = xs(0) 
             ___         _    _
```

代码中的下划线部分显示了如何指定一个泛型类型。在代码中从右向左阅读：
- 如前所述，方法主体中没有引用该类型；只有 **xs(0)**。
- **A** 被用作方法的返回类型，而不是 **Int**。
- 在 **Seq** 中使用了 **A**，而不是 **Int** 。
- 在方法声明之前的括号中指定了 **A**。

关于最后一点，在方法签名前的括号中指定泛型类型，是告诉编译器和代码的读者，泛型类型可以用在（a）方法签名，（b）返回类型，或（c）方法主体，或这三个地方的任何组合。

这样编写泛型代码能使你的代码对更多的人有用。这个方法不再仅仅适用于 **Seq[Int]**，而是适用于 **Seq[Fish]**、**Seq[Bird]**，以及一般来说 —— 也就是 *generic* 这个词 —— 任何类型的 **Seq**。

按照惯例，当你在Scala中声明泛型时，第一个被指定的泛型使用字母 **A**，第二个泛型是 **B**，以此类推。例如，如果Scala不包括元祖，而你想声明一个自己的元祖类，以包含两种不同的类型，此时可以这样声明它：
```scala
    class Pair[A,B](val a: A, val b: B)
```

这里有几个例子说明如何使用该类：
```scala
    Pair(1, 2)        // A and B are both Int
    Pair(1, "1")      // A is Int, B is String
    Pair("1", 2.2)    // A is String, B is Double
```

在第一个例子中，**A**和 **B** 刚好有相同的类型，而在后两个例子中，**A** 和 **B** 是不同的类型。

最后，为了完善我们的第一个泛型例子，让我们创建一个使用泛型参数的特质，然后创建一个实现该特质的类。首先，让我们创建两个简单的类，这个例子将需要这些简单的类，还有我们之前的 **Pair** 类：
```scala
    class Cat
    class Dog
    class Pair[A,B](val a: A, val b: B)
```

在这个的背景下，你可以使用两个泛型类型参数来创建参数化特质：
```scala
    trait Foo[A,B]:
        def pair(): Pair[A, B]
```

请注意，你在特质名称后面声明了你需要的类型，然后在特质中引用了这些类型。

接下来，这是一个为狗和猫实现特质的类：
```scala
    class Bar extends Foo[Cat, Dog]:
        def pair(): Pair[Cat, Dog] = Pair(Cat(), Dog())
```

这第一行代码声明 **Bar** 适用于 **Cat** 和 **Dog** 类型，**Cat** 是 **A** 的特定替换，**Dog** 是 **B** 的替换：
```scala
    class Bar extends Foo[Cat, Dog]:
```

如果你想创建另一个继承 **Foo** 的类，并对 **String** 和 **Int** 进行操作。你可以这样写：
```scala
    class Baz extends Foo[String, Int]:
        def pair(): Pair[String, Int] = Pair("1", 2)
```

这些例子展示了在不同情况下如何使用泛型类型参数。

随着你更多地使用泛型类型，你会发现，你想对这些类型定义某些期望和限制。为了处理这些情况，你将使用边界、形变和类型约束，这些将在接下来讨论。

## 边界

边界让你能对类型参数进行限制。例如，想象一下，你想写一个方法来返回一个类型的 **name** 字段的大写版本：
```scala
    // 这段代码无法编译
    def upperName[A](a: A) = a.name.toUpperCase
```

这段代码与你想要的差不多，但它不会工作，因为不能保证类型 **A** 有一个 **name** 字段。作为这个问题的解决方案，如果你有一个像 **SentientBeing** 这样的类型，它声明了一个 **name** 字段：
```scala
    trait SentientBeing:
        def name: String
```

你可以通过使用一个边界来正确实现 **upperName** 方法，如下面的代码所示：
```scala
    def upperName[A <: SentientBeing](a: A) = a.name.toUpperCase
                  ------------------
```

这告诉编译器，无论 **A** 类型是什么，它必须是 **SentientBeing** 的一个子类，它被保证有一个 **name** 字段。因此，如果你有这样的类，它们是 **SentientBeing** 的子类：
```scala
    case class Dog(name: String) extends SentientBeing
    case class Person(name: String, age: Int) extends SentientBeing
    case class Snake(name: String) extends SentientBeing
```

**upperName** 方法在所有这些情况下都能如愿以偿地工作：
```scala
    upperName(Dog("rover"))       // "ROVER"
    upperName(Person("joe", 25))  // "JOE"
    upperName(Snake("Noodles"))   // "NOODLES"
```

这就是使用边界工作的本质。它们给你提供了一种方法来定义限制 —— 边界，或者说是泛型类型的可能性的边界。表23-1提供了常见边界符号的描述。

*表23-1. Scala的边界符号的描述*

|               | Bound     | Description          |
|---------------|-----------|----------------------|
| A <: B        | 上界        | A必须是B的一个子类型，见23.5小节。 |
| A >: B        | 下界        | A必须是B的一个超类型（父类型）。    |
| A <: 上界 >: 下界 | 下界和上界一起使用 | 类型A既有上界又有下界。         |

下界在集合类的一些方法中有示范。要找到它们的例子，可以在 **List**（ *https://oreil.ly/Q5pMd* ）等类的Scaladoc中搜索 **>:** 符号。

## 形变

顾名思义，形变是一个概念，它与泛型类型参数在创建类型的子类时如何变化有关。Scala使用了所谓的 *声明端形变*，这意味着 —— 你作为库的创建者 —— 在创建新类型时，在泛型类型参数上声明了形变注释，例如特质和类。(这与Java相反，Java使用的是 *使用端形变*，这意味着库的使用者要负责理解这些注释）。

我发现，在创建的新类型像这样我们一直使用的 **List** 和 **ArrayBuffer** 的集合时，最容易展示形变。所以作为一个例子，我将创建一个名为 **Container** 的新类型，它包含一个元素。当我定义 **Container** 时，形变与我是否将其泛型类型参数 **A** 定义为 **A**、**+A** 或 **-A** 有关。
```scala
    class Container[A](a: A) ...  // invariant
    class Container[+A](a: A) ... // covariant
    class Container[-A](a: A) ... // contravariant
```

我 *现在* 如何声明 **A** 会影响到 *以后* 如何使用 **Container** 实例。例如，在这样的讨论中，形变会发挥作用：
    
    当我使用这些注释之一定义一个新的Container类型时，如果我还定义了一个Dog类，它是Animal的一个子类型，那么Container[Dog]是Container[Animal]的一个子类型吗？


具体来说，这意味着如果你有这样一个方法，它被定义为接受 **Container[Animal]** 类型的参数：
```scala
    def foo(c: Container[Animal]) = ???
```

你能把一个 **Container[Dog]** 传给 **foo** 吗？

### 简化形变的两种方法

形变的解释可能需要几个步骤，因为你必须同时谈论（a）泛型参数最初是如何声明的，以及（b）你的container的实例后来是如何使用的，但我发现有两种方法可以简化这个话题。

**1. 如果所有东西都是不可变的。** 简化形变的第一个方法是，如果Scala中的所有东西都是不可变的，那么就没有必要进行形变了。具体来说，在一个完全不可变的世界里，所有的字段都是 **val**，所有的集合都是不可变的（比如 **List** ），如果 **Dog** 是 **Animal** 的子类，**Container[Dog]** 肯定是 **Container[Animal]** 的子类。

### 在一个不可改变的世界中，不需要形变 -- TODO 鸽子栏

在下面的讨论中，在一个完全不可改变的世界中，对形变的需求就消失了。


这在下面的代码中得到了证明。首先，我创建了一个 **Animal** 特质，然后创建了一个继承自动物的 **Dog** 样例类：
```scala
    sealed trait Animal:
        def name: String
    case class Dog(name: String) extends Animal
```

现在我定义了我的 **Container** 类，将其泛型类型参数声明为 **+A**，使其成为 *协变* 的。虽然这是一个花哨的数学术语，但它只是意味着当一个方法被声明为接受一个 **Container[Animal]** 时，你可以把一个 **Container[Dog]** 传给它。因为类型是协变的，所以它是灵活的，允许在这个方向上变化（即，允许接受一个子类型）：
```scala
    class Container[+A](a: A):
        def get: A = a
```

然后我创建了一个 **Dog** 的实例以及一个 **Container[Dog]** ，然后验证 **Container** 中的 **get** 方法是否如愿以偿：
```scala
    val d = Dog("Fido")
    val h = Container[Dog](d)
    h.get   // Dog(Fido)
```

为了完成这个例子，我定义了一个方法，它接受一个 **Container[Animal]** 参数：
```scala
    def printName(c: Container[Animal]) = println(c.get.name)
```

最后，我向该方法传递了一个 **Container[Dog]** 变量，该方法如愿以偿：
```scala
    printName(h)   // "Fido"
```

简而言之，所有这些代码都是有效的，因为所有东西都是不可变的，我用泛型参数 **+A** 定义了 **Container**。

请注意，如果我把该参数只定义为 **A** 或定义为 **-A** ，该代码就不会被编译。(关于这方面的更多信息，请继续阅读)。

## 类型约束
