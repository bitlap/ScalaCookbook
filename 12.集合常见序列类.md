# 12 集合：常见序列类

在本章中，我们会研究最常见的序列类。 正如11.1节“选择集合类”中提到的，序列类的使用建议如下：

- **Vector**是首选的不可变索引序列。
- **List**是首选的不可变线性序列。
- **ArrayBuffer**是首选的可变索引序列。
- **ListBuffer**是首选的可变线性序列。

# Vector

正如11.1 节“选择集合类”中所讨论，**Vector**是首选的不可变索引序列类，因为它具有通用的性能特征。 需要不可变序列时使用它。

因为 **Vector** 是不可变的，所以可以通过过滤和转换方法创建另一个**Vector**。 快速浏览下面创建和使用 **Vector**的例子：

```scala
    val a = Vector(1, 2, 3, 4, 5)
    val b = a.filter(_ > 2) // Vector(3, 4, 5)
    val c = a.map(_ * 10) // Vector(10, 20, 30, 40, 50)
```



# List

如果你从Java来到Scala，很快会发现尽管名字相同，但Scala **List**与 Java **List** （例如 Java **ArrayList**）完全不同。Scala **List**类是不可变的，大小和包含的元素都不能改变。它基于链表实现，首选的方法是*prepend*元素。由于是链表，所以遍历需要从头到尾，实际上，通常认为它由**head**，**tail** 方法(以及**isEmpty**)组成。

与 **Vector**类似，由于 **List** 是不可变的，所以可以通过过滤和转换方法创建另一个**List**，快速浏览下面创建和使用 **List**的例子：

```scala
    val a = List(1, 2, 3, 4, 5)
    val b = a.filter(_ > 2) // List(3, 4, 5)
    val c = a.map(_ * 10) // List(10, 20, 30, 40, 50)
```

> List和Vector
>
> 你可能想知道何时使用**List**而不是**Vector**。11.2小节“理解集合的性能”中详细介绍了性能特征，提供了选择的通用规则。
>
> 在一个有趣的实验中，Scala语言的创建者Martin Odersky，在Scala贡献者网站上的这个帖子中指出，Tiark Rompf曾经试图用Vector替换Scala编译器中的所有List，结果性能下降了10%。所以认为**Vector**有一定的开销，导致在处理小序列时效率较低。
>
> 所以 **List** 有其用处，尤其是当你把它想象成它是一个简单的单链表时。 （在Martin Odersky 先生的评论中，Java Champion， Scala **Future**的创造者Viktor Klang—认为**List**是一个优秀的栈。）

# ArrayBuffer

**ArrayBuffer** 是首选的可变索引序列类。 因为是可变的，可以通过转换方法来修改内容。 例如，将**map**方法与**Vector**或**List**一起使用，并将结果赋给一个新变量：

```scala
    val x = Vector(1, 2, 3)
    val y = x.map(_ * 2) // y: ArrayBuffer(2, 4, 6)
```

对于**ArrayBuffer**，使用**mapInPlace**而不是**map**方法，会原地修改值：

```scala
    import collection.mutable.ArrayBuffer
    val ab = ArrayBuffer(1, 2, 3)
    ab.mapInPlace(_ * 2) // ab: ArrayBuffer(2, 4, 6)
```

> **Buffers**
>
> 在Scala中，*Buffer*只是一个可以增长和收缩的序列。

# Array

Scala **Array**很独特：它的元素可以变，但是大小是不可变—不能增加或减少。相比之下，**List**和**Vector**是完全不可变的，而**ArrayBuffer**是完全可变的。

数组的独特之处在于它是基于Java数组，所以Scala数组**[Int]**是基于Java **Int[]**的。

虽然**Array**经常展示在Scala例子中，但建议将**Vector**类作为首选的不可变索引序列类，**ArrayBuffer**作为首选的可变索引序列。基于这个建议，我的实际代码中使用**Vector**和**ArrayBuffer**，在需要时转换为**Array**。

对于一些操作，**Array**比其他集合有更好的性能，所以了解它的工作原理是很重要的。详情参考11.2节，“理解集合的性能”。



# 12.1 Vector作为首选的不可变序列

## 问题

在Scala应用中想要一个快速的，通用的，不可变的序列集合类型。

## 解决方案

**Vector**类是首选的通用索引不可变的顺序集合。 如果更需要线性不可变顺序集合，可以使用**List**。

### 创建Vectors

和其它不可变序列一样创建和使用 **Vector**。 可以通过初始元素创建一个 **Vector**，然后通过索引访问元素：

```scala
    val v = Vector("a", "b", "c")
    v(0) // "a"
    v(1) // "b"
```

因为**Vector**有索引，所以调用**x(9_999_999)**几乎立即返回：

```scala
    val x = (1 to 10_000_000).toVector
    x(9_999_999) // 10000000
```

还可以创建一个空的**Vector**，并向其添加元素，记住要将结果赋给一个新变量：

```scala
    val a = Vector[String]() // a: Vector[String] = Vector()
    val b = a ++ List("a", "b") // b: Vector(a, b)
```



### Add, Append和Prepend元素

由于不能修改向量，所以将结果指定给新变量时，可以向现有向量添加元素：

```scala
    val a = Vector(1, 2, 3)
    val b = a ++ List(4, 5) // b: Vector(1, 2, 3, 4, 5)
    val c = b ++ Seq(6) // c: Vector(1, 2, 3, 4, 5, 6)
```

和其他不可变序列一样，通过下面方法给Vector中append和prepend元素：

-  **+:**  方法，别名**prepended**。
- **++:** 方法，别名**prependedAll**。
- **:+** 方法，别名**appended**。
- **:++**方法，别名**appendedAll**。

下面是例子，将每个操作的结果赋值**var**变量：

```scala
// prepending
var a = Vector(6)

a = 5 +: a // a: Vector(5, 6)
a = a.prepended(4) // a: Vector(4, 5, 6)

a = List(2,3) ++: a // a: Vector(2, 3, 4, 5, 6)
a = a.prependedAll(Seq(0,1)) // a: Vector(0, 1, 2, 3, 4, 5, 6)

// appending
var b = Vector(1)

b = b :+ 2 // b: Vector(1, 2)
b = b.appended(3) // b: Vector(1, 2, 3)

b = b :++ List(4,5) // b: Vector(1, 2, 3, 4, 5)
b = b.appendedAll(List(6,7)) // b: Vector(1, 2, 3, 4, 5, 6, 7)
```



### 修改元素

要修改**Vector**中的元素，调用**update**方法时设置**index**和**elem**参数来替换元素，同时将结果赋给一个新变量：

```scala
    val a = Vector(1, 2, 3)
    val b = a.updated(index=0, elem=10) // b: Vector(10, 2, 3)
    val c = b.updated(1, 20) // c: Vector(10, 20, 3)
```

同样，使用 **patch** 方法一次替换多个元素：

```scala
    val a = Vector(1, 2, 3, 4, 5, 6)

    // specify (a) the index to start at, (b) the new sequence
    // you want, and (c) the number of elements to replace
    val b = a.patch(0, List(10,20), 2) // b: Vector(10, 20, 3, 4, 5, 6)
    val b = a.patch(0, List(10,20), 3) // b: Vector(10, 20, 4, 5, 6)
    val b = a.patch(0, List(10,20), 4) // b: Vector(10, 20, 5, 6)

    val b = a.patch(2, List(30,40), 2) // b: Vector(1, 2, 30, 40, 5, 6)
    val b = a.patch(2, List(30,40), 3) // b: Vector(1, 2, 30, 40, 6)
    val b = a.patch(2, List(30,40), 4) // b: Vector(1, 2, 30, 40)
```

使用**patch**，插入元素可以通过设置替换的元素数量为0：

```scala
    val a = Vector(10, 20, 30)
    val b = a.patch(1, List(15), 0) // b: Vector(10, 15, 20, 30)
    val b = a.patch(2, List(25), 0) // b: Vector(10, 20, 25, 30)
```



## 讨论

Scala 文档中关于不可变集合类的声明如下：

> **Vector**是种集合类型，可解决List随机访问低效的问题。 **Vector**可以在“有效”常数时间内访问列表中的任何元素……因为**Vector**在快速随机选择和快速随机函数更新之间取得了很好的平衡，是不可变索引序列的默认实现。

在“理解集合的层次”中所述，创建 **IndexedSeq** 的实例时，Scala 会返回**Vector**：

```scala
    scala> val x = IndexedSeq(1,2,3)
    x: IndexedSeq[Int] = Vector(1, 2, 3)
```

因此，我看到一些开发人员在创建索引不可变序列时，使用**IndexedSeq**而不是**Vector**，并将实现细节留给编译器。

# 12.2创建和填充List

## 问题

想要创建和填充列表。

## 解决方案

创建和初始填充 **List**方法有很多，下面有六个例子，从两个基本的用例开始：

```scala
    // (1) basic, general use cases
    val xs = List(1, 2, 3) // List(1, 2, 3)
    val xs = 1 :: 2 :: 3 :: Nil // List(1, 2, 3)
    val xs = 1 :: List(2, 3)

    // (2) both of these create an empty list
    val xs: List[String] = List()
    val xs: List[String] = Nil
```

接下来，这些例子展示了如何让编译器隐式设置**List**类型，然后显式控制类型：

```scala
    // (3a) implicit and explicit types, with mixed values
    val xs = List(1, 2.0, 33D, 4_000L) // implicit type (List[AnyVal])
    val xs: List[Double] = List(1, 2.0, 33D, 4_000L) // explicit type
    
    // (3b) another example of explicitly setting the list type,
    // where the second example declares the type to be List[Long]
    val xs = List(1, 2, 3) // List[Int] = List(1, 2, 3)
    val xs: List[Long] = List(1, 2, 3) // List[Long] = List(1, 2, 3)
```

下面例子展示了基于范围创建**List**的多种方法，包括Int和Char类型上的**to**和**by**方法（多亏了类型的隐式转换）：

```scala
    // (4) using ranges
    val xs = List.range(1, 10) // List(1, 2, 3, 4, 5, 6, 7, 8, 9)
    val xs = List.range(0, 10, 2) // List(0, 2, 4, 6, 8)

    (1 to 5).toList // List(1, 2, 3, 4, 5)
    (1 until 5).toList // List(1, 2, 3, 4)
    (1 to 10 by 2).toList // List(1, 3, 5, 7, 9)
    (1 to 10 by 3).toList // List(1, 4, 7, 10)

    ('a' to 'e').toList // List(a, b, c, d, e)
    ('a' to 'e' by 2).toList // List(a, c, e)
```

下面例子展示了填充**List**的多种方法：

```scala
    // (5) different ways to fill lists
    val xs = List.fill(3)("foo") // xs: List(foo, foo, foo)
    val xs = List.tabulate(5)(n => n * n) // xs: List(0, 1, 4, 9, 16)
    val xs = "hello".toList // xs: List[Char] = List(h,e,l,l,o)

    // create a list of alphanumeric characters
    val alphaNum = (('a' to 'z') ++ ('A' to 'Z') ++ ('0' to '9')).toList
    // result contains 52 letters and 10 numbers
    
    // create a list of 10 printable characters
    val r = scala.util.Random
    val printableChars = (for i <- 0 to 10 yield r.nextPrintableChar).toList
    // result is like: List(=, *, W, ?, W, 1, L, <, F, d, O)
```

最后，如果使用**List**时数据经常变化，在数据变化的时候用**ListBuffer**，然后在数据停止变化时再转换成**List**：

```scala
    // (6) use a ListBuffer while data is frequently changing
    import collection.mutable.ListBuffer
    val a = ListBuffer(1) // a: ListBuffer(1)
    a += 2 // a: ListBuffer(1, 2)
    a += 3 // a: ListBuffer(1, 2, 3)

    // convert it to a List when the changes stop
    val b = a.toList // b: List(1, 2, 3)
```

**ListBuffer**是基于链表实现的**Buffer**。提供常数时间的**prepend**和**append**操作，且大多数操作是线性的。



## 讨论

很重要的是Scala的 **List**与Java的 **List**（如Java **ArrayList**）完全不同。在22.1小节“在Scala中使用Java **Collections**”，展示了**java.util.List**转换为Scala **Buffer**或**Seq**，而不是Scala **List**。

Scala的 **List** 只是一个以 **Nil** 元素结尾的顺序集合：

```scala
    // empty list
    val xs: List[String] = Nil // List[String] = List()

    // three elements that end with a Nil element
    val xs = 1 :: 2 :: 3 :: Nil // List(1, 2, 3)
    
	// this is an error, because it does not end with a Nil
    val xs = 1 :: 2 :: 3 // error
    
	// prepending a `1` to a `List(2, 3)`
    val xs = 1 :: List(2, 3) // List(1, 2, 3)
```

如上所示， **: :**方法（称为**cons**）接受两个参数：

- *head*元素，是单一的元素。
- *tail*元素，既可以是**List**也可以是**Nil**值

**: :**方法和**Nil**值起源于Lisp编程语言，在Lisp语言中，这样的列表被大量使用。关于**List**的一个重要的事情是，添加元素时总是**prepend**元素在最前面，如下所示：

```scala
    val a = List(3) // List(3)
    val b = 2 :: a // List(2, 3)
    val c = 1 :: b // List(1, 2, 3)
```

下面这段引用来自List类的Scaladoc，讨论了List类的重要属性：

> 这个类最适用于类似栈的后进先出(**LIFO**)访问模式。如果需要随机访问或**FIFO**等访问模式，考虑比List更适合的集合。List的**prepend**和**head/tail**时间复杂度O(1)。其它大多数操作都是O(n)。

## 另见

- **4.14**小节“在匹配表达式中使用列表”，展示了在匹配表达式中处理 List，尤其是 Nil 元素。
- **11.2**小节“理解集合的性能”，有更多关于**List**性能特质的内容。
- 向列表中添加元素在**12.3**小节有更多的讨论。





# 12.3 List中添加元素

## 问题

给正在使用的**List**添加元素。

## 解决方案

“如何给**List**添加元素？”是一个比较麻烦的问题，因为**List**是不可变的，不能添加新元素。如果**List**经常变化，考虑使用**ListBuffer**（如12.5节所述），然后在需要时候转换成**List**。

上述建议适用于不断修改**List**结构中的数据。但如果只想向**List**中添加一些元素，而不是不断更新它 — 因为在**List** 中 **prepending**元素很快，所以首选的方式是通过**: :**方法**prepend**元素，同时将结果赋值给新的**List**。

```scala
    val a = List(2) // a: List(2)

    // prepend with ::
    val b = 1 :: a // b: List(1, 2)
    val c = 0 :: b // c: List(0, 1, 2)
```

还可以使用 **: : :** 方法在一个列表前面添加另一个列表：

```scala
    val a = List(3, 4) // a: List(3, 4)
    val b = List(1, 2) ::: a // b: List(1, 2, 3, 4)
```

可以把变量声明为**var**，并将结果重新赋值给它，而不是不断地把**prepend**操作结果赋值给一个新变量：

```scala
    var x = List(5) // x: List[Int] = List(5)
    x = 4 :: x // x: List(4, 5)
    x = 3 :: x // x: List(3, 4, 5)
    x = List(1, 2) ::: x // x: List(1, 2, 3, 4, 5)
```

正如这些例子所说明的，**: :**和**: : :**方法是右关联的。这意味着列表是从右到左构建的，可以在下面例子中更清楚地看到这一点：

```scala
    val a = 3 :: Nil // a: List(3)
    val b = 2 :: a // b: List(2, 3)
    val c = 1 :: b // c: List(1, 2, 3)
    val d = 1 :: 2 :: Nil // d: List(1, 2)
```

要弄清楚 **: :** 和 **: : :** 的工作原理，了解 Scala 编译器很有帮助，Scala编译器将第一个例子的代码转换为第二个例子的代码：

```scala
    List(1, 2) ::: List(3, 4) // what you type
    List(3, 4).:::(List(1, 2)) // how the compiler interprets that code
```

结果都是**List(1,2,3,4)**。

## 讨论

### 其他方法如prepend，append

## 另见

# 12.4 List(或ListBuffer)中删除元素

## 问题

## 解决方案

### List

### ListBuffer

## 讨论

## 另见

# 12.5 用ListBuffer创建可变列表

## 问题

## 解决方案

## 讨论

### 小List

# 12.6  使用LazyList

## 问题

## 解决方案

## 讨论

## 另见

# 12.7 ArrayBuffer为首选的可变序列

## 问题

## 解决方案

## 讨论

# 12.8 从Array和ArrayBuffer中删除元素

## 问题

## 解决方案

## 讨论

# 12.9 创建和修改Array

## 问题

## 解决方案

## 讨论

# 12.10 创建多维数组

## 问题

## 解决方案

## 讨论

# 12.11 数组排序

## 问题

## 解决方案

## 讨论

## 另见