# 12 集合：常见序列类

在本章中，我们会研究最常见的序列类。 正如11.1节“选择集合类”中提到的，序列类的使用建议如下：

- **Vector**是首选的不可变索引序列。
- **List**是首选的不可变线性序列。
- **ArrayBuffer**是首选的可变索引序列。
- **ListBuffer**是首选的可变线性序列。

# Vector

正如11.1 节“选择集合类”中所讨论，**Vector**是首选的不可变索引序列类，因为它具有通用的性能特征。 需要不可变序列时使用它。

因为 **Vector** 是不可变的，所以可以通过过滤和转换方法创建另一个**Vector**。 快速浏览下面创建和使用 **Vector**的例子：

```scala
    val a = Vector(1, 2, 3, 4, 5)
    val b = a.filter(_ > 2) // Vector(3, 4, 5)
    val c = a.map(_ * 10) // Vector(10, 20, 30, 40, 50)
```



# List

如果你从Java来到Scala，很快会发现尽管名字相同，但Scala **List**与 Java **List** （例如 Java **ArrayList**）完全不同。Scala **List**类是不可变的，大小和包含的元素都不能改变。它基于链表实现，首选的方法是*prepend*元素。由于是链表，所以遍历需要从头到尾，实际上，通常认为它由**head**，**tail** 方法(以及**isEmpty**)组成。

与 **Vector**类似，由于 **List** 是不可变的，所以可以通过过滤和转换方法创建另一个**List**，快速浏览下面创建和使用 **List**的例子：

```scala
    val a = List(1, 2, 3, 4, 5)
    val b = a.filter(_ > 2) // List(3, 4, 5)
    val c = a.map(_ * 10) // List(10, 20, 30, 40, 50)
```

> List和Vector
>
> 你可能想知道何时使用**List**而不是**Vector**。11.2小节“理解集合的性能”中详细介绍了性能特征，提供了选择的通用规则。
>
> 在一个有趣的实验中，Scala语言的创建者Martin Odersky，在Scala贡献者网站上的这个帖子中指出，Tiark Rompf曾经试图用Vector替换Scala编译器中的所有List，结果性能下降了10%。所以认为Vector有一定的开销，导致在处理小序列时效率较低。
>
> 所以 List 有其用处，尤其是当你把它想象成它是一个简单的单链表时。 （在Martin Odersky 先生的评论中，Java Champion， Scala Future的创造者Viktor Klang—认为List是一个优秀的技术栈。）

# ArrayBuffer

**ArrayBuffer** 是首选的可变索引序列类。 因为是可变的，可以通过转换方法来修改内容。 例如，将**map**方法与**Vector**或**List**一起使用，并将结果赋给一个新变量：

```scala
    val x = Vector(1, 2, 3)
    val y = x.map(_ * 2) // y: ArrayBuffer(2, 4, 6)
```

对于**ArrayBuffer**，使用**mapInPlace**而不是**map**方法，会原地修改值：

```scala
    import collection.mutable.ArrayBuffer
    val ab = ArrayBuffer(1, 2, 3)
    ab.mapInPlace(_ * 2) // ab: ArrayBuffer(2, 4, 6)
```

> **Buffers**
>
> 在Scala中，*Buffer*只是一个可以增长和收缩的序列。

# Array

Scala **Array**很独特：它的元素可以变，但是大小是不可变—不能增加或减少。相比之下，**List**和**Vector**是完全不可变的，而**ArrayBuffer**是完全可变的。

数组的独特之处在于它是基于Java数组，所以Scala数组**[Int]**是基于Java **Int[]**的。

虽然**Array**经常展示在Scala例子中，但建议将**Vector**类作为首选的不可变索引序列类，**ArrayBuffer**作为首选的可变索引序列。基于这个建议，我的实际代码中使用**Vector**和**ArrayBuffer**，在需要时转换为**Array**。

对于一些操作，**Array**比其他集合有更好的性能，所以了解它的工作原理是很重要的。详情参考11.2节，“理解集合的性能”。



# 12.1 Vector作为首选的不可变序列

## 问题

在Scala应用中想要一个快速的，通用的，不可变的序列集合类型。

## 解决方法

Vector类是首选的通用索引不可变的顺序集合。 如果更需要线性不可变顺序集合，可以使用List。

### 创建Vectors

和其它不可变序列一样创建和使用 **Vector**。 可以通过初始元素创建一个 **Vector**，然后通过索引访问元素：

```scala
    val v = Vector("a", "b", "c")
    v(0) // "a"
    v(1) // "b"
```

因为**Vector**有索引，所以调用**x(9_999_999)**几乎立即返回：

```scala
    val x = (1 to 10_000_000).toVector
    x(9_999_999) // 10000000
```

还可以创建一个空的**Vector**，并向其添加元素，记住要将结果赋给一个新变量：

```scala
    val a = Vector[String]() // a: Vector[String] = Vector()
    val b = a ++ List("a", "b") // b: Vector(a, b)
```



### Add, Append和Prepend元素

由于不能修改向量，所以将结果指定给新变量时，可以向现有向量添加元素：

```scala
    val a = Vector(1, 2, 3)
    val b = a ++ List(4, 5) // b: Vector(1, 2, 3, 4, 5)
    val c = b ++ Seq(6) // c: Vector(1, 2, 3, 4, 5, 6)
```

和其他不可变序列一样，通过下面方法给Vector中append和prepend元素：

-  **+:**  方法，别名**prepended**。
- **++:** 方法，别名**prependedAll**。
- **:+** 方法，别名**appended**。
- **:++**方法，别名**appendedAll**。

下面是例子，将每个操作的结果赋值**var**变量：

```scala
// prepending
var a = Vector(6)

a = 5 +: a // a: Vector(5, 6)
a = a.prepended(4) // a: Vector(4, 5, 6)

a = List(2,3) ++: a // a: Vector(2, 3, 4, 5, 6)
a = a.prependedAll(Seq(0,1)) // a: Vector(0, 1, 2, 3, 4, 5, 6)

// appending
var b = Vector(1)

b = b :+ 2 // b: Vector(1, 2)
b = b.appended(3) // b: Vector(1, 2, 3)

b = b :++ List(4,5) // b: Vector(1, 2, 3, 4, 5)
b = b.appendedAll(List(6,7)) // b: Vector(1, 2, 3, 4, 5, 6, 7)
```



### 修改元素

要修改**Vector**中的元素，调用**update**方法时设置**index**和**elem**参数来替换元素，同时将结果赋给一个新变量：

```scala
    val a = Vector(1, 2, 3)
    val b = a.updated(index=0, elem=10) // b: Vector(10, 2, 3)
    val c = b.updated(1, 20) // c: Vector(10, 20, 3)
```

同样，使用 **patch** 方法一次替换多个元素：

```scala
    val a = Vector(1, 2, 3, 4, 5, 6)

    // specify (a) the index to start at, (b) the new sequence
    // you want, and (c) the number of elements to replace
    val b = a.patch(0, List(10,20), 2) // b: Vector(10, 20, 3, 4, 5, 6)
    val b = a.patch(0, List(10,20), 3) // b: Vector(10, 20, 4, 5, 6)
    val b = a.patch(0, List(10,20), 4) // b: Vector(10, 20, 5, 6)

    val b = a.patch(2, List(30,40), 2) // b: Vector(1, 2, 30, 40, 5, 6)
    val b = a.patch(2, List(30,40), 3) // b: Vector(1, 2, 30, 40, 6)
    val b = a.patch(2, List(30,40), 4) // b: Vector(1, 2, 30, 40)
```

使用**patch**，插入元素可以通过设置替换的元素数量为0：

```scala
    val a = Vector(10, 20, 30)
    val b = a.patch(1, List(15), 0) // b: Vector(10, 15, 20, 30)
    val b = a.patch(2, List(25), 0) // b: Vector(10, 20, 25, 30)
```



## 讨论

Scala 文档中关于不可变集合类的声明如下：

> **Vector**是种集合类型，可解决List随机访问低效的问题。 **Vector**可以在“有效”常数时间内访问列表中的任何元素……因为**Vector**在快速随机选择和快速随机函数更新之间取得了很好的平衡，是不可变索引序列的默认实现。

在“理解集合的层次”中所述，创建 **IndexedSeq** 的实例时，Scala 会返回**Vector**：

```scala
    scala> val x = IndexedSeq(1,2,3)
    x: IndexedSeq[Int] = Vector(1, 2, 3)
```

因此，我看到一些开发人员在创建索引不可变序列时，使用**IndexedSeq**而不是**Vector**，并将实现细节留给编译器。

# 12.2创建和填充List

## 问题

## 解决方法

## 讨论

## 另见

# 12.3 List中添加元素

## 问题

## 解决方法

## 讨论

### 其他方法如prepend，append

## 另见

# 12.4 List(或ListBuffer)中删除元素

## 问题

## 解决方法

### List

### ListBuffer

## 讨论

## 另见

# 12.5 用ListBuffer创建可变列表

## 问题

## 解决方法

## 讨论

### 小List

# 12.6  使用LazyList

## 问题

## 解决方法

## 讨论

## 另见

# 12.7 ArrayBuffer为首选的可变序列

## 问题

## 解决方法

## 讨论

# 12.8 从Array和ArrayBuffer中删除元素

## 问题

## 解决方法

## 讨论

# 12.9 创建和修改Array

## 问题

## 解决方法

## 讨论

# 12.10 创建多维数组

## 问题

## 解决方法

## 讨论

# 12.11 数组排序

## 问题

## 解决方法

## 讨论

## 另见