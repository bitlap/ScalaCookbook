# 命令行任务

我们的Scala 3之旅，始于命令行。比如，在你按照xxi页“安装Scala”后，你可能会想要从操作系统的命令行中输入 **scala** 来启动REPL——Scala的 Read/Eval/Print/Loop （添加备注：REPL基本上是现在所有主流语言的标配 java也有javashell了）。或者你可能想要创建一个小小的基于文件的“Hello, world“项目，然后来编译运行它。因为许多人开始使用Scala是从命令行任务开始的，所以我们先从这里开始介绍。

REPL是一个命令行*shell*，它是一个小实验室，你可以在这里运行各种小测试来看看Scala和它的一些第三方库是如何工作的。如果你熟悉Java的JShell，Ruby的**irb**，Python的shell或者IPython，或者Haskell的**ghci**，那么Scala的REPL与这些都很相似。如图1-1所示，只要在操作系统命令行输入**scala** 就可以启动REPL，然后再输入Scala表达式然后就会在 shell 中被求值。

当你想测试一些Scala代码时，REPL是一个绝佳的实验环境。没必要创建一个完整的工程——只需要将你的测试代码放到REPL中进行实验，直到你知道它能工作了为止。由于REPL是一个非常重要的工具，它最重要的功能将在本章的前两个例子中演示。

![f1-1](./f1-1.jpeg)

图1-1. macOS 终端窗口中运行Scala3 REPL

虽然REPL非常棒，但它不是你唯一的选项。*Ammonite REPL* 最初是为Scala 2创建的，它比Scala2 REPL有更多的功能，包括：

- 能从GitHub和Maven仓库中导入代码
- 保存和恢复会话的能力
- 美化打印输出
- 多行编辑

在写这本书的时候， Ammonite 仍在被移植到Scala 3， 但许多重要的功能已经可以使用了。关于如何使用这些功能的例子，见例子1.3。

最后，当你需要构建Scala项目时，你通常会使用像sbt这样的构建工具，这将在第17章中演示。但如果你想编译和运行一个小型的Scala应用，比如只有一两个文件，你可以用**scalac** 命令编译你的代码，然后使用**scala** 运行就像在Java中使用**javac**和**java**命令那样。这些过程将在例子1.4中进行演示。之后，例子1.6展示了如何使用**java**或**scala**命令运行你打包成JAR文件的应用程序。

## 1.1 Scala REPL 入门

### 问题

开始使用Scala REPL，使用它的一些基本功能

### 解决方法

如果你使用过Java，Python，Ruby和Haskell等语言的REPL环境，你会觉得Scala REPL很熟悉。要启动REPL，在你的操作系统的命令行中输入**scala**。当REPL启动时，你可能看到一个初始信息，紧接着的是 **scala**>提示符：

```
$ scala
Welcome to Scala 3.0
Type in expressions for evaluation. Or try :help.

scala> _
```

该提示表明你正在使用Scala REPL。在REPL环境中，你可以尝试各种不同的实验和表达式。

```
scala> val x = 1
x: Int = 1

scala> val y = 2
y: Int = 2

scala> x + y 
res0: Int = 3

scala> val x = List(1, 2, 3)
x: List[Int] = List(1, 2, 3)

scala> x.sum 
res1: Int = 6
```

正如上述例子所示：

- 输入命令后，REPL输出显示你的表达式的结果，包括数据类型信息。
- 如果没有指定一个变量名，如第三个例子所示，REPL会创建自己的变量，以**res0**开头然后是**res1**以此类推。你可以直接使用这些变量名，就像这些变量是你创建的那样：

```
scala> res1.getClass 
res2: Class[Int] = int

scala> res1 + 2 
res3: Int = 8
```

初学者和有经验的开发者每天都会在REPL中编写代码，以快速了解Scala的功能和他们自己的算法是如何工作的。

#### Tab 补全

有一些简单的技巧可以使REPL的使用更加有效。一个技巧是使用*tab 补全*来查看一个对象上的可用方法。我们可以通过输入1然后一个小数点再然后按Tab键来看看tab 补全是如何工作的。REPL的响应是列出**Int**实例上的几十个可用方法：

```
scala> 1.

!=     	finalize     	round 
##     	floatValue   	self
%      	floor        	shortValue
&      	formatted    	sign
*      	getClass     	signum
many more here ...

```

你也可以通过输入方法名的第一部分，然后按Tab键来限制所显示的方法列表。比如，如果你想看**List**上所有的方法，输入**List(1)**。然后按Tab键，你会看到超过200个方法。但如果你只关心**List**上以**to**开头的方法，那么你可以输入**List(1).to** 然后按Tab键，输出结果就会减少到这些方法：

```
scala> List(1).to
to        toIndexedSeq  toList  toSet      toTraversable
toArray   toIterable    toMap   toStream   toVector
toBuffer  toIterator    toSeq   toString
```

#### 讨论

我使用REPL创建了许多小实验，这有助于我理解Scala自动执行的一些类型转换。比如，当我刚开始使用Scala时，我在REPL中输入以下代码时，我不知道变量x的类型是什么：

```
scala> val x = (3, "Three", 3.0)
val x: (Int, String, Double) = (3,Three,3.0)
```

在REPL中很容易运行这样的测试，然后在一个变量上调用**getClass**来查看其类型：

```
scala> x.getClass 
val res0: Class[? <: (Int, String, Double)] = class scala.Tuple3
```

虽然对于刚开始使用Scala的你来说，上面这一行输出的可读性有些差，但是=右边的信息能让你知道这个类型是一个**Tuple3**

你也可以使用REPL的**:type**命令来查看类似的信息，尽管并不会显示**Tuple3**的名字：

```
scala> :type x 
(Int, String, Double)
```

然而，一般来说，在许多其他情况下，这个命令还是有帮助的：

```
scala> :type 1 + 1.1 
Double

scala> :type List(1,2,3).map(_ * 2.5) 
List[Double]
```

虽然这些都是简单的例子，但你会发现，当处理更复杂的代码以及那些你不熟悉的库时，REPL是非常有帮助的。

![tips](./tips.png)

##### 在sbt内部启动REPL

你也可以从sbt shell中启动Scala REPL会话，如例17.5”了解其他sbt命令“所示，只要在一个sbt项目中启动sbt shell：

```
$ sbt 
MyProject> _
```

然后在那使用**console**或者**consoleQuick**命令：

```
MyProject> console 
scala> _
```

**console**命令会编译项目中的源文件，将其放到classpath中并启动REPL。而**consoleQuick**命令则会直接使用项目依赖在classpath上启动REPL（不会编译项目源代码）。**consoleQuick**适用于你的项目源代码不能被编译或者你只是想使用依赖库尝试一些测试代码的情况

#### 另见

如果你很喜欢REPL环境的想法，但又想尝试一些默认REPL以外的REPL，可以考虑下面的一些免费的REPL：

- Ammonite REPL有着比默认REPL更多的功能，在例1.3中有演示。
- [Scastie](https://scastie.scala-lang.org/)是一个基于Web支持sbt选项并且可以添加外部库的REPL。
- [ScalaFiddle](https://scalafiddle.io)另一个基于Web的REPL。
- IntelliJ IDEA和Visual Studio Code(VS Code) IDEs都有类似REPL的功能的worksheets。