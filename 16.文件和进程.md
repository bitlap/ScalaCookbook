# 文件和进程

当涉及文件操作时，本章中的许多解决方案都使用了Java类，但对于某些情况，**scala.io.Source**类及其伴生对象比起Java有更好的简化。**Source**
不仅让打开和读取文本文件变得简单，还让完成其他任务变得简单，例如从URL下载内容，或者用**String**代替一个**File**。

文件在本章中将会有以下内容：

- 读取和写入文本和二进制文件。
- 用**scala.util.Using**的*Loan Pattern*来自动关闭资源。
- 处理文件中的每一个字符。
- 将一个**String**视为一个**File**，通常在测试中使用。
- 将对象序列化和反序列化到文件中。
- 列出文件和目录。

接下来，当涉及到和进程交互时，Scala **process**类被写成了DSL，所以可以用一种类似于Unix的方式执行外部命令。运行系统命令的能力对于应用程序是很有用的，对于脚本来说也是非常有用。

**scala.sys.process**包中的类和方法可以让你从Scala中运行外部系统命令，代码如下：

```
    val result: String = "ls -al".!!
    val result = Seq("ls", "-al").!!
    val rootProcs = ("ps aux" #| "grep root").!!.trim
    val contents: LazyList[String] =
    sys.process.Process("find /Users -print").lazyLines
```

Scala进程的DSL提供了五种执行*external commands*的方式：

- 使用**run**方法来异步运行外部命令，方法结束时检查它的退出状态。
- 使用 **！** 方法来运行命令，并在等待返回退出状态时进行阻塞。
- 使用 **!!** 方法来运行命令，并在等待返回输出时进行阻塞。
- 使用**lazyLines**方法来异步运行命令，并将其结果作为 **LazyList[String]** 返回。
- 如果退出状态不是0，**lazyLines**将抛出一个异常，所以如果你不想这样，请使用**lazy Lines_!**。

进程在本章中将会有以下内容：

- 运行外部命令并访问退出状态和输出结果。
- 同步和异步地运行这些命令。
- 从这些命令中访问**STDOUT**和**STDERR**。
- 运行命令管道和使用通配符。
- 在不同的目录下执行命令，并为其配置环境变量。

#### 正方体框 TODO 可能发生的事情的边界

从概念上讲，关于这些类的限制，有一点很重要，在进程库的Scala文档中做了说明（ *https://oreil.ly/EvyzU* ）：

整个包的底层基础是Java的**Process**和**ProcessBuilder**类。虽然没有必要使用这些Java类，但需要了解它们可能发生事情的限制。例如，不能为正在执行的进程查找其进程ID。

如果你想知道为什么某些事情是这样的，记住这一点很重要。

## 16.1读取文本文件

### 问题

你想打开一个文本文件并处理文件中的行。

### 解决方案

在Scala中打开和读取文本文件的方法有很多，其中很多方法都使用了Java库，但本小节中展示的解决方案主要使用**scala.io.Source**打开和读取文本文件。

本小节展示了两种Source方案的使用方式：

- 简洁的单行语法。这有一个副作用，就是会使文件处于打开状态，但在运行时间短的程序中可能会很有用，比如shell脚本。
- 一个较长的方法，能正确地关闭文件。

#### 使用简明的语法

在Scala shell脚本中，JVM在相对较短的时间内启动和停止，文件是否关闭可能并不重要，因此可以使用Scala **scala.io.Source.fromFile**方法。例如，在读取文件时处理文件中的每一行，可以使用这种方法：

```
    import scala.io.Source
        for line <- Source.fromFile("/etc/passwd").getLines do
        // do whatever you need to do with each line in the file
        println(line)
```

还有一个变种，使用下面方法从文件中获取所有的行作为**List**或**String**：

```
    val linesAsList = Source.fromFile("/etc/passwd").getLines.toList
    val linesAsString = Source.fromFile("/etc/passwd").getLines.mkString
```

**fromFile**方法返回**scala.io.BufferedSource**，Scaladoc说**getLines**方法将 "任何的 **\r\n**，**\r** 或 **\n** 视为行分隔符（最长匹配）"，所以如果是**List**情况下，序列中的每个元素是文件中的一行。

这种方法有一个副作用，就是只要JVM在运行，文件就会一直打开，但对于运行时间短的Shell脚本来说，这不应该是一个问题；因为当JVM关闭时，文件就会关闭。

#### 正确地关闭文件和处理异常情况

为了正确地关闭文件和处理异常，请使用**scala.util.Using**对象，它可以自动关闭资源。如果你想把一个文件读入一个序列，请使用以下方法之一：

```
import scala.util.Using
import scala.util.{Try, Success, Failure}

def readFileAsSeq(filename: String): Try[Seq[String]] =
        Using(io.Source.fromFile(filename)) { bufferedSource =>
        bufferedSource.getLines.toList
    }
    
def readFileAsSeq(filename: String): Try[Seq[String]] =
	Using(io.Source.fromFile(filename)) { _.getLines.toList }
```

读取文件时处理每一行，使用这种方法：

```
def readFileAsSeq(filename: String): Try[Seq[String]] =
    Using(io.Source.fromFile(filename)) { bufferedSource =>
        val ucLines = for
            line <- bufferedSource.getLines
            // 'line' is a String. can work with each Char here,
            // if desired, like this:
            // char <- line
        yield
            // work with each 'line' as a String here
            line.toUpperCase
        ucLines.toSeq
}
```

如上面代码中的第一个注释所示，如果你想处理文件中的每个字符，就使用**for**循环中的**line**。

使用**scala.util.Using**的好处是它会自动关闭资源。**Using**对象实现了租赁（Loan）模式，其基本过程是:

- 创建可以使用的资源。
- 将资源”租赁“给其它代码。
- 当其它代码使用完资源时，会自动关闭/销毁资源，例如通过自动调用**BufferedSource**的**close**方法。

**Using**对象Scaladoc（ *https://oreil.ly/7iNzY* ）表明：“可以用来执行一个使用资源的操作，然后按照创建资源的相反顺序释放资源”。对于打开和关闭多个资源所需的方法，查看Scaladoc。

### 讨论

如上所述，只要JVM在运行，第一个解决方案就保持文件打开：

```
    // leaves the file open
    for (line <- io.Source.fromFile("/etc/passwd").getLines)
    	println(line)

    // also leaves the file open
    val contents = io.Source.fromFile("/etc/passwd").mkString
```

在Unix系统中，你可以在程序运行时，在另一个终端运行**lsof**（列出打开的文件）命令来显示一个文件是否被打开。例如，可以使用下面三个**lsof**命令：

```
    lsof -c java | grep '/etc/passwd'
    sudo lsof /etc/passwd
    sudo lsof -u Al | grep '/etc/passwd'
```

第一个命令列出所有打开的文件，这些文件的命令以**java**字符串开头，然后在输出中搜索**/etc/passwd**文件。如果文件名在输出中，这意味着它是打开的，所以你会看到类似这样的内容：

```
	java 17148 Al 40r REG 14,2 1475 174214161 /etc/passwd
```

然后，当你关闭**REPL**--从而停止JVM进程时，你会看到该文件不再出现在**lsof**输出中。

#### 自动关闭资源

当处理文件或者其他资源需要关闭时，最好使用借贷模式，正如第二个解决方案的例子所示。

在Scala中，也可以通过**try/finally**语句来保证关闭资源。在Scala 2的早期，我在第一版的《Beginning Scala》（Apress出版）的**using**方法中第一次看到这个解决方案的实现：

```
    // a Scala 2 approach (circa 2009)
    import scala.language.reflectiveCalls
    
    object Control:
    	def using[A <: { def close(): Unit }, B](resource: A)(fun: A => B): B =
    		try
    			fun(resource)
    		finally
    			resource.close()
```

如上所示，**resource**被定义为参数，且必须有**close()**方法（否则代码将无法编译）。这个**close()**方法会在**try**块的**finally**语句中被调用。

#### 很多io.Source方法

**scala.io.Source**对象（ *https://oreil.ly/USXcl* ）有许多方法用于从不同类型的来源中读取数据，包括：

- 8个**fromFile**方法。
- **fromInputStream**方法，从**java.io.InputStream**中读取。
- **fromIterable**，通过**Iterable**创建**Source**。
- **fromString**，通过**String**创建**Source**。
- **fromURI**，从**java.net.URI**中读取。
- 4个**fromURL**方法，从**java.net.URL**读取数据。
- **stdin**，通过**System.in**创建**Source**。

举一个例子，如果你想在指定编码的同时读取文件，可以这么写：

```
	Source.fromFile("example.txt", "UTF-8")
```



#### 强大的Java集成   TODO 乌鸦图  

由于Scala与Java的配合非常好，你可以使用Java **FileReader**和**BufferedReader**类，以及其他Java库，如Apache Commons **FileUtils**类来读取文件。



### 另见

- **scala.util.Using** （ *https://oreil.ly/7iNzY* ）的Scaladoc。
- **scala.io.Source**（ *https://oreil.ly/USXcl* ）的Scaladoc。
- 你也可以用Java **BufferedReader**和**FileReader**类来读取文本文件。我写了一篇博客，“用Scala读取大型文本文件的五个好方法（和两个坏方法）（ *https://oreil.ly/My1Fj* ）”。

## 16.2 写入文本文件

### 问题

### 解决方案

### 讨论

### 另见

## 16.3读写二进制文件

### 问题

### 解决方案

### 讨论

### 另见

## 16.4 将字符串伪装为文件

### 问题

### 解决方案

### 讨论

## 16.5 序列化和反序列化对象到文件

### 问题

### 解决方案

### 讨论

## 16.6 列出目录中的文件

### 问题

### 解决方案

### 讨论

### 另见

## 16.7 执行外部命令

### 问题

### 解决方案

### 讨论

## 16.8 执行外部命令和读取标准输出

### 问题

### 解决方案

### 讨论

## 16.9 处理命令的标准输出和标准错误输出

### 问题

### 解决方案

### 讨论

### 另见

## 16.10 构建外部命令管道

### 问题

### 解决方案

### 讨论