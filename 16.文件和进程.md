# 文件和进程

当涉及文件操作时，本章中的许多解决方案都使用了Java类，但对于某些情况，**scala.io.Source**类及其伴生对象比起Java有更好的简化。**Source**不仅让打开和读取文本文件变得简单，还让完成其他任务变得简单，例如从URL下载内容，或者用**String**代替一个**File**。

文件在本章中将会有以下内容：

- 读取和写入文本和二进制文件。
- 用**scala.util.Using**的*Loan Pattern*来自动关闭资源。
- 处理文件中的每一个字符。
- 将一个**String**视为一个**File**，通常在测试中使用。
- 将对象序列化和反序列化到文件中。
- 列出文件和目录。

接下来，当涉及到和进程交互时，Scala **process**类被写成了DSL，所以可以用一种类似于Unix的方式执行外部命令。运行系统命令的能力对于应用程序是很有用的，对于脚本来说也是非常有用。

**scala.sys.process**包中的类和方法可以让你从Scala中运行外部系统命令，代码如下：

```
    val result: String = "ls -al".!!
    val result = Seq("ls", "-al").!!
    val rootProcs = ("ps aux" #| "grep root").!!.trim
    val contents: LazyList[String] =
    sys.process.Process("find /Users -print").lazyLines
```

Scala进程的DSL提供了五种执行*external commands*的方式：

- 使用**run**方法来异步运行外部命令，方法结束时检查它的退出状态。
- 使用**！**方法来运行命令，并在等待返回退出状态时进行阻塞。
- 使用**!!**方法来运行命令，并在等待返回输出时进行阻塞。
- 使用**lazyLines**方法来异步运行命令，并将其结果作为**LazyList[String]**返回。
- 如果退出状态不是0，**lazyLines**将抛出一个异常，所以如果你不想这样，请使用**lazy Lines_!**。

进程在本章中将会有以下内容：

- 运行外部命令并访问退出状态和输出结果。
- 同步和异步地运行这些命令。
- 从这些命令中访问**STDOUT**和**STDERR**。
- 运行命令管道和使用通配符。
- 在不同的目录下执行命令，并为其配置环境变量。

#### 正方体框  TODO   可能发生的事情的边界

从概念上讲，关于这些类的限制，有一点很重要，在进程库的Scala文档中做了说明（ * https://oreil.ly/EvyzU *）：

整个包的底层基础是Java的**Process**和**ProcessBuilder**类。虽然没有必要使用这些Java类，但需要了解它们可能发生事情的限制。例如，不能为正在执行的进程查找其进程ID。

如果你想知道为什么某些事情是这样的，记住这一点很重要。

## 16.1读取文本文件

### 问题

你想打开一个文本文件并处理文件中的行。

### 解决方案



### 讨论

### 另见

## 16.2 写入文本文件

### 问题

### 解决方案

### 讨论

### 另见

## 16.3读写二进制文件

### 问题

### 解决方案

### 讨论

### 另见

## 16.4 将字符串伪装为文件

### 问题

### 解决方案

### 讨论

## 16.5 序列化和反序列化对象到文件

### 问题

### 解决方案

### 讨论

## 16.6 列出目录中的文件

### 问题

### 解决方案

### 讨论

### 另见

## 16.7 执行外部命令

### 问题

### 解决方案

### 讨论

## 16.8 执行外部命令和读取标准输出

### 问题

### 解决方案

### 讨论

## 16.9 处理命令的标准输出和标准错误输出

### 问题

### 解决方案

### 讨论

### 另见

## 16.10 构建外部命令管道

### 问题

### 解决方案

### 讨论