# 13 集合：常见序列方法

前两章主要关注序列类，本章主要关注常用的序列方法。深入研究这些小节前，当使用集合类方法时，需要了解一些重要的概念：

- 谓词
- 匿名函数
- 隐式循环

## 谓词

*predicate*是一个方法、函数或匿名函数。接收一个或多个输入参数并返回**Boolean**值。 下面方法返回 **true** 或 **false**，所以是一个谓词：

```
    def isEven(i: Int): Boolean =
        i % 2 == 0
```

谓词是一个简单的概念，使用集合方法时，会经常听到这个术语，所以有必要提及。

## 匿名函数

匿名函数的概念也很重要。在10.1小节“使用函数字面量(匿名函数)”中有深入的描述，作为一个简单的例子，下面代码展示了完整的匿名函数，与 **isEven** 方法做同样的工作：

```
    (i: Int) => i % 2 == 0
```

简写如下：

```
    _ % 2 == 0
```

看起来并不多，但当它与集合上的**filter**方法结合在一起时，一小段代码就会发挥很大的作用：

```
    scala> val list = List.range(1, 10)
    list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
    
    scala> val events = list.filter(_ % 2 == 0)
    events: List[Int] = List(2, 4, 6, 8)
```

## 隐式循环

**filter**方法是第三个话题的一个很好的例子：*implied loops*。正如你从上面例子中看到的，**filter**包含一个循环，将你的函数使用在集合中的每个元素，并返回一个新的集合。你可以不使用**filter**
方法，而写出下面等价代码：

```
    for
        e <- list
        if e % 2 == 0
    yield
        e
```

我认为你会赞同，**filter**方法既更简洁，也更容易阅读。

像**filter**、**foreach**、**map**、**reduceLeft**等集合方法都在其算法中内置了循环。由于这些内置的方法，在编写Scala代码时，你会比其他语言少写很多自定义的**for**循环。

## 本章中的小节

虽然序列类有一百多个内置的方法，但本章的小节主要集中在最常用的方法上，包括：

- **filter**，允许你用一个给定的谓词来过滤集合。
- **map**，允许你对集合中的每个元素应用一个转换函数。
- 提取序列和现有序列子集的方法。
- 寻找序列中唯一元素的方法。
- 合并和压缩序列的方法。
- 随机化和排序序列的方法。
- 将序列转换为字符串的两个方法。

这些功能（以及更多的功能）将在下面的小节中展示。

## 13.1 选择集合方法解决问题

### 问题

Scala集合里有大量的方法可用，需要选择其中一个来解决一个问题。

### 解决方案

Scala集合类提供了丰富的用来操作数据的方法。绝大多数方法以一个函数或者谓词作为参数。

可用的方法在本节中会以两种方式列出。接下来的几段中，方法按类别划分，从而使你方便找到所需要的。然后在后面的表格中，还会有简单的描述和方法签名。

#### 按类别划分的方法

##### 过滤方法

可以用来过滤一个集合的方法，包括**collect**，**diff**，**distinct**，**drop**，**dropRight**，**dropWhile**，**filter**，**filterNot**，**filterInPlace**，**find**，**foldLeft**，**foldRight**，**head**，**headOption**，**init**，**intersect**，**last**，**lastOption**，**slice**，**tail**，**take**，**takeRight**，**takeWhile**和**union**。

##### 转换方法

转化器方法至少需要一个输入集合来创建一个新的输出集合，通常使用你提供的算法。包括 **+**，**++**，**+:**，**++:**，**appended**，**appendedAll**，**diff**，**distinct**，**collect**，**concat**，**flatMap**，**flatten**，**inits**，**map**，**mapInPlace**， **patch**， **reverse**， **sorted**， **sortBy**， **sortWith**， **sortInPlace**， **sortInPlaceWith**， **sortInPlaceBy**， **tails**， **takeWhile**， **updated**， **zip**和**zipWithIndex**。

##### 分组方法

这些方法会根据一个已有的集合创建多个分组。包括**groupBy**，**grouped**，**groupMap**，**partition**，**sliding**，**span**，**splitAt**和**unzip**。

##### 信息和数学方法

这些方法提供关于集合的信息，包括**canEqual**，**contains**，**containsSlice**，**count**，**endsWith**，**exists**，**find**，**findLast**，**forAll**，**indexOf**，**indexOfSlice**，**indexWhere**，**isDefinedAt**，**isEmpty**，**last**，**lastOption**，**lastIndexOf**，**lastIndexOfSlice**，**lastIndexWhere**，**length**，**lengthIs**，**max**，**maxBy**，**maxOption**，**maxByOption**，**min**，**minBy**，**minOption**，**minByOption**，**nonEmpty**，**product**，**segmentLength**，**size**，**sizeIs**，**startsWith**和**sum**。像**foldLeft**，**foldRight**，**reduceLeft**和**reduceRight**这样的方法也可以通过提供一个函数去获得集合的信息。

##### 其他

一些其他的方法很难分类，包括**view**，**foreach**，**addString**和**mkString**。**view**在集合上创建一个惰性视图（见11.4小节，“在集合上创建惰性视图”），**foreach**就像**for**循环，遍历集合里的每一个元素，并对每个元素产生副作用。**addString**和**mkString**会根据集合生成字符串。

甚至还有比这里列出的更多方法。例如，有一系列的 **to*** 方法，把当前集合（例如**List**）转换为其他集合类型（**toArray**，**toBuffer**，**toVector**等等）。查看集合类的Scaladoc找到更多的内置方法。

#### 通用集合方法

下表列出了最常见的集合方法。注意，带引号的描述来自每个类的Scaladoc。

表13-1通过**Iterable**列出了所有集合共有的方法。在这个表中，第一列符号的含义如下：

- **c**代表一个集合。
- **f**代表一个函数。
- **p**代表一个谓词。
- **n**代表一个数字。

更多的可变和不可变集合的方法分别在表13-2和表13-3中。

*表13-1 **Iterable**集合的常用方法（scala.collection.Iterable）*

| 方法              | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| c collect f       | 通过将偏函数应用于已定义函数的集合中所有元素来构建一个新集合。 |
| c count p         | 对集合中满足谓词的元素的计数。                               |
| c drop n          | 返回集合中除前n个元素外的所有元素。                          |
| c dropWhile p     |                                                              |
| c exists p        |                                                              |
| c filter p        |                                                              |
| c filterNot p     |                                                              |
| c find p          |                                                              |
| c flatMap f       |                                                              |
| c flatten         |                                                              |
| c foldLeft(s)(f)  |                                                              |
| c foldRight(s)(f) |                                                              |
| c forAll p        |                                                              |
| c foreach f       |                                                              |
| c groupBy f       |                                                              |
| c head            |                                                              |
| c headOption      |                                                              |
| c init            |                                                              |
| c inits           |                                                              |
| c isEmpty         |                                                              |
| c knownSize       |                                                              |
| c last            |                                                              |
| c lastOption      |                                                              |
| c1 lazyZip c2     |                                                              |
| c map f           |                                                              |

| 方法                 | 描述 |
| -------------------- | ---- |
| c max                |      |
| c maxOption          |      |
| c maxBy f            |      |
| c maxByOption        |      |
| c min                |      |
| c minOption          |      |
| c minBy              |      |
| c minByOption        |      |
| c mkString           |      |
| c nonEmpty           |      |
| c partition p        |      |
| c product            |      |
| c reduceLeft op      |      |
| c reduceRight op     |      |
| c scanLeft op        |      |
| c scanRight op       |      |
| c size               |      |
| c1 sizeCompare(c2)   |      |
| c sizeIs n           |      |
| c slice(from, to)    |      |
| c sliding(size,step) |      |
| c span p             |      |
| c splitAt n          |      |
| c sum                |      |
| c tail               |      |
| c tails              |      |
| c take n             |      |

| 方法           | 描述 |
| -------------- | ---- |
| c takeWhile p  |      |
| c tapEach f    |      |
| c unzip        |      |
| c view         |      |
| c1 zip c2      |      |
| c zipWithIndex |      |

还有其他方法，但这些是最常见的。关于更多的方法，参考你正在使用集合的Scaladoc。

#### 可变集合方法

表13-2展示了可变集合的常用方法（这些都是方法，但是某些方法看起来像内置的操作符）。

*表13-2可变集合中常用的操作符（方法）*

| 方法                    | 描述 |
| ----------------------- | ---- |
| c += x                  |      |
| c1 ++= c2               |      |
| c −= x                  |      |
| c −= (x,y,z)            |      |
| c1 −−= c2               |      |
| c(n) = x                |      |
| c append x              |      |
| c1 appendAll c2         |      |
| c clear                 |      |
| c filterInPlace p       |      |
| c flatMapInPlace f      |      |
| c mapInPlace f          |      |
| c1.patchInPlace(i,c2,n) |      |
| c prepend x             |      |
| c1 prependAll c2        |      |

| 方法                | 描述 |
| ------------------- | ---- |
| c sortInPlace       |      |
| c sortInPlaceBy f   |      |
| c sortInPlaceWith f |      |
| c remove i          |      |
| c.remove(i, len)    |      |
| c.update(i,e)       |      |

注意，像 **+=** 和 **-=** 这样的符号方法名是方法的别名。例如 **+=** 是 **addOne** 的别名。关于更多的方法，参考你正在使用可变集合的Scaladoc。

#### 不可变集合方法

表13-3展示了不可变集合的常用方法。注意不能修改不可变集合，所以第一列中每个表达式的结果必须被赋值给一个新的变量。(参考11.3小节“理解可变变量与不可变集合”，了解在不可变的集合中使用可变的变量的细节）。

*表13-3不可变的集合中特有的方法*

| 方法            | 描述 |
| --------------- | ---- |
| c1 ++ c2        |      |
| c :+ e          |      |
| c1 :++ c2       |      |
| e +: c          |      |
| c1 ++: c2       |      |
| e :: list       |      |
| list1 ::: list2 |      |
| c updated(i,e)  |      |

注意，像 **++** 和 **++=** 这样的符号方法名是方法的别名。例如，**++** 是 **concat** 的别名。要注意的是，对于大多数序列来说，方法 **-** 和 **--**
在几个版本之前就被废弃了，目前只在集合上可用。所以要使用表13-1中列出的过滤方法来返回一个新的集合，并删除所需的元素。

上表只列出了不可变集合上最常见的方法。还有其他的方法，比如 **-** 和 **--** 方法在不可变集合上是可用的。关于更多的方法，参考你正在使用集合的Scaladoc。

#### Maps

**Map**还有附加的方法，如表13-14所示。在这个表中，第一列符号的含义如下：

- **m**，**m1**，**m2**代表一个map。
- **mm**代表一个可变map。
- **k**，**k1**，**k2**代表一个map的键。
- **p**代表一个谓词（返回**true**或**false**的函数）。
- **v**，**v1**，**v2**代表一个map的值。
- **c**代表一个集合。

*表13-4可变和不可变map中常用的方法*

| Map方法                        | 描述 |
| ------------------------------ | ---- |
| **不可变Map的方法**            |      |
| m + (k->v)                     |      |
| m1 ++ m2                       |      |
| m ++ Seq(k1->v1, k2->v2)       |      |
| m - k                          |      |
| m - Seq(k1, k2, k3)            |      |
| m -- k<br/>m -- Seq(k1,k2)     |      |
| **可变Map的方法**              |      |
| mm(k) = v                      |      |
| mm += (k -> v)                 |      |
| mm ++= Map(k1 -> v1, k2 -> v2) |      |

| Map方法                         | 描述 |
| ------------------------------- | ---- |
| mm ++= List(k1 -> v1, k2 -> v2) |      |
| mm -= k                         |      |
| mm --= Seq(k1, k2, k3)          |      |
| **可变和不可变Map的方法**       |      |
| m(k)                            |      |
| m contains k                    |      |
| m filter p                      |      |
| m get k                         |      |
| m getOrElse(k, d)               |      |
| m isDefinedAt k                 |      |
| m keys                          |      |
| m keyIterator                   |      |
| m keySet                        |      |
| m values                        |      |
| m valuesIterator                |      |

你也可以用 **updatedWith** 和 **updateWith** 方法来更新**Map**的值，这两个方法分别适用于不可变和可变的Map。

更多的方法，参考可变map类的Scaladoc（ *https://oreil.ly/OwG1n* ）和不可变map类的Scaladoc（ *https://oreil.ly/X5LhZ* ）。

### 讨论

正如你所看到的，Scala集合类包含了大量的方法（以及看起来是操作符的方法）。理解这些方法可以帮助你提高工作效率，随着对它们的理解，你会写更少的代码和更少的循环，而是写短的函数和谓词来使用这些方法。

## 13.2 用foreach遍历一个集合

### 问题

用**foreach**方法迭代集合中的元素。

### 解决方案

为**foreach**方法提供一个函数，匿名函数或方法，以匹配**foreach**正在寻找的方法签名，同时也解决你的问题。

Scala序列上的**foreach**方法有这样的签名：

```
	def foreach[U](f: (A) => U): Unit
```

这意味着它需要一个函数作为方法的唯一的参数，并且该函数需要一个泛型**A**，并且不返回任何东西（**Unit**）。如果这是一个实际问题，**A**是集合中的类型，例如**Int**和**String**。

**foreach**的工作方式是，从集合中每次传入一个元素给函数，从第一个元素开始，到最后一个元素结束。你提供的函数可以对每个元素做任何希望它做的事情，尽管你的函数不能返回任何东西。(如果你想返回什么，请看**map**方法）。

举个例子，**foreach**的常见用法是输出信息，如**Vector[Int]** ：

```
	val nums = Vector(1, 2, 3)
```

你可以编写一个函数，接受**Int**参数而没有返回：

```
	def printAnInt(i: Int): Unit = println(i)
```

因为**printAnInt**与**foreach**要求的签名相匹配，你可以将它与**nums**和**foreach**一起使用：

```
    scala> nums.foreach(i => printAnInt(i))
    1
    2
    3
```

你也可以这样写这个表达式：

```
    nums.foreach(printAnInt(_))
    nums.foreach(printAnInt) // most common
```

最后一个例子显示了最常用的形式。

同样地，你也可以通过编写一个匿名函数传入**foreach**来解决这个问题。这些例子都与使用**printAnInt**函数相同：

```
    nums.foreach(i => println(i))
    nums.foreach(println(_))
    nums.foreach(println) // most common
```

#### Map上使用foreach

**foreach**在**Map**类上也可使用。**foreach**的**Map**实现有这样的签名：

```
    def foreach[U](f: ((K, V)) => U): Unit
```

这意味着它期望接收有两个参数（**K**和**V**，代表*key*和*value*）的函数，同时并返回**U**，代表**Unit**。因此，**foreach**向函数传入两个参数。你可以把这些参数当作一个元组来处理：

```
    val m = Map("first_name" -> "Nick", "last_name" -> "Miller")
    
    m.foreach(t => println(s"${t._1} -> ${t._2}")) // tuple syntax
```

你也可以使用这种方式：

```
    m.foreach {
        (fname, lname) => println(s"$fname -> $lname")
    }
```

参见14.9小节，“遍历Map”，了解遍历**Map**的其他方法。

#### 副作用 -- 鸽子栏

&nbsp; &nbsp; &nbsp; &nbsp;如上所示，**foreach**将函数作用于集合中的每个元素，但函数不需要返回值，**foreach**也不返回值。因为**foreach**
不返回任何东西。所以在逻辑上使用它必须有其他的原因，比如打印输出或修改其他变量。因此，有人说**foreach**，以及任何其他返回**Unit**的方法必须用于其副作用。因此，**foreach**是一个*statement*
，而不是一个*expression*。关于语句和表达式的更多细节，参考我的博客“A Note About Expression-Oriented Programming” （ *https://oreil.ly/UyODg* ） 。

### 讨论

在**foreach**使用多行函数，需要将函数用花括号包成为代码块，然后传入：

```
    val longWords = StringBuilder()
    
    "Hello world it’s Al".split(" ").foreach { e =>
        if e.length > 4 then longWords.append(s" $e")
        else println("Not added: " + e)
    }
```

在**REPL**中运行该代码，输出如下：

```
    Not added: it’s
    Not added: Al
    val longWords: StringBuilder = Hello world
```

### 另见

- 你可以使用**for**循环和**for**表达式来迭代集合中的元素，详见第4章。

## 13.3 使用迭代器

### 问题

想要（或需要）在Scala程序中使用一个迭代器。

### 解决方案

在Scala中使用迭代器，有些要点需要了解：

- 与Java的**while**循环不同，Scala开发者一般不会直接使用**Iterator**的**hasNext**和**next**方法。
- 出于性能方面的考虑，使用迭代器是有意义的，比如读取大文件时。
- 迭代器在使用后会被耗尽。
- 虽然迭代器不是集合，但它有常用的集合方法。
- 迭代器的转化器方法是惰性的。
- **Iterator**的子类**BufferedIterator**提供了**head**和**headOption**方法，可以查看下一个元素的值。

这些要点（和解决方案）将在下面小节中涵盖。

#### Scala开发者不会直接使用hasNext和next

尽管在Java中使用迭代器的 **hasNext()** 和 **next()** 是在遍历集合的常见方式，但Scala开发者通常不会直接使用这些方法。相反，会使用**map**，**filter**和**foreach**
等集合方法遍历集合，或者说**for**循环。说白了，只要我在Scala中有迭代器，我就从来没有直接写过这样的代码：

```
    val it = Iterator(1, 2, 3)

    // we don’t do this
    val it = collection.iterator
    while (it.hasNext) ...
```

相反，我这样写代码：

```
    val a = it.map(_ * 2)           // a: Iterator[Int] = <iterator>
    val b = it.filter(_ > 2)        // b: Iterator[Int] = <iterator>
    val c = for e <- it yield e*2   // c: Iterator[Int] = <iterator>
```

#### 性能原因导致迭代器有意义

虽然没有直接调用 **hasNext()** 和 **next()** 方法，但迭代器在Scala中是一个重要概念。例如，当你用**io.Source.fromFile**
方法读取一个文件时，它返回一个迭代器，使得一次从文件中读取一行。这是有意义的，因为将大的数据文件一次读入内存是不现实的。

迭代器也被用于*views*的转化器方法中，它是惰性的。例如*Programming in Scala* 一书展示了用迭代器来实现**lazyMap**函数：

```
    def lazyMap[T, U](coll: Iterable[T], f: T => U) =
        new Iterable[U] {
            def iterator = coll.iterator map f
    }
```

正如11.4小节，“在集合上创建惰性视图”中所示，在大集合上使用视图是提高性能的重要技巧。

#### 迭代器在使用后会被耗尽

使用迭代器的一个重要部分，需要知道耗尽在使用之后会耗尽（变为空）。当访问每个元素时，会改变迭代器（参考讨论），并且前面的元素会被丢弃。例如，如果你使用**foreach**来打印迭代器的元素，调用在第一次时就起作用了：

```
    scala> val it = Iterator(1,2,3)
    it: Iterator[Int] = nonempty iterator

    scala> it.foreach(print)
    123
```

当第二次尝试同样的调用时，将没有任何输出，因为迭代器已经耗尽了：

```
    scala> it.foreach(print)
    (no output here)
```

#### 迭代器的行为像集合

从技术上讲，迭代器不是集合。相反，它提供了可以逐个访问集合中元素的方法。但在迭代器又确实定义了许多在常用集合类中看到的方法，如**foreach**，**map**，**filter**等。你也可以在需要时将迭代器转换为集合：

```
    val i = Iterator(1,2,3) // i: Iterator[Int] = <iterator>
    val a = i.toVector      // a: Vector[Int] = Vector(1, 2, 3)

    val i = Iterator(1,2,3) // i: Iterator[Int] = <iterator>
    val b = i.toList        // b: List[Int] = List(1, 2, 3)
```

#### 迭代器是惰性的

另一个重要的点是，迭代器是惰性的，意味着它们的转换器方法以一种非严格或惰性的方式进行计算。例如，下面的**for**循环，**map**和**filter**方法并不返回具体的结果，而只返回一个迭代器：

```
    val i = Iterator(1,2,3)         // i: Iterator[Int] = <iterator>

    val a = for e <- i yield e*2    // a: Iterator[Int] = <iterator>
    val b = i.map(_ * 2)            // b: Iterator[Int] = <iterator>
    val c = i.filter(_ > 2)         // c: Iterator[Int] = <iterator>
```

像其他惰性方法一样，它们仅仅在需要时才会被计算，例如调用严格方法**foreach**：

```
    scala> i.map(_ + 10).foreach(println)
    11
    12
    13
```

#### BufferedIterator允许你提前查看元素

缓冲迭代器也是一种迭代器，它允许你在不向前移动迭代器的情况下查看下一个元素。可以通过调用**Iterator**的**buffered**方法创建**BufferedIterator**。

```
    val it = Iterator(1,2)  // it: Iterator[Int] = <iterator>
    val bi = it.buffered    // bi: BufferedIterator[Int] = <iterator>
```

随后在**BufferedIterator**上调用**head**方法，这不会影响迭代器：

```
    // call 'head' as many times as desired
    bi.head // 1
    bi.head // 1
    bi.head // 1
```

另一方面，注意到在**Iterator**或**BufferedIterator**上调用**next**方法时会发生什么：

```
    // 'next' advances the iterator
    bi.next // 1
    bi.next // 2
    bi.next // java.util.NoSuchElementException: next on empty iterator
```

#### 小心调用head方法 -- 耗子栏

&nbsp; &nbsp; &nbsp; &nbsp;正如13.1小节中所讨论的，你通常想用 **headOption** 而不是 **head**，因为如果在空列表上调用它，或者在列表的末尾调用它， **head** 方法会抛出异常。

```
    // create a one-element BufferedIterator
    val bi = Iterator(1).buffered
    	// result: BufferedIterator[Int] = <iterator>

    // 'head' works fine
    bi.head			// 1

    // advance the iterator
    bi.next 		// 1
    bi.headOption	// None (headOption works as intended)

    // 'head' blows up
    bi.head
        // result: java.util.NoSuchElementException:
        // next on empty iterator
```

### 讨论

从概念上讲，迭代器就像指针。当你在列表上创建迭代器时，它最初指向列表的第一个元素：

```
    val x = 1 :: 2 :: Nil
            ^
```

然后当你调用迭代器的**next**方法时，它会指向集合中的下一个元素：

```
    val x = 1 :: 2 :: Nil
                 ^
```

最后，当迭代器到达集合的末尾时，它被认为已经耗尽。不会再回到指向第一个元素的位置：

```
    val x = 1 :: 2 :: Nil
                       ^
```

如解决方案中所示，此时调用**next**或**head**将抛出异常**java.util.NoSuchElementException**。

### 另见

- Scala迭代器介绍。（ *https://oreil.ly/oFiiQ* ）
- Iterator的Scaladoc。（ *https://oreil.ly/VPzWO* ）
- BufferedIterator的Scaladoc。（ *https://oreil.ly/w7IQt* ）
- 11.4小节，“在集合上创建惰性视图”，有更多关于视图，迭代器和性能的内容。

## 13.4 使用zipWithIndex或者zip创建循环计数器

### 问题

循环一个序列集合，并且要能够访问循环计数器，而不用手动创建一个计数器。

### 解决方案

用**zipWithIndex**或者**zip**方法创建一个计数器，假设你有一个字符列表：

```
	val chars = List('a', 'b', 'c')
```

使用计数器打印列表中的元素，一种方法是使用**zipWithIndex**、**foreach**和花括号中的**case**语句：

```
    chars.zipWithIndex.foreach {
        case (c, i) => println(s"character '$c' has index $i")
    }

    // output:
    character 'a' has index 0
    character 'b' has index 1
    character 'c' has index 2
```

正如你将在讨论中所见，这个解决方案之所以有效，因为**zipWithIndex**返回一系列由双元素元组（tuple-2）组成的序列，如下：

```
	List((a,0), (b,1), ...
```

也是因为代码块中的**case**语句匹配了一个tuple-2。**foreach**将tuple-2传递给你的算法，你也可以这么写：

```
    chars.zipWithIndex.foreach { t =>
    	println(s"character '${t._1}' has index ${t._2}")
    }
```

最后，也可以使用**for**循环：

```
    for
    	(c, i) <- chars.zipWithIndex
    do
    	println(s"character '$c' has index $i")
```

所有的循环都有相同的输出。

#### 用zip控制起始值

当使用**zipWithIndex**时，计数器总是从0开始。如果你想控制起始值，使用**zip**：

```
    for (c, i) <- chars.zip(LazyList from 1) do
    	println(s"${c} is #${i}")
```

循环输入如下：

```
    a is #1
    b is #2
    c is #3
```

### 讨论

当在序列中使用**zipWithIndex**时，它返回一个tuple-2元素的序列。例如，给定一个**List[Char]**，你可以看到**zipWithIndex**产生的是很多tuple-2值：

```
    scala> val chars = List('a', 'b', 'c')
    val chars: List[Char] = List(a, b, c)

    scala> val zwi = chars.zipWithIndex
    val zwi: List[(Char, Int)] = List((a,0), (b,1), (c,2))
```

#### 在花括号中使用case语句

如解决方案中所示，你可以在花括号内使用**case**语句和**foreach**：

```
    chars.zipWithIndex.foreach {
    	case (c, i) => println(s"character '$c' has index $i")
    }
```

这种方法可以用在任何需要使用函数字面的地方。在其他情况下，你可以根据需要使用尽可能多的**case**选项。

在Scala 2.13之前，这个例子只能用**case**关键字来写，但在Scala 2.13及以上版本中，这行代码可以用下面任何一种方式来写：

```
    case(c, i) => println(s"character '$c' has index $i") // shown previously
    case(c -> i) => println(s"character '$c' has index $i") // alternate
    (c, i) => println(s"character '$c' has index $i") // without the 'case'
```

#### 使用惰性视图

因为**zipWithIndex**从一个已有的序列中创建了一个新的序列，你可能会想在调用**zipWithIndex**之前调用view方法，尤其是大的序列：

```
    scala> val zwi2 = chars.view.zipWithIndex
    zwi2: scala.collection.View[(Char, Int)] = View(<not computed>)
```

正如11.4小节，“在集合上创建惰性视图”中所讨论的，这将在**char**上创建惰性视图，这意味着：

- 没有创建中间的序列。
- 需要时元组元素才会被创建，尽管在循环的情况下，通常是需要的，除非你的算法包含终止或异常。

因为使用**view**可以避免创建中间的集合，在**zipWithIndex**之前调用**view**有助于在大集合上循环。通常当性能是一个问题时，使用或不使用视图测试你的代码。

## 13.5 用map实现集合的转换

### 问题

就像上小节一样，把原始集合中的每个元素通过算法转换成另一个集合。

### 解决方案

与其像4.4小节“用for/yield从现有集合创建一个新的集合”中展示的那样使用**for/yield**组合，不如在你的集合上调用**map**方法，传参一个函数、一个匿名函数或者一个方法来转换每个元素。这些例子显示了如何使用匿名函数：

```
    val a = Vector(1,2,3)
    
    // add 1 to each element
    val b = a.map(_ + 1)        // b: Vector(2, 3, 4)
    val b = a.map(e => e + 1)   // b: Vector(2, 3, 4)
    
    // double each element
    val b = a.map(_ * 2)        // b: Vector(2, 4, 6)
    val b = a.map(e => e * 2)   // b: Vector(2, 4, 6)
```

下面例子展示了使用函数（或方法）：

```
    def plusOne(i: Int) = i + 1
    val a = Vector(1,2,3)
    
    // three ways to use plusOne with map
    val b = a.map(plusOne)          // b: Vector(2, 3, 4)
    val b = a.map(plusOne(_))       // b: Vector(2, 3, 4)
    val b = a.map(e => plusOne(e))  // b: Vector(2, 3, 4)
```

#### 编写一个使用map的方法

当编写使用map的方法时：

- 方法的参数是和集合类型相同的单个输入参数。
- 方法的返回类型可以是你需要的任何类型。

例如，假设有一个可以被转换为整数的字符串列表：

```
	val strings = List("1", "2", "hi mom", "4", "yo")
```

你可以用**map**将字符串列表转换为整数列表。首先需要一个方法，(a)接收一个**String**，(b)返回一个**Int**。例如，作为示例方法的第一步，如果你想确定列表中每个字符串的长度，**lengthOf**方法就可以了：

```
    def lengthOf(s: String): Int = s.length
    val x = strings.map(lengthOf) // x: List(1, 1, 6, 1, 2)
```

然而，因为我真的想把每个字符串转换为整数，但因为有些字符串不能转换为整数，我真正需要的是一个返回**Option[Int]**的函数：

```
    import scala.util.Try
    def makeInt(s: String): Option[Int] = Try(Integer.parseInt(s)).toOption
```

当给定字符串**"1"**时，方法返回**Some(1)**，而当给定字符串**"yo"**时，返回**None**。

现在可以使用**makeInt**和**map**将列表中的每个字符串转换为整数。第一次尝试返回一个**Option[Int]**的**List**，即**List[Option[Int]]**类型。

```
    scala> val intOptions = strings.map(makeInt)
    val intOptions: List[Option[Int]] = List(Some(1), Some(2), None, Some(4), None)
```

一旦你知道了集合可用的方法，你可以将**List[Option[Int]]**扁平化为**List[Int]**。

```
    scala> val ints = strings.map(makeInt).flatten
    val ints: List[Int] = List(1, 2, 4)
```



### 讨论

当我第一次接触Scala时，我的背景是Java，所以我最初写了**for/yield**循环。这是我所熟悉的命令式的解决方案。但最终我意识到，**map**就像没有任何保护的**for/yield**表达式一样，只有一个生成器。

```
    val list = List("a", "b", "c")                  // list: List(a, b, c)
    
    // map
    val caps1 = list.map(_.capitalize)              // caps1: List(A, B, C)
    
    // for/yield
    val caps2 = for e <- list yield e.capitalize    // caps2: List(A, B, C)
```

当明白这一点后，我就开始使用**map**。

这是关于Scala集合类中许多函数方法的一个关键概念：像**map**，**filter**，**take**等方法都是自定义**for**循环的替代方法。使用这些内置函数方法有很多好处，但两个重要的好处是：

- 你不需要写自定义的**for**循环。
- 你不需要阅读其他开发者编写的自定义**for**循环。

我并不是说这些话是刻薄的评论，相反，我的意思是说**for**循环需要大量的模板代码，你必须阅读这些代码才能找到自定义算法的意图。当你使用Scala集合内置的方法时，会更容易看到这个意图。

有一个小例子，给定下面的列表：

```
	val fruits = List("banana", "peach", "lime", "pear", "cherry")
```

满足（a）找到所有长度超过两个字符和（b）长度少于六个字符的字符串，然后（c）将剩下的这些字符串大写，命令式的解决方案看起来像这样：

```
    val newFruits = for
        f <- fruits
        if f.length < 6
        if f.startsWith("p")
    yield f.capitalize
```

由于Scala的语法，这并不难读，但至少要注意两件事：

- 你必须明确地写出 **f <- fruits**，即”for each fruit in fruits“。
- 算法的一部分在**for**表达式内，另一部分在**yield**关键字之后。

相反，对于同样的问题，Scala的常用解决方案是这样的：

```
    val newFruits = fruits.filter(_.length > 2)
                          .filter(_.startsWith("p"))
                          .map(_.capitalize)
```

即使在这样的一个小例子中，可以看到编写（a）是你想要的，而不是（b）一步步的命令式算法来得到你想要的东西。一旦了解了如何使用Scala集合方法，你会发现可以更多地关注意图，而不是编写自定义**for**循环的细节，代码将变得简洁，但是可读性仍然很好—这就是我们所说的*expressive*。

#### 把map当成transform  -- 耗子栏

当我刚开始使用Scala和**map**方法的时候，我发现每次输入**map**时说成**transform**会很有帮助。也就是说，我希望这个方法被命名为**transform**而不是**map**：

```
    fruits.map(_.capitalize)        // what it’s named
    fruits.transform(_.capitalize)  // what i wish it was named
```

这是因为**map**将函数应用于初始列表中的每个元素，并将这些元素转换为一个新的列表。

（正如我在博客“The ‘Great FP Terminology Barrier‘ ”（ **https://oreil.ly/UX2rJ** ）中所解释的。**map**的名字来自于数学领域）。

## 13.6 用flatten对列表进行扁平化处理

### 问题

### 解决方案

### 讨论

## 13.7 用flilter对列表进行过滤

### 问题

### 解决方案

### 讨论

###        

## 13.8 从集合中提取元素序列

### 问题

从集合中提取元素序列，可以通过指定一个起始位置和长度实现，也可以通过一个函数实现。

### 解决方案

这里有一些集合方法，这些方法可以从集合里提取元素序列，包括**drop**，**dropWhile**，**head**，**headOption**，**init**，**last**，**lastOption**，**slice**，**tail**，**take**，和**takeWhile**。

给定下面**Vector**：

```
	val x = (1 to 10).toVector
```

**drop**方法从序列的开始删除指定的元素数量：

```
	val y = x.drop(3)           // y: Vector(4, 5, 6, 7, 8, 9, 10)
```

**dropRight**方法和**drop**方法一样，但是从集合的结尾处开始向前删除元素：

```
	val y = x.dropRight(4)      // y: Vector(1, 2, 3, 4, 5, 6)
```

**dropWhile**方法会删除让谓词为真的元素：

```
	val y = x.dropWhile(_ < 6)  // y: Vector(6, 7, 8, 9, 10)
```

**take**方法从序列中提取前N个元素：

```
	val y = x.take(3)           // y: Vector(1, 2, 3)
```

**takeRight**和**take**工作方式相同，但从序列的末端提取元素：

```
	val y = x.takeRight(3)      // y: Vector(8, 9, 10)
```

**takeWhile**返回让谓词为真的元素：

```
	val y = x.takeWhile(_ < 5)  // y: Vector(1, 2, 3, 4)
```

#### 性能说明    -- 耗子图

&nbsp; &nbsp; &nbsp; &nbsp;由于**List**类的构造方式，像**dropRight**和**takeRight**这样的方法在**List**这样的线性序列上执行得很慢。如果你需要对大的序列使用这些方法，使用像**Vector**这样的索引序列来代替。

**slice(from, until)** 返回从**from**到**until**下标的序列，不包括**until**，可以认为是基于**0**的下标：

```
    val chars = Vector('a', 'b', 'c', 'd')
    
    chars.slice(0,1) // Vector(a)
    chars.slice(0,2) // Vector(a, b)
    
    chars.slice(1,1) // Vector()
    chars.slice(1,2) // Vector(b)
    chars.slice(1,3) // Vector(b, c)
    
    chars.slice(2,3) // Vector(c)
    chars.slice(2,4) // Vector(c, d)
```

所有这些方法都提供了另一种过滤序列的方法，很明显的特点是它们返回连续的元素序列。

### 讨论

其实还有更多可以用的方法。给定一个列表：

```
	val nums = Vector(1, 2, 3, 4, 5)
```

以下表达式后面的注释展示了每个方法返回的值：

```
    nums.head       // 1
    nums.headOption // Some(1)
    nums.init       // Vector(1, 2, 3, 4)
    
    nums.tail       // Vector(2, 3, 4, 5)
    nums.last       // 5
    nums.lastOption // Some(5)
```

一般来说，这些方法的工作方式从它们的名字中就可以看出来，但有两个可能需要解释一下，那就是**init**和**tail**。**init**方法返回序列中除了最后一个元素外的所有元素，**tail**方法返回除了第一个元素外的所有元素。

需要注意的是，**head**、**init**、**tail**和**last**会在空序列上抛出**java.lang.UnsupportedOperationException**异常。在函数式编程中，纯函数是*total* -- 意味着它对每个输入都有定义，并且不抛出异常，因此纯函数式程序员通常不使用这些方法。当他们使用时，会仔细检查序列是否为空。

## 13.9 将序列拆分成子集

### 问题

### 解决方案

### 讨论

## 13.10 用reduce和fold方法遍历集合

### 问题

### 解决方案

### 讨论

### 另见

## 13.11 从序列中查找不重复的元素

### 问题

你有一个包含重复元素的序列，你想移除重复的元素，只留下唯一的元素。

### 解决方案

可以调用序列的**distinct**方法，也可以调用**toSet**。

```
    val x = Vector(1, 1, 2, 3, 3, 4)
    val y = x.distinct // Vector(1, 2, 3, 4)
    val z = x.toSet // Set(1, 2, 3, 4)
```

这两种方法都会返回一个新的序列，并删除重复的值，但是**distinct**返回与开始时相同的序列类型，而**toSet**会返回一个**Set**。

### 讨论

要在自己的类中使用这些方法，需要实现**equals**和**hashCode**方法。例如，样例类为你实现了这些方法，所以你可以将**Person**类与**distinct**一起使用：

```
    case class Person(firstName: String, lastName: String)
    
    val dale1 = Person("Dale", "Cooper")
    val dale2 = Person("Dale", "Cooper")
    val ed = Person("Ed", "Hurley")
    val list = List(dale1, dale2, ed)
    
    // correct solution: only one Dale Cooper appears in this result:
    val uniques = list.distinct // List(Person(Dale,Cooper), Person(Ed,Hurley))
    val uniques = list.toSet    // Set(Person(Dale,Cooper), Person(Ed,Hurley))
```

如果你不想使用样例类，参考5.9小节，“定义euqals方法（对象等价）”，讨论了如何实现**equals**和**hashCode**方法。

## 13.12 合并序列集合

### 问题

### 解决方案

### 讨论

## 13.13 随机化序列

### 问题

你想随机化（shuffle）一个现有的序列，或者从序列中获得一个随机元素。

### 解决方案

要随机化一个序列，需要导入**scala.util.Random**，然后将其**shuffle**方法应用于现有的序列，同时将结果分配给一个新的序列：

```
    import scala.util.Random
    
    // List
    val xs = List(1,2,3,4,5)
    val ys = Random.shuffle(xs)                     // 'ys' will be shuffled, like List(4,1,3,2,5)
    
    // also works with other sequences
    val x = Random.shuffle(Vector(1,2,3,4,5))       // x: Vector(5,3,4,1,2)
    val x = Random.shuffle(Array(1,2,3,4,5))        // x: mutable.ArraySeq(1,3,2,4,5)
    
    import scala.collection.mutable.ArrayBuffer
    val x = Random.shuffle(ArrayBuffer(1,2,3,4,5))  // x: ArrayBuffer(4,2,3,1,5)
```

与函数式方法一样，这个解决方案的关键是知道**shuffle**不会随机化给定的列表。相反，它返回一个已经随机化了（**shuffled**）的新列表。

### 讨论

当你想对整个列表进行随机化时，这个解决方案非常有效。但如果你只想从列表中获得一个随机元素，下面的方法会更有效：

```
    import scala.util.Random
    
    // throws an IllegalArgumentException if `seq` is empty
    def getRandomElement[A](seq: Seq[A]): A =
        seq(Random.nextInt(seq.length))
```

只要你传入的序列至少包含一个元素，函数就能工作。它的工作原理是 **nextInt** 返回一个介于 **0**（包括）和 **seq.length**（不包括）之间的值。因此，如果序列包含100个元素，**nextInt**返回一个介于**0**和**99**之间的值，这与序列的索引相匹配。

现在只要你有一个序列，就可以用这个函数从序列中获取一个随机元素：

```
    val randomNumber = getRandomElement(List(1,2,3))
    val randomString = getRandomElement(List("a", "b", "c"))
```



## 13.14 集合排序

### 问题

你想（a）对一个序列集合进行排序，（b）在一个自定义类中实现**Ordered**特质，这样可以用排序方法，或者像 **<**，**<=**，**>** 和 **>=** 操作符去比较类的实例，（c）在排序时使用隐式或显式的**Ordering**。

### 解决方案

参考12.11小节，“对数组进行排序”，了解如何对数组进行排序。否则使用**sorted**，**sortWith**或**sortBy**方法来对不可变的序列进行排序，而 **sortInPlace**，**sortInPlaceWith**和**sortInPlaceBy**来对可变序列进行排序。 你可以根据自己需要实现**Ordered**或**Ordering**特质。

#### 不可变序列使用sorted，sortWith和sortBy

序列上的**sorted**方法可以对**Double**，**Int**，**String**以及其他任何具有隐式**scala.math.Ordering**类型的集合进行排序：

```
    List(10, 5, 8, 1, 7).sorted         // List(1, 5, 7, 8, 10)
    List("dog", "mouse", "cat").sorted  // List(cat, dog, mouse)
```

**sortWith**方法可以自己写排序算法。下面的例子展示如何对一个**String**或**Int**的序列进行两个方向的排序：

```
    // short form: sorting algorithm uses '_' references
    Vector("dog", "mouse", "cat").sortWith(_ < _)   // Vector(cat, dog, mouse)
    Vector("dog", "mouse", "cat").sortWith(_ > _)   // Vector(mouse, dog, cat)
    // long form: sorting algorithm uses a tuple-2
    Vector(10, 5, 8, 1, 7).sortWith((a,b) => a < b) // Vector(1, 5, 7, 8, 10)
    Vector(10, 5, 8, 1, 7).sortWith((a,b) => a > b) // Vector(10, 8, 7, 5, 1)
```

排序函数接收两个参数，简单或复杂看你需要。如果排序函数较长，首先可以把它声明成一个方法：

```
    def sortByLength(s1: String, s2: String): Boolean =
        println(s"comparing $s1 & $s2")
        s1.length > s2.length
```

然后传入**sortWith**方法：

```
    scala> val a = List("dog", "mouse", "cat").sortWith(sortByLength)
    comparing mouse & dog
    comparing cat & mouse
    comparing mouse & cat
    comparing cat & dog
    comparing dog & cat
    a: List[String] = List(mouse, dog, cat)
```

根据Scaladoc，**sortBy**方法“排序序列，根据转换函数转换隐式given **Ordering**而产生的**Ordering**”。**List**的**sortBy**签名看起来像这样：

```
    def sortBy[B](f: (A) => B)(implicit ord: Ordering[B]): List[A]
```

下面有几个使用**sortBy**进行排序的例子：

```
    val a = List("peach", "apple", "pear", "fig")
    val b = a.sortBy(s => s.length)             // b: List(fig, pear, peach, apple)
    
    // the Scaladoc shows an example like this that works “because scala.Ordering
    // will implicitly provide an Ordering[Tuple2[Int, Char]]”
    val b = a.sortBy(s => (s.length, s.head))   // b: List(fig, pear, apple, peach)
    
    // a way to sort from the longest to the shortest string, and then
    // by the string
    val a = List("fin", "fit", "fig", "pear", "peas", "peach", "peat")
    val b = a.sortBy(s => (-s.length, s))
    // b: List(peach, pear, peas, peat, fig, fin, fit)
```

#### 可变序列使用sortInPlace，sortInPlaceWith和sortInPlaceBy

像**ArrayBuffer**这样的可变序列，你可以使用**sortInPlace**，**sortInPlaceWith**和**sortInPlaceBy**方法。如果序列中的数据类型支持隐式**Ordering**或实现**Ordered**来排序，**sortInPlace**是一个直接的解决方案：

```
    import scala.collection.mutable.ArrayBuffer
    
    val a = ArrayBuffer(3,5,1)
    a.sortInPlace   // a: ArrayBuffer(1, 3, 5)
    
    val b = ArrayBuffer("Mercedes", "Hannah", "Emily")
    b.sortInPlace   // b: ArrayBuffer(Emily, Hannah, Mercedes)
```

**sortInPlaceWith**和**sortWith**类似：

```
    import scala.collection.mutable.ArrayBuffer
    val a = ArrayBuffer(3,5,1)
    a.sortInPlaceWith(_ < _)    // a: ArrayBuffer(1, 3, 5)
    a.sortInPlaceWith(_ > _)    // a: ArrayBuffer(5, 3, 1)
```

**sortInPlaceBy**的工作方式与**sortBy**类似，可以指定一个函数来排序：

```
    import scala.collection.mutable.ArrayBuffer
    val a = ArrayBuffer("kiwi", "apple", "fig")
    a.sortInPlaceBy(_.length)   // a: ArrayBuffer(fig, kiwi, apple)
```

### 讨论

下面的讨论展示了如何在*immutable*序列中使用**Ordering**和**Ordered**，讨论也适用于*mutable*序列。

#### 有隐式的Ordering

如果一个序列所持有的类型缺少隐式**Ordering**，将无法用**sorted**方法排序。例如，下面这个**Person**类和**List[Person]**：

```
    class Person(val name: String):
    	override def toString = name
    	
    val dudes = List(
        Person("Bill"),
        Person("Al"),
        Person("Adam")
    )
```

如果试图在 **REPL** 中对这个列表进行排序，你会看到一个错误，**Person**类没有隐式**Ordering**：

```
    scala> dudes.sorted
    1 |dudes.sorted
      |           ^
      |           No implicit Ordering defined for B
      |           where: B is a type variable with constraint >: Person
      |           I found:
      |               scala.math.Ordering.ordered[A](/* missing
      |               */summon[scala.math.Ordering.AsComparable[B]])
      |           But no implicit values were found that match type
      |           scala.math.Ordering.AsComparable[B].
```

所以你不能排序**Person**类，解决方案是写一个匿名函数，使用**sortWith**对**Person**元素的**name**字段进行排序：

```
    dudes.sortWith(_.name < _.name) // List(Adam, Al, Bill)
    dudes.sortWith(_.name > _.name) // List(Bill, Al, Adam)
```

#### 给sorted提供一个显示的Ordering

如果你的类没有隐式**Ordering**，解决方案是提供一个显式的**Ordering**。例如，在默认情况下，下面**Person**类没有提供任何关于如何排序的信息：

```
    class Person(val firstName: String, val lastName: String):
    	override def toString = s"$firstName $lastName"
```

所以试图用**sorted**对列表中的**Person**实例排序是不行，正如刚才所展示的：

```
    val peeps = List(
        Person("Jessica", "Day"),
        Person("Nick", "Miller"),
        Person("Winston", "Bishop")
    )
    
    scala> peeps.sorted
    1 |peeps.sorted
      |           ^
      |No implicit Ordering defined for B ... (long error message) ...
```

一个解决方案是给**Person**创建一个显示的**Ordering**：

```
    object LastNameOrdering extends Ordering[Person]:
        def compare(a: Person, b: Person) = a.lastName compare b.lastName
```

现在使用**LastNameOrdering**结合**sorted**，排序如愿所偿：

```
    scala> val sortedPeeps = peeps.sorted(LastNameOrdering)
        val sortedPeeps: List[Person] = List(Winston Bishop, Jessica Day, Nick Miller)
```

这个解决方案是可行的，因为（a）**sorted**被定义为接收一个隐式**Ordering**参数：

```
    def sorted[B >: A](implicit ord: Ordering[B]): List[A]
                        -------------------------
```

并且（b）显示提供该参数：

```
val sortedPeeps = peeps.sorted(LastNameOrdering)
							   ----------------
```

另一种解决方案是用**implicit**关键字声明**LastNameOrdering**，然后调用**sorted**：

```
    implicit object LastNameOrdering extends Ordering[Person]:
        def compare(a: Person, b: Person) = a.lastName compare b.lastName
    
    val sortedPeeps = peeps.sorted
        // sortedPeeps: List(Winston Bishop, Jessica Day, Nick Miller)
```

在这个解决方案中，因为**LastNameOrdering**通过**implicit**关键字定义的，所以它被神奇地拉进来，用作**sorted**正在寻找的隐式**Ordering**参数。

#### 混入Ordered特质来排序

如果你想使用带有**sorted**方法的**Person**类，另一个解决方案是将**Ordered**特质混入**Person**，然后实现**Ordered**特质的抽象**compare**方法。下面代码展示了这种技术：

```
    class Person(var name: String) extends Ordered[Person]:
        override def toString = name
            // return 0 if the same, negative if this < that, positive if this > that
            def compare(that: Person): Int =
                // depends on the definition of `==` for String
                if this.name == that.name then
                    0
                else if this.name > that.name then
                    1
                else
                    -1
```

现在，**Person**类可以通过**sorted**排序：

```
    val dudes = List(
        Person("Bill"),
        Person("Al"),
        Person("Adam")
    )
    
    val x = dudes.sorted // x: List(Adam, Al, Bill)
```

**Ordered**中的**compare**方法是抽象方法，所以需要在自己的类中实现它，从而提供排序能力。下面的说明展示了**compare**方法是如何工作的：

- 对象相等返回**0**（你可以随意自定义相等，但通常使用类的**equals**方法）。

- **this**比**that**小，返回负值。
- **this**比**that**大，返回正值。

如何确定一个实例是否大于另一个实例，完全取决于你的**compare**算法。

注意因为这种**compare**算法只对两个**String**值进行比较，所以可以这样写：

```
    def compare (that: Person) = this.name.compare(that.name)
```

然而，我按照第一个例子中的写法来写，可以更加清楚地了解这个方法。

在类中混入**Ordered**特质的一个额外好处是，可以在代码中直接比较对象实例：

```
    val bill = Person("Bill")
    val al = Person("Al")
    val adam = Person("Adam")
    
    if adam > bill then println(adam) else println(bill)
```

这是因为**Ordered**特质实现了 **<=**，**<** ， **>** ，和 **>=** 方法，它们调用**compare**方法来进行比较。

### 另见

要了解更多内容，**Ordered**和**Ordering** 的Scaladoc很棒，有些不错的例子。

- Ordering特质（ *https://oreil.ly/HtYQn* ）
- Ordered特质 （ *https://oreil.ly/zrsEx* ）

## 13.15 通过mkString和addString将集合转换成字符串

### 问题

把集合的元素转成一个字符串，很可能是添加一个字段分隔符、前缀和后缀。

### 解决方案

使用**mkString**或**addString**方法，将集合打印成一个**String**。

#### mkString

给定一个简单的集合：

```
	val x = Vector("apple", "banana", "cherry")
```

你可以使用**mkString**将元素转换为一个**String**：

```
	x.mkString // "applebananacherry"
```

看起来并不是很有用，所以加一个分隔符：

```
    x.mkString(" ")     // "apple banana cherry"
    x.mkString("|")     // "apple|banana|cherry"
    x.mkString(", ")    // "apple, banana, cherry"
```

**mkString**被重载了，所以你可以在创建一个字符串时添加前缀和后缀：

```
	x.mkString("[", ", ", "]") // "[apple, banana, cherry]"
```

**Map**类上也有一个**mkString**方法:

```
    val a = Map(1 -> "one", 2 -> "two")
    a.mkString                      // "1 -> one2 -> two"
    a.mkString("|")                 // "1 -> one|2 -> two"
    a.mkString("| ", " | ", " |")   // "| 1 -> one | 2 -> two |"
```

#### addString

从Scala 2.13开始，新的**addString**方法类似于**mkString**，但可以让你用序列的内容填充一个可变的**StringBuilder**。和**mkString**一样，你可以单独使用**addString**，也可以使用一个分隔符，还可以使用开始，结束和分隔符：

```
    val x = Vector("a", "b", "c")
    
    val sb = StringBuilder()
    val y = x.addString(sb)         // y: StringBuilder = abc
    
    val sb = StringBuilder()
    val y = x.addString(sb , ", ")  // y: StringBuilder = "a, b, c"
    
    val sb = StringBuilder()
    val y = x.addString(
    sb,     // StringBuilder
    "[",    // start
    ", ",   // separator
    "]"     // end
    )
    
    // result of the last expression:
    y: StringBuilder = [a, b, c]
    y(0) // Char = '['
    y(1) // Char = 'a'
```

因为该技术使用的是**StringBuilder**而不是**String**，所以它在处理大数据集时会更快。（通常总是测试任何与性能相关的问题。）

### 讨论

用这些技术创建的字符串是基于序列中元素的字符串表示，也就是说，通过调用**toString**方法得到的字符串。因此，该技术对字符串和整数这样的类型很有效，但如果你有一个简单的类，但没有实现**toString**方法的**Person**类，然后把**Person**放到**List**中，此时得到的字符串不会很有用：

```
    class Person(val name: String)
    val xs = List(Person("Schmidt"))
    xs.mkString // Person@1b17b5cb (not a useful result)
```

为了解决这个问题，需要在类中实现**toString**方法：

```
    class Person(val name: String):
        override def toString = name
        
    List(Person("Schmidt")).mkString    // "Schmidt"
```

#### 从重复字符创建字符串

稍微说明下，你可以通过下面技术用**Char**或**String**填充一个序列：

```
	val list = List.fill(5)('-')          // List(-, -, -, -, -)
```

然后你可以把这个列表转换为一个**String**：

```
	val list = List.fill(5)('-').mkString // "-----"
```

我曾用这种方法为一个句子生成下划线，比如当我知道一个句子的长度是10个字符时，就会创建10个下划线字符。但更简单的技术是把所需的字符串相乘，从而创建一个字符串，如下所示：

```
	"\u2500" * 10 // String = ──────────
```

关于这些技术，我在“Scala Functions to Repeat a Character n Times (Blank Padding)”（ *https://oreil.ly/tYC5y* ）有更多介绍。
