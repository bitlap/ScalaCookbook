# 13 集合：常见序列方法

前两章主要关注序列类，本章主要关注常用的序列方法。深入研究这些小节前，当使用集合类方法时，需要了解一些重要的概念：

- 谓词
- 匿名函数
- 隐式循环

## 谓词

*predicate*是一个方法、函数或匿名函数。接收一个或多个输入参数并返回**Boolean**值。 下面方法返回 **true** 或 **false**，所以是一个谓词：

```
    def isEven(i: Int): Boolean =
        i % 2 == 0
```

谓词是一个简单的概念，使用集合方法时，会经常听到这个术语，所以有必要提及。

## 匿名函数

匿名函数的概念也很重要。在10.1小节“使用函数字面量(匿名函数)”中有深入的描述，作为一个简单的例子，下面代码展示了完整的匿名函数，与 **isEven** 方法做同样的工作：

```
    (i: Int) => i % 2 == 0
```

简写如下：

```
    _ % 2 == 0
```

看起来并不多，但当它与集合上的**filter**方法结合在一起时，一小段代码就会发挥很大的作用：

```
    scala> val list = List.range(1, 10)
    list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
    
    scala> val events = list.filter(_ % 2 == 0)
    events: List[Int] = List(2, 4, 6, 8)
```

## 隐式循环

**filter**方法是第三个话题的一个很好的例子：*implied loops*。正如你从上面例子中看到的，**filter**包含一个循环，将你的函数使用在集合中的每个元素，并返回一个新的集合。你可以不使用**filter**
方法，而写出下面等价代码：

```
    for
        e <- list
        if e % 2 == 0
    yield
        e
```

我认为你会赞同，**filter**方法既更简洁，也更容易阅读。

像**filter**、**foreach**、**map**、**reduceLeft**等集合方法都在其算法中内置了循环。由于这些内置的方法，在编写Scala代码时，你会比其他语言少写很多自定义的**for**循环。

## 本章中的小节

虽然序列类有一百多个内置的方法，但本章的小节主要集中在最常用的方法上，包括：

- **filter**，允许你用一个给定的谓词来过滤集合。
- **map**，允许你对集合中的每个元素应用一个转换函数。
- 提取序列和现有序列子集的方法。
- 寻找序列中唯一元素的方法。
- 合并和压缩序列的方法。
- 随机化和排序序列的方法。
- 将序列转换为字符串的两个方法。

这些功能（以及更多的功能）将在下面的小节中展示。

## 13.1 选择集合方法解决问题

### 问题

Scala集合里有大量的方法可用，需要选择其中一个来解决一个问题。

### 解决方案

Scala集合类提供了丰富的用来操作数据的方法。绝大多数方法以一个函数或者谓词作为参数。

可用的方法在本节中会以两种方式列出。接下来的几段中，方法按类别划分，从而使你方便找到所需要的。然后在后面的表格中，还会有简单的描述和方法签名。

#### 按类别划分的方法

##### 过滤方法

可以用来过滤一个集合的方法，包括**collect**，**diff**，**distinct**，**drop**，**dropRight**，**dropWhile**，**filter**，**filterNot**，**
filterInPlace**，**find**，**foldLeft**，**foldRight**，**head**，**headOption**，**init**，**intersect**，**last**，**
lastOption**，**slice**，**tail**，**take**，**takeRight**，**takeWhile**和**union**。

##### 转换方法

转化器方法至少需要一个输入集合来创建一个新的输出集合，通常使用你提供的算法。包括 **+**，**++**，**+:**，**++:**，
**appended**，**appendedAll**，**diff**，**distinct**，**collect**，**concat**，**flatMap**，**flatten**，**inits**，**map**，**
mapInPlace**， **patch**， **reverse**， **sorted**， **sortBy**， **sortWith**， **sortInPlace**， **sortInPlaceWith**， **
sortInPlaceBy**， **tails**， **takeWhile**， **updated**， **zip**和**zipWithIndex**。

##### 分组方法

这些方法会根据一个已有的集合创建多个分组。包括**groupBy**，**grouped**，**groupMap**，**partition**，**sliding**，**span**，**splitAt**和**unzip**。

##### 信息和数学方法

这些方法提供关于集合的信息，包括**canEqual**，**contains**，**containsSlice**，**count**，**endsWith**，**exists**，**find**，**findLast**，**
forAll**，**indexOf**，**indexOfSlice**，**indexWhere**，**isDefinedAt**，**isEmpty**，**last**，**lastOption**，**lastIndexOf**
，**lastIndexOfSlice**，**lastIndexWhere**，**length**，**lengthIs**，**max**，**maxBy**，**maxOption**，**maxByOption**，**min**
，**minBy**，**minOption**，**minByOption**，**nonEmpty**，**product**，**segmentLength**，**size**，**sizeIs**，**startsWith**
和**sum**。像**foldLeft**，**foldRight**，**reduceLeft**和**reduceRight**这样的方法也可以通过提供一个函数去获得集合的信息。

##### 其他

一些其他的方法很难分类，包括**view**，**foreach**，**addString**和**mkString**。**view**在集合上创建一个惰性视图（见11.4小节，“在集合上创建惰性视图”），**foreach**就像**
for**循环，遍历集合里的每一个元素，并对每个元素产生副作用。**addString**和**mkString**会根据集合生成字符串。

甚至还有比这里列出的更多方法。例如，有一系列的 **to*** 方法，把当前集合（例如**List**）转换为其他集合类型（**toArray**，**toBuffer**，**toVector**
等等）。查看集合类的Scaladoc找到更多的内置方法。

#### 通用集合方法

下表列出了最常见的集合方法。注意，带引号的描述来自每个类的Scaladoc。

表13-1通过**Iterable**列出了所有集合共有的方法。在这个表中，第一列符号的含义如下：

- **c**代表一个集合。
- **f**代表一个函数。
- **p**代表一个谓词。
- **n**代表一个数字。

更多的可变和不可变集合的方法分别在表13-2和表13-3中。

*表13-1 **Iterable**集合的常用方法（scala.collection.Iterable）*

| 方法              | 描述 |
| ----------------- | ---- |
| c collect f       |      |
| c count p         |      |
| c drop n          |      |
| c dropWhile p     |      |
| c exists p        |      |
| c filter p        |      |
| c filterNot p     |      |
| c find p          |      |
| c flatMap f       |      |
| c flatten         |      |
| c foldLeft(s)(f)  |      |
| c foldRight(s)(f) |      |
| c forAll p        |      |
| c foreach f       |      |
| c groupBy f       |      |
| c head            |      |
| c headOption      |      |
| c init            |      |
| c inits           |      |
| c isEmpty         |      |
| c knownSize       |      |
| c last            |      |
| c lastOption      |      |
| c1 lazyZip c2     |      |
| c map f           |      |

| 方法                 | 描述 |
| -------------------- | ---- |
| c max                |      |
| c maxOption          |      |
| c maxBy f            |      |
| c maxByOption        |      |
| c min                |      |
| c minOption          |      |
| c minBy              |      |
| c minByOption        |      |
| c mkString           |      |
| c nonEmpty           |      |
| c partition p        |      |
| c product            |      |
| c reduceLeft op      |      |
| c reduceRight op     |      |
| c scanLeft op        |      |
| c scanRight op       |      |
| c size               |      |
| c1 sizeCompare(c2)   |      |
| c sizeIs n           |      |
| c slice(from, to)    |      |
| c sliding(size,step) |      |
| c span p             |      |
| c splitAt n          |      |
| c sum                |      |
| c tail               |      |
| c tails              |      |
| c take n             |      |

| 方法           | 描述 |
| -------------- | ---- |
| c takeWhile p  |      |
| c tapEach f    |      |
| c unzip        |      |
| c view         |      |
| c1 zip c2      |      |
| c zipWithIndex |      |

还有其他方法，但这些是最常见的。关于更多的方法，参考你正在使用集合的Scaladoc。

#### 可变集合方法

表13-2展示了可变集合的常用方法（这些都是方法，但是某些方法看起来像内置的操作符）。

*表13-2可变集合中常用的操作符（方法）*

| 方法                    | 描述 |
| ----------------------- | ---- |
| c += x                  |      |
| c1 ++= c2               |      |
| c −= x                  |      |
| c −= (x,y,z)            |      |
| c1 −−= c2               |      |
| c(n) = x                |      |
| c append x              |      |
| c1 appendAll c2         |      |
| c clear                 |      |
| c filterInPlace p       |      |
| c flatMapInPlace f      |      |
| c mapInPlace f          |      |
| c1.patchInPlace(i,c2,n) |      |
| c prepend x             |      |
| c1 prependAll c2        |      |

| 方法                | 描述 |
| ------------------- | ---- |
| c sortInPlace       |      |
| c sortInPlaceBy f   |      |
| c sortInPlaceWith f |      |
| c remove i          |      |
| c.remove(i, len)    |      |
| c.update(i,e)       |      |

注意，像 **+=** 和 **-=** 这样的符号方法名是方法的别名。例如 **+=** 是 **addOne** 的别名。关于更多的方法，参考你正在使用可变集合的Scaladoc。

#### 不可变集合方法

表13-3展示了不可变集合的常用方法。注意不能修改不可变集合，所以第一列中每个表达式的结果必须被赋值给一个新的变量。(参考11.3小节“理解可变变量与不可变集合”，了解在不可变的集合中使用可变的变量的细节）。

*表13-3不可变的集合中特有的方法*

| 方法            | 描述 |
| --------------- | ---- |
| c1 ++ c2        |      |
| c :+ e          |      |
| c1 :++ c2       |      |
| e +: c          |      |
| c1 ++: c2       |      |
| e :: list       |      |
| list1 ::: list2 |      |
| c updated(i,e)  |      |

注意，像 **++** 和 **++=** 这样的符号方法名是方法的别名。例如，**++** 是 **concat** 的别名。要注意的是，对于大多数序列来说，方法 **-** 和 **--**
在几个版本之前就被废弃了，目前只在集合上可用。所以要使用表13-1中列出的过滤方法来返回一个新的集合，并删除所需的元素。

上表只列出了不可变集合上最常见的方法。还有其他的方法，比如 **-** 和 **--** 方法在不可变集合上是可用的。关于更多的方法，参考你正在使用集合的Scaladoc。

#### Maps

**Map**还有附加的方法，如表13-14所示。在这个表中，第一列符号的含义如下：

- **m**，**m1**，**m2**代表一个map。
- **mm**代表一个可变map。
- **k**，**k1**，**k2**代表一个map的键。
- **p**代表一个谓词（返回**true**或**false**的函数）。
- **v**，**v1**，**v2**代表一个map的值。
- **c**代表一个集合。

*表13-4可变和不可变map中常用的方法*

| Map方法                        | 描述 |
| ------------------------------ | ---- |
| **不可变Map的方法**            |      |
| m + (k->v)                     |      |
| m1 ++ m2                       |      |
| m ++ Seq(k1->v1, k2->v2)       |      |
| m - k                          |      |
| m - Seq(k1, k2, k3)            |      |
| m -- k<br/>m -- Seq(k1,k2)     |      |
| **可变Map的方法**              |      |
| mm(k) = v                      |      |
| mm += (k -> v)                 |      |
| mm ++= Map(k1 -> v1, k2 -> v2) |      |

| Map方法                         | 描述 |
| ------------------------------- | ---- |
| mm ++= List(k1 -> v1, k2 -> v2) |      |
| mm -= k                         |      |
| mm --= Seq(k1, k2, k3)          |      |
| **可变和不可变Map的方法**       |      |
| m(k)                            |      |
| m contains k                    |      |
| m filter p                      |      |
| m get k                         |      |
| m getOrElse(k, d)               |      |
| m isDefinedAt k                 |      |
| m keys                          |      |
| m keyIterator                   |      |
| m keySet                        |      |
| m values                        |      |
| m valuesIterator                |      |

你也可以用 **updatedWith** 和 **updateWith** 方法来更新**Map**的值，这两个方法分别适用于不可变和可变的Map。

更多的方法，参考可变map类的Scaladoc（ *https://oreil.ly/OwG1n* ）和不可变map类的Scaladoc（ *https://oreil.ly/X5LhZ* ）。

### 讨论

正如你所看到的，Scala集合类包含了大量的方法（以及看起来是操作符的方法）。理解这些方法可以帮助你提高工作效率，随着对它们的理解，你会写更少的代码和更少的循环，而是写短的函数和谓词来使用这些方法。

## 13.2 用foreach遍历一个集合

### 问题

用**foreach**方法迭代集合中的元素。

### 解决方案

为**foreach**方法提供一个函数，匿名函数或方法，以匹配**foreach**正在寻找的方法签名，同时也解决你的问题。

Scala序列上的**foreach**方法有这样的签名：

```
	def foreach[U](f: (A) => U): Unit
```

这意味着它需要一个函数作为方法的唯一的参数，并且该函数需要一个泛型**A**，并且不返回任何东西（**Unit**）。如果这是一个实际问题，**A**是集合中的类型，例如**Int**和**String**。

**foreach**的工作方式是，从集合中每次传入一个元素给函数，从第一个元素开始，到最后一个元素结束。你提供的函数可以对每个元素做任何希望它做的事情，尽管你的函数不能返回任何东西。(如果你想返回什么，请看**map**方法）。

举个例子，**foreach**的常见用法是输出信息，如**Vector[Int]** ：

```
	val nums = Vector(1, 2, 3)
```

你可以编写一个函数，接受**Int**参数而没有返回：

```
	def printAnInt(i: Int): Unit = println(i)
```

因为**printAnInt**与**foreach**要求的签名相匹配，你可以将它与**nums**和**foreach**一起使用：

```
    scala> nums.foreach(i => printAnInt(i))
    1
    2
    3
```

你也可以这样写这个表达式：

```
    nums.foreach(printAnInt(_))
    nums.foreach(printAnInt) // most common
```

最后一个例子显示了最常用的形式。

同样地，你也可以通过编写一个匿名函数传入**foreach**来解决这个问题。这些例子都与使用**printAnInt**函数相同：

```
    nums.foreach(i => println(i))
    nums.foreach(println(_))
    nums.foreach(println) // most common
```

#### Map上使用foreach

**foreach**在**Map**类上也可使用。**foreach**的**Map**实现有这样的签名：

```
    def foreach[U](f: ((K, V)) => U): Unit
```

这意味着它期望接收有两个参数（**K**和**V**，代表*key*和*value*）的函数，同时并返回**U**，代表**Unit**。因此，**foreach**向函数传入两个参数。你可以把这些参数当作一个元组来处理：

```
    val m = Map("first_name" -> "Nick", "last_name" -> "Miller")
    
    m.foreach(t => println(s"${t._1} -> ${t._2}")) // tuple syntax
```

你也可以使用这种方式：

```
    m.foreach {
        (fname, lname) => println(s"$fname -> $lname")
    }
```

参见14.9小节，“遍历Map”，了解遍历**Map**的其他方法。

#### 副作用 -- 鸽子栏

&nbsp; &nbsp; &nbsp; &nbsp;如上所示，**foreach**将函数作用于集合中的每个元素，但函数不需要返回值，**foreach**也不返回值。因为**foreach**
不返回任何东西。所以在逻辑上使用它必须有其他的原因，比如打印输出或修改其他变量。因此，有人说**foreach**，以及任何其他返回**Unit**的方法必须用于其副作用。因此，**foreach**是一个*statement*
，而不是一个*expression*。关于语句和表达式的更多细节，参考我的博客“A Note About Expression-Oriented Programming” （ *https://oreil.ly/UyODg* ） 。

### 讨论

在**foreach**使用多行函数，需要将函数用花括号包成为代码块，然后传入：

```
    val longWords = StringBuilder()
    
    "Hello world it’s Al".split(" ").foreach { e =>
        if e.length > 4 then longWords.append(s" $e")
        else println("Not added: " + e)
    }
```

在**REPL**中运行该代码，输出如下：

```
    Not added: it’s
    Not added: Al
    val longWords: StringBuilder = Hello world
```

### 另见

- 你可以使用**for**循环和**for**表达式来迭代集合中的元素，详见第4章。

## 13.3 使用迭代器

### 问题

想要（或需要）在Scala程序中使用一个迭代器。

### 解决方案

在Scala中使用迭代器，有些要点需要了解：

- 与Java的**while**循环不同，Scala开发者一般不会直接使用**Iterator**的**hasNext**和**next**方法。
- 出于性能方面的考虑，使用迭代器是有意义的，比如读取大文件时。
- 迭代器在使用后会被耗尽。
- 虽然迭代器不是集合，但它有常用的集合方法。
- 迭代器的转化器方法是惰性的。
- **Iterator**的子类**BufferedIterator**提供了**head**和**headOption**方法，可以查看下一个元素的值。

这些要点（和解决方案）将在下面小节中涵盖。

#### Scala开发者不会直接使用hasNext和next

尽管在Java中使用迭代器的**hasNext()**和**next()**是在遍历集合的常见方式，但Scala开发者通常不会直接使用这些方法。相反，会使用**map**，**filter**和**foreach**
等集合方法遍历集合，或者说**for**循环。说白了，只要我在Scala中有迭代器，我就从来没有直接写过这样的代码：

```
    val it = Iterator(1, 2, 3)

    // we don’t do this
    val it = collection.iterator
    while (it.hasNext) ...
```

相反，我这样写代码：

```
    val a = it.map(_ * 2)           // a: Iterator[Int] = <iterator>
    val b = it.filter(_ > 2)        // b: Iterator[Int] = <iterator>
    val c = for e <- it yield e*2   // c: Iterator[Int] = <iterator>
```

#### 性能原因导致迭代器有意义

虽然没有直接调用**hasNext()**和**next()**方法，但迭代器在Scala中是一个重要概念。例如，当你用**io.Source.fromFile**
方法读取一个文件时，它返回一个迭代器，使得一次从文件中读取一行。这是有意义的，因为将大数据文件一次读入内存是不现实的。

迭代器也被用于*views*的转化器方法中，它是惰性的。例如*Programming in Scala* 一书展示了用迭代器来实现**lazyMap**函数：

```
    def lazyMap[T, U](coll: Iterable[T], f: T => U) =
        new Iterable[U] {
            def iterator = coll.iterator map f
    }
```

正如11.4小节，“在集合上创建惰性视图”中所示，在大集合上使用视图是提高性能的重要技巧。

#### 迭代器在使用后会被耗尽

使用迭代器的一个重要部分，需要知道耗尽在使用之后会耗尽（变为空）。当访问每个元素时，会改变迭代器(参考讨论)，并且前面的元素会被丢弃。例如，如果你使用**foreach**来打印迭代器的元素，调用在第一次时就起作用了：

```
    scala> val it = Iterator(1,2,3)
    it: Iterator[Int] = nonempty iterator

    scala> it.foreach(print)
    123
```

当第二次尝试同样的调用时，将没有任何输出，因为迭代器已经耗尽了：

```
    scala> it.foreach(print)
    (no output here)
```

#### 迭代器的行为像集合

从技术上讲，迭代器不是集合。相反，它提供了可以逐个访问集合中元素的方法。但在迭代器又确实定义了许多在常用集合类中看到的方法，包括**foreach**，**map**，**filter**等。你也可以在需要时将迭代器转换为集合：

```
    val i = Iterator(1,2,3) // i: Iterator[Int] = <iterator>
    val a = i.toVector      // a: Vector[Int] = Vector(1, 2, 3)

    val i = Iterator(1,2,3) // i: Iterator[Int] = <iterator>
    val b = i.toList        // b: List[Int] = List(1, 2, 3)
```

#### 迭代器是惰性的

另一个重要的点是，迭代器是惰性的，意味着它们的转换器方法以一种非严格或惰性的方式进行计算。例如，下面的**for**循环以及**map**和**filter**方法并不返回具体的结果，它们只是返回一个迭代器：

```
    val i = Iterator(1,2,3)         // i: Iterator[Int] = <iterator>

    val a = for e <- i yield e*2    // a: Iterator[Int] = <iterator>
    val b = i.map(_ * 2)            // b: Iterator[Int] = <iterator>
    val c = i.filter(_ > 2)         // c: Iterator[Int] = <iterator>
```

像其他惰性方法一样，它们仅仅在需要时才会被计算，例如调用严格方法**foreach**：

```
    scala> i.map(_ + 10).foreach(println)
    11
    12
    13
```

#### BufferedIterator允许你提前查看元素

缓冲迭代器也是一种迭代器，它允许你在不向前移动迭代器的情况下查看下一个元素。可以通过调用**Iterator**的**buffered**方法创建**BufferedIterator**。

```
    val it = Iterator(1,2)  // it: Iterator[Int] = <iterator>
    val bi = it.buffered    // bi: BufferedIterator[Int] = <iterator>
```

随后在**BufferedIterator**上调用**head**方法，这不会影响迭代器：

```
    // call 'head' as many times as desired
    bi.head // 1
    bi.head // 1
    bi.head // 1
```

另一方面，注意在**Iterator**或**BufferedIterator**上调用**next**方法时会发生什么：

```
    // 'next' advances the iterator
    bi.next // 1
    bi.next // 2
    bi.next // java.util.NoSuchElementException: next on empty iterator
```

#### 小心调用head方法 -- 耗子栏

&nbsp; &nbsp; &nbsp; &nbsp;正如13.1小节中所讨论的，你通常想用 **headOption** 而不是 **head**，因为如果在空列表上调用它，或者在列表的末尾调用它， **head** 方法会抛出异常。

```
    // create a one-element BufferedIterator
    val bi = Iterator(1).buffered
    	// result: BufferedIterator[Int] = <iterator>

    // 'head' works fine
    bi.head			// 1

    // advance the iterator
    bi.next 		// 1
    bi.headOption	// None (headOption works as intended)

    // 'head' blows up
    bi.head
        // result: java.util.NoSuchElementException:
        // next on empty iterator
```

### 讨论

从概念上讲，迭代器就像指针。当你在列表上创建迭代器时，它最初指向列表的第一个元素：

```
    val x = 1 :: 2 :: Nil
            ^
```

然后当你调用迭代器的**next**方法时，它会指向集合中的下一个元素：

```
    val x = 1 :: 2 :: Nil
    			 ^
```

最后，当迭代器到达集合的末尾时，它被认为已经耗尽。不会再回到指向第一个元素的位置：

```
    val x = 1 :: 2 :: Nil
    				   ^
```

如解决方案中所示，此时调用**next**或**head**将抛出异常**java.util.NoSuchElementException**。

### 另见

- Scala迭代器介绍。（ *https://oreil.ly/oFiiQ* ）
- Iterator的Scaladoc。（ *https://oreil.ly/VPzWO* ）
- BufferedIterator的Scaladoc。（ *https://oreil.ly/w7IQt* ）
- 11.4小节，“在集合上创建惰性视图”，有更多关于视图，迭代器和性能的内容。

## 13.4 使用zipWithIndex或者zip创建循环计数器

### 问题

### 解决方案

### 讨论

###       

## 13.5 用Map实现集合的转换

### 问题

### 解决方案

### 讨论

###       

## 13.6 用flatten对列表进行扁平化处理

### 问题

### 解决方案

### 讨论

## 13.7 用flilter对列表进行过滤

### 问题

### 解决方案

### 讨论

###       

## 13.8 从集合中提取元素序列

### 问题

### 解决方案

### 讨论

## 13.9 将序列拆分成子集

### 问题

### 解决方案

### 讨论

## 13.10 用reduce和fold方法遍历集合

### 问题

### 解决方案

### 讨论

### 另见

## 13.11 从序列中查找不重复的元素

### 问题

### 解决方案

### 讨论

## 13.12 合并序列集合

### 问题

### 解决方案

### 讨论

## 13.13 随机化序列

### 问题

### 解决方案

### 讨论

## 13.14 集合排序

### 问题

### 解决方案

### 讨论

### 另见

## 13.15 通过mkString和addString将集合转换成字符串

### 问题

### 解决方案

### 讨论
