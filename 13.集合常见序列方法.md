# 13 集合：常见序列方法

前两章主要关注序列类，本章主要关注常用的序列方法。深入研究这些小节前，当使用集合类方法时，需要了解一些重要的概念：

- 谓词
- 匿名函数
- 隐式循环

## 谓词

*predicate*是一个方法、函数或匿名函数。接收一个或多个输入参数并返回**Boolean**值。 下面方法返回 **true** 或 **false**，所以是一个谓词：

```
    def isEven(i: Int): Boolean =
        i % 2 == 0
```

谓词是一个简单的概念，使用集合方法时，会经常听到这个术语，所以有必要提及。

## 匿名函数

匿名函数的概念也很重要。在10.1小节“使用函数字面量(匿名函数)”中有深入的描述，作为一个简单的例子，下面代码展示了完整的匿名函数，与 **isEven** 方法做同样的工作：

```
    (i: Int) => i % 2 == 0
```

简写如下：

```
    _ % 2 == 0
```

看起来并不多，但当它与集合上的**filter**方法结合在一起时，一小段代码就会发挥很大的作用：

```
    scala> val list = List.range(1, 10)
    list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
    
    scala> val events = list.filter(_ % 2 == 0)
    events: List[Int] = List(2, 4, 6, 8)
```

  

## 隐式循环

**filter**方法是第三个话题的一个很好的例子：*implied loops*。正如你从上面例子中看到的，**filter**包含一个循环，将你的函数使用在集合中的每个元素，并返回一个新的集合。你可以不使用**filter**方法，而写出下面等价代码：

```
    for
        e <- list
        if e % 2 == 0
    yield
        e
```

我认为你会赞同，**filter**方法既更简洁，也更容易阅读。

像**filter**、**foreach**、**map**、**reduceLeft**等集合方法都在其算法中内置了循环。由于这些内置的方法，在编写Scala代码时，你会比其他语言少写很多自定义的**for**循环。

## 本章中的小节

虽然序列类有一百多个内置的方法，但本章的小节主要集中在最常用的方法上，包括：

- **filter**，允许你用一个给定的谓词来过滤集合。
- **map**，允许你对集合中的每个元素应用一个转换函数。
- 提取序列和现有序列子集的方法。
- 寻找序列中唯一元素的方法。
- 合并和压缩序列的方法。
- 随机化和排序序列的方法。
- 将序列转换为字符串的两个方法。

这些功能（以及更多的功能）将在下面的小节中展示。

## 13.1 选择集合方法解决问题

### 问题

Scala集合里有大量的方法可用，需要选择其中一个来解决一个问题。

### 解决方案

Scala集合类提供了丰富的用来操作数据的方法。绝大多数方法以一个函数或者谓词作为参数。

可用的方法在本节中会以两种方式列出。接下来的几段中，方法按类别划分，从而使你方便找到所需要的。然后在后面的表格中，还会有简单的描述和方法签名。

#### 按类别划分的方法

##### 过滤方法

可以用来过滤一个集合的方法，包括**collect**，**diff**，**distinct**，**drop**，**dropRight**，**dropWhile**，**filter**，**filterNot**，**filterInPlace**，**find**，**foldLeft**，**foldRight**，**head**，**headOption**，**init**，**intersect**，**last**，**lastOption**，**slice**，**tail**，**take**，**takeRight**，**takeWhile**和**union**。

##### 转换方法

转化器方法至少需要一个输入集合来创建一个新的输出集合，通常使用你提供的算法。包括 **+**，**++**，**+:**，**++:**，
**appended**，**appendedAll**，**diff**，**distinct**，**collect**，**concat**，**flatMap**，**flatten**，**inits**，**map**，**mapInPlace**， **patch**， **reverse**， **sorted**， **sortBy**， **sortWith**， **sortInPlace**， **sortInPlaceWith**， **sortInPlaceBy**， **tails**， **takeWhile**， **updated**， **zip**和**zipWithIndex**。

##### 分组方法

这些方法会根据一个已有的集合创建多个分组。包括**groupBy**，**grouped**，**groupMap**，**partition**，**sliding**，**span**，**splitAt**和**unzip**。

##### 信息和数学方法

这些方法提供关于集合的信息，包括**canEqual**，**contains**，**containsSlice**，**count**，**endsWith**，**exists**，**find**，**findLast**，**forAll**，**indexOf**，**indexOfSlice**，**indexWhere**，**isDefinedAt**，**isEmpty**，**last**，**lastOption**，**lastIndexOf**，**lastIndexOfSlice**，**lastIndexWhere**，**length**，**lengthIs**，**max**，**maxBy**，**maxOption**，**maxByOption**，**min**，**minBy**，**minOption**，**minByOption**，**nonEmpty**，**product**，**segmentLength**，**size**，**sizeIs**，**startsWith**和**sum**。像**foldLeft**，**foldRight**，**reduceLeft**和**reduceRight**这样的方法也可以通过提供一个函数去获得集合的信息。

##### 其他

一些其他的方法很难分类，包括**view**，**foreach**，**addString**和**mkString**。**view**在集合上创建一个惰性视图（见11.4小节，“在集合上创建惰性视图”），**foreach**就像**for**循环，遍历集合里的每一个元素，并对每个元素产生副作用。**addString**和**mkString**会根据集合生成字符串。

甚至还有比这里列出的更多方法。例如，有一系列的 **to*** 方法，把当前集合（例如**List**）转换为其他集合类型（**toArray**，**toBuffer**，**toVector** 等等）。查看集合类的Scaladoc找到更多的内置方法。

#### 通用集合方法

下表列出了最常见的集合方法。注意，带引号的描述来自每个类的Scaladoc。

表13-1通过**Iterable**列出了所有集合共有的方法。在这个表中，第一列符号的含义如下：

- **c**代表一个集合。
- **f**代表一个函数。
- **p**代表一个谓词。
- **n**代表一个数字。

更多的可变和不可变集合的方法分别在表13-2和表13-3中。

*表13-1 **Iterable**集合的常用方法（scala.collection.Iterable）*

| 方法              | 描述 |
| ----------------- | ---- |
| c collect f       |      |
| c count p         |      |
| c drop n          |      |
| c dropWhile p     |      |
| c exists p        |      |
| c filter p        |      |
| c filterNot p     |      |
| c find p          |      |
| c flatMap f       |      |
| c flatten         |      |
| c foldLeft(s)(f)  |      |
| c foldRight(s)(f) |      |
| c forAll p        |      |
| c foreach f       |      |
| c groupBy f       |      |
| c head            |      |
| c headOption      |      |
| c init            |      |
| c inits           |      |
| c isEmpty         |      |
| c knownSize       |      |
| c last            |      |
| c lastOption      |      |
| c1 lazyZip c2     |      |
| c map f           |      |



| 方法                 | 描述 |
| -------------------- | ---- |
| c max                |      |
| c maxOption          |      |
| c maxBy f            |      |
| c maxByOption        |      |
| c min                |      |
| c minOption          |      |
| c minBy              |      |
| c minByOption        |      |
| c mkString           |      |
| c nonEmpty           |      |
| c partition p        |      |
| c product            |      |
| c reduceLeft op      |      |
| c reduceRight op     |      |
| c scanLeft op        |      |
| c scanRight op       |      |
| c size               |      |
| c1 sizeCompare(c2)   |      |
| c sizeIs n           |      |
| c slice(from, to)    |      |
| c sliding(size,step) |      |
| c span p             |      |
| c splitAt n          |      |
| c sum                |      |
| c tail               |      |
| c tails              |      |
| c take n             |      |



| 方法           | 描述 |
| -------------- | ---- |
| c takeWhile p  |      |
| c tapEach f    |      |
| c unzip        |      |
| c view         |      |
| c1 zip c2      |      |
| c zipWithIndex |      |

还有其他方法，但这些是最常见的。关于更多的方法，参考你正在使用集合的Scaladoc。

#### 可变集合方法

表13-2展示了可变集合的常用方法（这些都是方法，但是某些方法看起来像内置的操作符）。

*表13-2可变集合中常用的操作符（方法）*

| 方法                    | 描述 |
| ----------------------- | ---- |
| c += x                  |      |
| c1 ++= c2               |      |
| c −= x                  |      |
| c −= (x,y,z)            |      |
| c1 −−= c2               |      |
| c(n) = x                |      |
| c append x              |      |
| c1 appendAll c2         |      |
| c clear                 |      |
| c filterInPlace p       |      |
| c flatMapInPlace f      |      |
| c mapInPlace f          |      |
| c1.patchInPlace(i,c2,n) |      |
| c prepend x             |      |
| c1 prependAll c2        |      |



| 方法                | 描述 |
| ------------------- | ---- |
| c sortInPlace       |      |
| c sortInPlaceBy f   |      |
| c sortInPlaceWith f |      |
| c remove i          |      |
| c.remove(i, len)    |      |
| c.update(i,e)       |      |

注意，像 **+=** 和 **-=** 这样的符号方法名是方法的别名。例如 **+=** 是 **addOne** 的别名。关于更多的方法，参考你正在使用可变集合的Scaladoc。

#### 不可变集合方法

表13-3展示了不可变集合的常用方法。注意不能修改不可变集合，所以第一列中每个表达式的结果必须被赋值给一个新的变量。(参考11.3小节“理解可变变量与不可变集合”，了解在不可变的集合中使用可变的变量的细节）。

*表13-3不可变的集合中特有的方法*

| 方法            | 描述 |
| --------------- | ---- |
| c1 ++ c2        |      |
| c :+ e          |      |
| c1 :++ c2       |      |
| e +: c          |      |
| c1 ++: c2       |      |
| e :: list       |      |
| list1 ::: list2 |      |
| c updated(i,e)  |      |

注意，像 **++** 和 **++=** 这样的符号方法名是方法的别名。例如，**++** 是 **concat** 的别名。要注意的是，对于大多数序列来说，方法 **-** 和 **--** 在几个版本之前就被废弃了，目前只在集合上可用。所以要使用表13-1中列出的过滤方法来返回一个新的集合，并删除所需的元素。

上表只列出了不可变集合上最常见的方法。还有其他的方法，比如 **-** 和 **--** 方法在不可变集合上是可用的。关于更多的方法，参考你正在使用集合的Scaladoc。

#### Maps

**Map**还有附加的方法，如表13-14所示。在这个表中，第一列符号的含义如下：

- **m**，**m1**，**m2**代表一个map。
- **mm**代表一个可变map。
- **k**，**k1**，**k2**代表一个map的键。
- **p**代表一个谓词（返回**true**或**false**的函数）。
- **v**，**v1**，**v2**代表一个map的值。
- **c**代表一个集合。

*表13-4可变和不可变map中常用的方法*

| Map方法                        | 描述 |
| ------------------------------ | ---- |
| **不可变Map的方法**            |      |
| m + (k->v)                     |      |
| m1 ++ m2                       |      |
| m ++ Seq(k1->v1, k2->v2)       |      |
| m - k                          |      |
| m - Seq(k1, k2, k3)            |      |
| m -- k<br/>m -- Seq(k1,k2)     |      |
| **可变Map的方法**              |      |
| mm(k) = v                      |      |
| mm += (k -> v)                 |      |
| mm ++= Map(k1 -> v1, k2 -> v2) |      |



| Map方法                         | 描述 |
| ------------------------------- | ---- |
| mm ++= List(k1 -> v1, k2 -> v2) |      |
| mm -= k                         |      |
| mm --= Seq(k1, k2, k3)          |      |
| **可变和不可变Map的方法**       |      |
| m(k)                            |      |
| m contains k                    |      |
| m filter p                      |      |
| m get k                         |      |
| m getOrElse(k, d)               |      |
| m isDefinedAt k                 |      |
| m keys                          |      |
| m keyIterator                   |      |
| m keySet                        |      |
| m values                        |      |
| m valuesIterator                |      |

你也可以用 **updatedWith** 和 **updateWith** 方法来更新**Map**的值，这两个方法分别适用于不可变和可变的Map。

更多的方法，参考可变map类的Scaladoc（ *https://oreil.ly/OwG1n* ）和不可变map类的Scaladoc（ *https://oreil.ly/X5LhZ* ）。

### 讨论

正如你所看到的，Scala集合类包含了大量的方法（以及看起来是操作符的方法）。理解这些方法可以帮助你提高工作效率，随着对它们的理解，你会写更少的代码和更少的循环，而是写短的函数和谓词来使用这些方法。



## 13.2 用foreach遍历一个集合

### 问题

### 解决方案

#### Map上使用foreach

### 讨论

### 另见



## 13.3 使用迭代器

### 问题

### 解决方案

### 讨论

### 另见



## 13.4 使用zipWithIndex或者zip创建循环计数器

### 问题

### 解决方案

### 讨论

### 

## 13.5 用Map实现集合的转换

### 问题

### 解决方案

### 讨论

### 

## 13.6 用flatten对列表进行扁平化处理

### 问题

### 解决方案

### 讨论



## 13.7 用flilter对列表进行过滤

### 问题

### 解决方案

### 讨论

### 

## 13.8 从集合中提取元素序列

### 问题

### 解决方案

### 讨论



## 13.9 将序列拆分成子集

### 问题

### 解决方案

### 讨论



## 13.10 用reduce和fold方法遍历集合

### 问题

### 解决方案

### 讨论

### 另见

## 13.11 从序列中查找不重复的元素

### 问题

### 解决方案

### 讨论

## 13.12 合并序列集合

### 问题

### 解决方案

### 讨论

## 13.13 随机化序列

### 问题

### 解决方案

### 讨论

## 13.14 集合排序

### 问题

### 解决方案

### 讨论

### 另见

## 13.15 通过mkString和addString将集合转换成字符串

### 问题

### 解决方案

### 讨论
