# 19. Play 框架和 Web 服务

本章的小节展示了使用Scala开发Web服务，包括如何处理服务器端的HTTP请求，如何在JSON和Scala对象之间进行转换，以及如何编写客户端的HTTP请求。

到2021年，有一些很棒的库可以用Scala进行服务器端开发，可以在Awesome Scala列表(*https://oreil.ly/rC08K*)中找到这些库。本章重点介绍Play框架（Play），因为它很流行，支持度高，而且相对容易上手，特别是如果以前使用过Ruby on Rails这样的框架的话就更简单了。

注意，在本书编写之时，Play还没有更新到支持Scala 3。因此，在本章中看到的Play示例使用的是Scala 2语法。也就是说，Play的API已经相当稳定，可以追溯到2013年和*Scala Cookbook*第一版的发布，因此，当Play支持Scala 3时，这些例子有望很好地转化为支持Scala 3。

本章的初始小节侧重于使用 Play 的服务器端开发。这些小节包括：

- 小节19.1，创建第一个Play项目
- 小节19.2，创建一个新的端点，即一个服务器端REST服务的URL
- 小节19.3，从Play GET请求返回一个JSON
- 小节19.4，将Scala对象转换为JSON
- 小节19.5，将JSON转换为Scala对象

然后，最后两个小节展示了可用于服务器端或客户端开发的技术：

- 小节19.6，在Play框架外使用Play JSON库
- 小节19.7，使用sttp HTTP客户端

## 19.1 创建一个Play框架项目

### 问题

这一章大部分小节使用Play 框架（Play），如果之前没用过Play，需要知道如何创建一个新的Play项目。

### 解决方案

创建一个新的Play项目的最简单方法是使用sbt种子模板：

```
    $ sbt new playframework/play-scala-seed.g8
```

当该命令运行时，只需要给它一个项目名称和组织名称，然后 **cd** 进入新的目录，如下所示：

```
    $ sbt new playframework/play-scala-seed.g8 
    [info] Set current project to play ...
    This template generates a Play Scala project

    name [play-scala-seed]: hello-world 
    organization [com.example]: com.alvinalexander

    Template applied in hello-world

    $ cd hello-world
```

然后在该项目目录下，运行 **sbt run** 命令：

```
    $ sbt run 
    // a LOT of output here ...
    [info] loading settings for project hello-world-build from plugins.sbt ... 
    [info] loading settings for project root from build.sbt ...
    [info] set current project to hello-world ...
    
    --- (Running the application, auto-reloading is enabled) --
    [info] p.c.s.AkkaHttpServer - Listening for HTTP on /0:0:0:0:0:0:0:0:9000 
    (Server started, use Enter to stop and go back to the console...)
```

第一次运行该命令时，会有很多输出，如果以最后三行结束，这表明Play服务器在9000端口运行：

现在，当在浏览器中打开 *http://localhost:9000* URL时，会看到一个 "Welcome to Play "的网页，看起来像图19-1中的页面那样。

![f19-1](./f19-1.png)

图19-1，*"欢迎来使用Play！"欢迎页*

如果需要在9000以外的端口运行Play，请在你的操作系统命令行中使用这个命令：

```
    $ sbt "run 8080"
```

或者在sbt shell中使用如下命令：

```
    sbt> run 8080
```

### 讨论

一个Play应用程序由以下组件组成：

- sbt *build.sbt* 文件，包含应用程序的依赖和其他配置信息。
- 放在 *app/controllers* 文件夹中的控制器。
- 在app/models文件夹中的模型。这个文件夹通常不会自动创建。
- 包含HTML、JavaScript、CSS和Scala代码片段的模板被放在 *app/views* 文件夹中。
- 一个 *conf/routes* 文件，里面有将URI和HTTP方法映射到控制器方法。

其他重要的文件包括：

- *conf/application.conf* 文件中的应用程序配置信息。这里包括关于如何访问数据库的信息。
- 在 *conf/evolutions* 文件夹中的数据库演化脚本。
- 模板文件的设计资源被放在 *public/images* 、*public/javascripts* 和 *public/stylesheets* 文件夹中。

因为本章是关于构建Web服务的，而不是Web 1.0应用程序，所以主要关注的是这些目录和文件：

- *conf/routes* 路由文件
- 在 *app/controllers* 自定义的控制器

#### *conf/routes* 文件

要了解项目中的文件，首先看conf/routes文件。当前的Play 2.8模板创建了一个具有以下内容的文件：

```
    # Routes 
    # This file defines all application routes (Higher priority routes first) 
    # https://www.playframework.com/documentation/latest/ScalaRouting
    
    # An example controller showing a sample home page 
    GET / controllers.HomeController.index
    
    # Map static resources from the /public folder to the /assets URL path 
    GET /assets/*file controllers.Assets.versioned(path="/public", file: Asset)
```

要了解欢迎页面是如何显示的，这是该文件中这重要的一行：

```
    GET / controllers.HomeController.index
```

这一行可以理解为："当以HTTP GET方法请求/ URI上时，调用 *控制器* 包中的 **HomeController** 类中定义的 **index** 方法"。如果使用过Ruby on Rails等其他框架，就见过这种东西。它将特定的HTTP方法（如GET或POST）和URI绑定到一个类中的方法。

关于路由的两件重要的事情是：

-  *conf/routes* 文件被编译了，所以可以在浏览器中直接看到路由错误。
- 正如将在控制器类代码中看到的，它使用了依赖注入。根据Play文档，"Play的默认路由生成器创建了一个路由器类，在 **@Inject-annotated** 构造函数中接受控制器实例。这意味着该类适合使用依赖注入，也可以使用构造函数手动实例化。"

#### 控制器

接下来，打开 *app/controllers/HomeController.scala* ，查看其 **index** 方法：

```
    package controllers
    import javax.inject._ 
    import play.api._ 
    import play.api.mvc._
    
    /**
     * This controller creates an `Action` to handle HTTP requests to the 
     * application's home page.
     */
    @Singleton 
    class HomeController @Inject()(val controllerComponents: ControllerComponents)          
    extends BaseController {
    
      /** 
       * Create an Action to render an HTML page.
       * 
       * The configuration in the `routes` file means that this method 
       * will be called when the application receives a `GET` request with 
       * a path of `/`.
       */
      def index() = Action { implicit request: Request[AnyContent] =>
        Ok(views.html.index()) 
      }
    }
    
```

这是一个普通的Scala源代码文件，有一个名为 **index** 的方法。这个方法通过调用一个名为 **Ok** 的方法实现一个Play **Action** ，并传入需要显示的内容。代码 **views.html.index** 是Play对 *app/views/index.scala.html* 模板文件的引用。Play架构的一个超棒的功能是，Play模板被编译为Scala函数，所以在这段代码中看到的是一个普通的函数调用：

```
    Ok(views.html.index())
```

这段代码就是调用 *views.html* 包中一个名为 **index** 的函数。

#### view 模版

在明白了模板会编译成一个普通的Scala函数之后，打开 *app/views/ index.scala.html* 模板文件，可以看到以下内容：

```
    @()
    
    @main("Welcome to Play") { 
      <h1>Welcome to Play!</h1> 
    }
```

注意这段代码的第一行

```
    @()
```

如果把模板看成一个函数，这就是函数的参数列表。在这个例子中，参数列表是空的，但如果这个模板有一个名字为 **message** 的字符串参数，这一行就会是这样的：

```
    @(message: String)
```

文件中的 **@** 符号是Play模板文件中的一个特殊字符。它表示它后面的内容是一个Scala表达式。例如，在所示的这行代码中，**@** 字符在函数参数列表之前。在第三行代码中，**@** 字符在调用一个名为 **main** 的函数之前。注意在这行代码中，字符串 "Welcome to Play "被传递到 **main** 方法中。

可能细心的读者已经猜到了，虽然 **main** 看起来像一个函数，但它也是一个模板文件。当代码调用 **main** 时，它实际上调用了 *app/views/main.scala.html* 模板。下面是 *main.scala.html* 的默认源代码：

```
    @(title: String)(content: Html)

    <!DOCTYPE html>
    <html lang="en">
        <head>
            @* Here's where we render the page title `String`. *@ 
            <title>@title</title>
            <link rel="stylesheet" media="screen"
                href="@routes.Assets.versioned("stylesheets/main.css")">
            <link rel="shortcut icon" type="image/png"
                href="@routes.Assets.versioned("images/favicon.png")">
        </head> 
        <body>
            @* And here's where we render the `Html` object containing 
            * the page content. *@ 
            @content
            
        <script src="@routes.Assets.versioned("javascripts/main.js")"
            type="text/javascript"></script>
        </body>
    </html>
```

这个文件是项目的默认包装模板文件。如果其他每一个模板文件都以 *index.scala.html* 文件的方式调用 **main** ，那么可以放心，这些模板都会被这个相同的HTML、CSS和JavaScript包裹起来。因此，所有的页面都会有相同的视觉体验。

在本章的课程中，其实是不需要知道这些细节，但在这里展示这两个初始文件，为了让读者更清楚了解web应用在Play中的样子。

#### 单页应用——（TODO：鸟图）

这里说的 "web应用 "，指的是用HTML编写的应用——或者在这里的情景中，指的是支持HTML和Scala片段混合的模板系统——在HTML中添加JavaScript和CSS。对于用JavaScript编写的单页应用程序（SPA），想在服务器端使用Play，可以不用对Scala的模板系统有更多了解。

#### sbt/Play 控制台

当在开发一个应用程序时，在项目的根目录下启动sbt：

```
    $ sbt
```

在这里可以运行所有常规的sbt命令，也可以启动应用程序。如解决方案中所示，该命令在默认的9000端口上启动应用程序：

```
    [play01] $ run

    (lots of output here ...)
    --- (Running the application, auto-reloading is enabled) --
    [info] p.c.s.AkkaHttpServer - Listening for HTTP on /0:0:0:0:0:0:0:0:9000 
    (Server started, use Enter to stop and go back to the console ...)
```

sbt输出的最后一行显示，可以按下Enter键停止服务器并返回到sbt提示。

正如在下面的一些小节中所示，也可以在sbt里面发出一个 **console** 命令：

```
    sbt> console 
    [info] Starting scala interpreter...
    Welcome to Scala 2.13 Type in expressions for evaluation. Or try :help.
    
    scala> _
```

这将启动一个Scala REPL，加载所有项目的依赖。在这里，可以测试Play JSON代码和其他Play代码，包括使用自定义类、模型等。

### 另见

- 更多关于 "开始使用"的信息，请参看Play Framework网站。
- 虽然它是为Play的早期版本写的，但我的Play框架食谱小册子可以在这（*https://alvinalexander.com/scala/scala-cookbook-play-framework-recipes-pdf-ebook/*）免费下载。
- 更多关于如何使用sbt的例子，见第17章。
- 关于如何使用Scala.js创建单页应用程序的细节，请参见21.3小节，"用Scala.js构建单页应用程序"。