#  字符串

作为程序员，我们经常和字符串打交道，如名字，地址，电话号码等等。Scala的字符串非常棒，因为它们不仅拥有Java字符串的全部功能，还有一些额外的功能。在本章中，将会在其中一些小节中展示与字符串格式化和正则模式相同的功能，而其他的小节则展示了Scala字符串独有的功能。

Scala与Java语法一个最大的区别是字符串的声明方式。所有的Scala变量都是以 **val** 或 **var** 的形式声明的，因此一个字符串变量通常是这样创建的：

```scala
val s = "Hello, world"
```

这个表达式与下面的Java代码等价：

```java
final String s = "Hello, world"
```

在Scala中，一般来说总是将变量声明为 **val** ，除非有充分的理由使用 **var** （纯函数式编程要求则更严格，禁止使用 **var**）

也可以 *显示* 声明成 **字符串** 类型：

```scala
val s: String = "Hello, world" // 不要这么做
       ______
```

这么做只会让代码变得冗长，所以并不推荐这么做。因为Scala的 *类型推断* 非常强大，使用第一个例子中的隐式语法已经是首选方式了。在实际情况下，我其实只有在调用一个方法并且不确定其返回类型时，才会在创建变量时明确声明其类型，如：

```scala
val s: String = someObject.someMethod(42)
```

## Scala 字符串特性

赋予Scala字符串力量（超级力量！）的特性有：

- 能使用==来比较字符串的相等
- 多行字符串
- 字符串插值，可以写出类似 **println(s"Name: $name")** 的代码
- 数十种额外的函数方法可以将字符串当作字符序列来处理

本章中的小节展示了所有这些功能

### 字符串是字符序列

上面提到的一个重要观点是，Scala的字符串可以被当作字符序列来看待，也就是当作 **Seq[Char]** 。因此在以下例子中的字符串：

```scala
val s = "Big Belly Burger"
```

下面是一些“序列”常用的方法，可以在字符串上进行调用：

```scala
s.count(_ == 'B') // 3
s.dropRight(3) // "Big Belly Bur"
s.dropWhile(_ != ' ') // " Belly Burger"
s.filter(_ != ' ') // "BigBellyBurger"
s.sortWith(_ < _) // " BBBeeggillrruy"
s.take(3) // "Big"
s.takeRight(3) // "ger"
s.takeWhile(_ != 'r') // "Big Belly Bu"
```

这些方法都是 **Seq** 的标准方法，将在第11章中深入介绍。

### 链式方法调用

**Seq** 上所有的方法都是“函数式”的，这意味着它们不会改变现有的序列，而是在调用时返回一个新的序列，除了 **foreach** 它返回 **Unit** 。由于这种函数式特点，可以在字符串上使用链式调用。

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"scala".drop(2).take(2).capitalize**

&nbsp;&nbsp;&nbsp;&nbsp;res0: String = Al

如果之前没有见过这种写法，这里简单介绍一下这个例子的工作原理：**drop** 是集合的一个方法，它从集合的开头丢弃指定数量的元素，保留剩余的元素。当这里调用 **drop(2)** 时，它从字符串( **scala** )中丢掉前两个字符( **sc** )，并返回剩余的元素。

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"scala".drop(2)**

&nbsp;&nbsp;&nbsp;&nbsp;res0: String = ala

然后， **take(2)** 方法 *保留* 它所给的字符串"ala"中的前2个字符，并丢弃其他字符：

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"scala".drop(2).take(2)**

&nbsp;&nbsp;&nbsp;&nbsp;res1: String = al

最后，调用 **capitalize** 得到最终结果

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"scala".drop(2).take(2).capitalize**

&nbsp;&nbsp;&nbsp;&nbsp;res2: String = Al

如果不熟悉这样的链式调用，它被称为流式编程风格。参见小节 8.8 "对流式编程风格的支持"以了解更多的信息。函数式编程中这种代码非常常见，每个函数都是纯函数并返回一个值。这种风格同样在RxJava和RxScala等Rx技术中很流行，也被大量用于Spark中。

### 这些方法从哪来？

熟悉Java的人都知道Java的 **字符串** 类并没有 **capitalize** 方法，所以Scala上有这个方法可能会让人惊讶。Scala字符串在Java字符串的基础上扩充了几十个额外的方法，而这些方法可以通过Eclipse或者IntelliJ IDEA等IDE的“代码辅助”功能看到。

而当通过这种方式看到这些可用的方法并且得知Scala没有字符串类时，会不会觉得很神奇。如果没有字符串类，字符串是如何拥有这些方法的？

其工作原理是Scala通过隐式转换和扩展方法“继承”了Java的字符串类，而完成向其添加方法的功能。*隐式转换* 是Scala 2中向封闭类添加方法的方式，而 *扩展方法* 则是Scala3 添加的方式。关于如何创建扩展方法的细节，参见8.9小节，“用扩展方法向封闭类添加新方法”。

虽然这可能会随着时间的推移而改变，但在Scala3.0中，Scala **字符串** 许多额外方法是定义在 **StringOps** 类中，定义在 **StringOps** 类中的方法会随着 **scala.Predef** 自动导入到代码中，在 Scala 2.13的 **Predef** 对象中（它也被Scala3所使用）可以找到这个隐式转换以及相关文档。

```scala
/** The `String` type in Scala has all the methods of the underlying 
* `java.lang.String`, of which it is just an alias ... In addition, 
* extension methods in scala.collection.StringOps 
* are added implicitly through the conversion augmentString.
*/ 
@inline implicit def augmentString(x: String): StringOps = new StringOps(x)
```

**augmentString** 将一个 **字符串** 转换成一个 **StringOps** 。这样做会将 **StringOps** 中的方法添加到所有的Scala **字符串** 实例中。这其中包括像 **drop** 、 **take** 和 **filter** 这些能把字符串当作字符序列处理的方法。

（松鼠图）

#### 阅读Predef源代码

我强烈建议Scala的初学者看一下Scala 2.13的 [scala.Predef](https://www.scala-lang.org/api/current/scala/Predef$.html) 的源码，可以在前面的Scaladoc页面上找到源代码链接，它提供了许多和Scala编程特性相关的例子。可以看到它时如何引入其他像 **StringOps** 和 **WrappedString** 这样的类型的