#  字符串

作为程序员，我们经常和字符串打交道，如名字，地址，电话号码等等。Scala的字符串非常棒，因为它们不仅拥有Java字符串的全部功能，还有一些额外的功能。在本章中，将会在其中一些小节中展示与字符串格式化和正则模式相同的功能，而其他的小节则展示了Scala字符串独有的功能。

Scala与Java语法一个最大的区别是字符串的声明方式。所有的Scala变量都是以 **val** 或 **var** 的形式声明的，因此一个字符串变量通常是这样创建的：

```scala
val s = "Hello, world"
```

这个表达式与下面的Java代码等价：

```java
final String s = "Hello, world"
```

在Scala中，一般来说总是将变量声明为 **val** ，除非有充分的理由使用 **var** （纯函数式编程要求则更严格，禁止使用 **var**）

也可以 *显示* 声明成 **字符串** 类型：

```scala
val s: String = "Hello, world" // 不要这么做
       ______
```

这么做只会让代码变得冗长，所以并不推荐这么做。因为Scala的 *类型推断* 非常强大，使用第一个例子中的隐式语法已经是首选方式了。在实际情况下，我其实只有在调用一个方法并且不确定其返回类型时，才会在创建变量时明确声明其类型，如：

```scala
val s: String = someObject.someMethod(42)
```

## Scala 字符串特性

赋予Scala字符串力量（超级力量！）的特性有：

- 能使用==来比较字符串的相等
- 多行字符串
- 字符串插值，可以写出类似 **println(s"Name: $name")** 的代码
- 数十种额外的函数方法可以将字符串当作字符序列来处理

本章中的小节展示了所有这些功能

### 字符串是字符序列

上面提到的一个重要观点是，Scala的字符串可以被当作字符序列来看待，也就是当作 **Seq[Char]** 。因此在以下例子中的字符串：

```scala
val s = "Big Belly Burger"
```

下面是一些“序列”常用的方法，可以在字符串上进行调用：

```scala
s.count(_ == 'B') // 3
s.dropRight(3) // "Big Belly Bur"
s.dropWhile(_ != ' ') // " Belly Burger"
s.filter(_ != ' ') // "BigBellyBurger"
s.sortWith(_ < _) // " BBBeeggillrruy"
s.take(3) // "Big"
s.takeRight(3) // "ger"
s.takeWhile(_ != 'r') // "Big Belly Bu"
```

这些方法都是 **Seq** 的标准方法，将在第11章中深入介绍。

## 链式方法调用

**Seq** 上所有的方法都是“函数式”的，这意味着它们不会改变现有的序列，而是在调用时返回一个新的序列，除了 **foreach** 它返回 **Unit** 。由于这种函数式特点，可以在字符串上使用链式调用。

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"scala".drop(2).take(2).capitalize**

&nbsp;&nbsp;&nbsp;&nbsp;res0: String = Al

如果之前没有见过这种写法，这里简单介绍一下这个例子的工作原理：**drop** 是集合的一个方法，它从集合的开头丢弃指定数量的元素，保留剩余的元素。当这里调用 **drop(2)** 时，它从字符串( **scala** )中丢掉前两个字符( **sc** )，并返回剩余的元素。

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"scala".drop(2)**

&nbsp;&nbsp;&nbsp;&nbsp;res0: String = ala

然后， **take(2)** 方法 *保留* 它所给的字符串"ala"中的前2个字符，并丢弃其他字符：

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"scala".drop(2).take(2)**

&nbsp;&nbsp;&nbsp;&nbsp;res1: String = al

最后，调用 **capitalize** 得到最终结果

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"scala".drop(2).take(2).capitalize**

&nbsp;&nbsp;&nbsp;&nbsp;res2: String = Al

如果不熟悉这样的链式调用，它被称为流式编程风格。参见小节 8.8 "对流式编程风格的支持"以了解更多的信息。函数式编程中这种代码非常常见，每个函数都是纯函数并返回一个值。这种风格同样在RxJava和RxScala等Rx技术中很流行，也被大量用于Spark中。

### 这些方法从哪来？

熟悉Java的人都知道Java的 **字符串** 类并没有 **capitalize** 方法，所以Scala上有这个方法可能会让人惊讶。Scala字符串在Java字符串的基础上扩充了几十个额外的方法，而这些方法可以通过Eclipse或者IntelliJ IDEA等IDE的“代码辅助”功能看到。

而当通过这种方式看到这些可用的方法并且得知Scala没有字符串类时，会不会觉得很神奇。如果没有字符串类，字符串是如何拥有这些方法的？

其工作原理是Scala通过隐式转换和扩展方法“继承”了Java的字符串类，而完成向其添加方法的功能。*隐式转换* 是Scala 2中向封闭类添加方法的方式，而 *扩展方法* 则是Scala3 添加的方式。关于如何创建扩展方法的细节，参见8.9小节，“用扩展方法向封闭类添加新方法”。

虽然这可能会随着时间的推移而改变，但在Scala3.0中，Scala **字符串** 许多额外方法是定义在 **StringOps** 类中，定义在 **StringOps** 类中的方法会随着 **scala.Predef** 自动导入到代码中，在 Scala 2.13的 **Predef** 对象中（它也被Scala3所使用）可以找到这个隐式转换以及相关文档。

```scala
/** The `String` type in Scala has all the methods of the underlying 
* `java.lang.String`, of which it is just an alias ... In addition, 
* extension methods in scala.collection.StringOps 
* are added implicitly through the conversion augmentString.
*/ 
@inline implicit def augmentString(x: String): StringOps = new StringOps(x)
```

**augmentString** 将一个 **字符串** 转换成一个 **StringOps** 。这样做会将 **StringOps** 中的方法添加到所有的Scala **字符串** 实例中。这其中包括像 **drop** 、 **take** 和 **filter** 这些能把字符串当作字符序列处理的方法。

（松鼠图）

#### 阅读Predef源代码

我强烈建议Scala的初学者看一下Scala 2.13的 [scala.Predef](https://www.scala-lang.org/api/current/scala/Predef$.html) 的源码，可以在前面的Scaladoc页面上找到源代码链接，它提供了许多和Scala编程特性相关的例子。可以看到它时如何引入其他像 **StringOps** 和 **WrappedString** 这样的类型的

## 字符串相等

### 问题

如何比较两个字符串是否相等，即它们所包含的字符序列是否相同

### 解决方法

在Scala中可以通过 == 运算符来比较两个 **字符串** 。对于下面这些字符串：

```scala
val s1 = "Hello"
val s2 = "Hello"
val s3 = "H" + "ello"
```

可以像下面这样来测试它们是否相等：

```scala
s1 == s2 //true
s2 == s3 //true
```

使用==方法的好处在于即使一个字符串是null，在测试的过程中也不会抛出 **NullPointerException** 

```scala
val s4: String = null // String = null
s3 == s4 // false
s4 == s3 // false
```

如果想不区分大小写的比较两个字符串，一种方法是将两个字符串都转成大写或者小写然后通过==进行比较：

```scala
val s1 = "Hello" // Hello
val s2 = "hello" // hello
s1.toUpperCase == s2.toUpperCase // true
```

同样也可以使用Java **字符串** 提供的 **equalsIgnoreCase** 方法：

```scala
val a = "Kimberly"
val b = "kimberly"
a.equalsIgnoreCase(b) // true
```

注意，虽然对 null 字符串进行相等测试不会抛异常，但对null 字符串调用方法则会抛出 **NullPointerException**

```scala
val s1: String = null 
val s2: String = null

scala> s1.toUpperCase == s2.toUpperCase 
java.lang.NullPointerException // more output here ...
```

### 讨论

在Scala中使用==来判断两个对象是否相等，这和Java使用 **equals** 来判断两个对象相等是不一样的。

==方法是定义在所有引用类型的基类 **AnyRef** 上的，它会先检查是否是 **null** 值，然后对第一个对象调用 **equals** 来测试这两个对象是否相等。因此，当比较字符串相等时不需要检查 **null** 

方框：

#### 最好不要使用Null

在日常使用Scala中，*从来不* 需要使用 **null** 值。本节中的讨论旨在帮助理解当使用Java库或者其他库在遇到 **null** 值时 == 是如何工作的。

如果想像Java那样的语言使用 **null** 值，建议使用 **Option** 来代替。我发现假设Scala 没有 **null** 去写代码是很有帮助的。参见 24.6节“ 使用 Scala的错误处理类型(Option, Try 和 Either)来获取更多的例子与信息。

在Scala3中甚至可以改变类型系统，将那些继承自 **AnyRef** 的类型如 **String,List,Option** 等等 设置成 *不可空*

 。使用实验性的编译器选项 **-Yexplicit-nulls** 通过改变Scala的类型继承关系使得下面这段代码无法通过编译：

```scala
val s: String = null 
// won’t compile with '-Yexplicit-nulls'
```

参见Scala[显示使用null](https://docs.scala-lang.org/scala3/reference/other-new-features/explicit-nulls.html)获取更多信息。

### 另见

更多关于 == 和 **equals** 方法定义的信息见小节5.9 “定义相等方法(对象相等)“

## 2.2 创建多行字符串

### 问题

在Scala源代码中创建多行字符串，就像用其他语言的 *heredoc* 语法一样。

### 解决方法

在Scala中，可以通过使用三个引号将想创建成多行字符串的文本引起来即可：

```scala
val foo = """This is 
    a multiline 
    String"""
```

虽然这样能运行，但是这个例子中，第二行和第三行会在行首出现空白。打印这个字符串会看起来像这样：

```
This is
    a multiline 
    String
```

有好几种方法可以解决这个问题，最好的解决方式是在多行字符串的末尾加上 **stripMargin** 方法，并使用管道符号(|)作为第二行以及之后所有行的开头：

```scala
val speech = """Four score and 
               |seven years ago""".stripMargin
```

如果不喜欢使用|符号，则只需要在调用 **stripMargin** 指定想要的字符即可：

```scala
val speech = """Four score and 
               #seven years ago""".stripMargin('#')
```

当然也可以对第二行开始所有的行进行左对齐：

```scala
val foo = """Four score and 
seven years ago"""
```

所有以上方法都会产生一个同样的结果，即一个多行字符串，其中每一行都是左对齐的。

```
Four score and 
seven years ago
```

这些方法生成的结果是一个真正的多行字符串，每一行的末尾都有一个隐藏的 **\n** 字符。如果想把这个多行字符串转换成一个连续的行，可以在 **stripMargin** 后调用 **replaceAll** 方法，将所有的换行符替换成空格。

```scala
val speech = """Four score and
               |seven years ago 
               |our fathers...""".stripMargin.replaceAll("\n", " ")
```

这会生成：

```
Four score and seven years ago our fathers...
```

### 讨论

Scala多行字符串的另一大特性是，可以在字符串中直接使用单引号和双引号而不用转义：

```scala
val s = """This is known as a
          |"multiline" string 
          |or 'heredoc' syntax.""". stripMargin.replaceAll("\n", " ")
```

结果为：

```
This is known as a "multiline" string or 'heredoc' syntax.
```

## 2.3 分隔字符串

### 问题

如何根据字段分隔符将一个字符串分成几个部分，比如从逗号分隔符（CSV）或者管道分隔文件中得到特定的字符串。

### 解决方法

使用 **字符串** 对象上一个可用的 **split** 方法

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"hello world".split(" ")**

&nbsp;&nbsp;&nbsp;&nbsp;res0: Array[String] = Array(hello, world)

**split** 方法返回一个字符串数组。可以将其当作一个普通的数组。

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"hello world".split(" ").foreach(println)**

&nbsp;&nbsp;&nbsp;&nbsp;hello

&nbsp;&nbsp;&nbsp;&nbsp;world

### 讨论

可以使用简单字符作为分隔符来分隔字符串，就像用逗号作为CSV文件分隔符一样：

&nbsp;&nbsp;&nbsp;&nbsp;scala> **val s = "eggs, milk, butter, Cocoa Puffs"**

&nbsp;&nbsp;&nbsp;&nbsp;s: java.lang.String = eggs, milk, butter, Cocoa Puffs

&nbsp;&nbsp;&nbsp;&nbsp;// 1st attempt

&nbsp;&nbsp;&nbsp;&nbsp;scala> **s.split(",")**

&nbsp;&nbsp;&nbsp;&nbsp;res0: Array[String] = Array("eggs", " milk", " butter", " Cocoa Puffs")

使用这种方法，最好对每个字符串进行trim。在返回数组之前。使用 **map** 方法对每个字符串调用 **trim**

&nbsp;&nbsp;&nbsp;&nbsp;// 2nd attempt, cleaned up

&nbsp;&nbsp;&nbsp;&nbsp;scala> **s.split(",").map(_.trim)**

&nbsp;&nbsp;&nbsp;&nbsp;res1: Array[String] = Array(eggs, milk, butter, Cocoa Puffs)

也可以使用正则表达式来分隔一个字符串，下面这个例子告诉我们如何根据空白字符来分隔字符串：

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"Relax, nothing is under control".split("\\s+")**

&nbsp;&nbsp;&nbsp;&nbsp;res0: Array[String] = Array(Relax,, nothing, is, under, control)

（小鸟图）

#### 不是所有CSV文件都一样

注意，一些声称自己是CSV文件的文件实际上可能在其字段中包含逗号，他们通常会使用单引号或者双引号引起来，而其他文件可能在其字段中包含换行符。理这类文件的算法将比所示方法更复杂。更多信息见维基百科关于[CSV](https://en.wikipedia.org/wiki/Comma-separated_values)文件的条目。

#### 关于那个 split 方法

**split** 方法有多个重载版本，有些来自于Java的 **String** 类，而有的版本来自于 Scala 的 **StringOps** ，例如，如果用 **Char** 作为参数而不是 **String** 作为参数来调用 **split** ,就使用的是 **StringOps** 的 **split** 

```scala
// split with a String argument (from Java) 
"hello world".split(" ") //Array(hello, world)

// split with a Char argument (from Scala) 
"hello world".split(' ') //Array(hello, world)
```

## 2.4 字符串中的变量替换

### 问题

将一个字符串中的变量进行替换，就像其他语言如Perl，PHP，和Ruby中一样。

### 解决方法

要在Scala中使用基本的字符串插值，需要在字符串前加上字母s，并在字符串中包含需要替换的变量，变量名称前面需要加上 **$** 字符，参照下面 **println** 中的语句：

&nbsp;&nbsp;&nbsp;&nbsp;val name = "Fred"

&nbsp;&nbsp;&nbsp;&nbsp;val age = 33

&nbsp;&nbsp;&nbsp;&nbsp;val weight = 200.00



&nbsp;&nbsp;&nbsp;&nbsp;scala> **println(s"$name is $age years old and weighs $weight pounds.")**

&nbsp;&nbsp;&nbsp;&nbsp;Fred is 33 years old and weighs 200.0 pounds.

根据Scala官方的字符串插值文档，当在字符串前面加上字母 **s** 时，就是在创建一个经过 *处理* 的字符串字面量。这个例子使用了 " **s** 字符串插值器"，它可以让你在字符串中嵌入变量，变量被替换成它们的值。

#### 在字符串字面量中使用表达式

除了把简单的变量放在字符串中，还可以将 *表达式* 放在字符串的大括号里，在下面的例子中，会把 **age** 加一后的结果放到字符串中。

&nbsp;&nbsp;&nbsp;&nbsp;scala> **println(s"Age next year: ${age + 1}")**

&nbsp;&nbsp;&nbsp;&nbsp;Age next year: 34

下面这个例子展示了在大括号中使用相等判断

&nbsp;&nbsp;&nbsp;&nbsp;scala> **println(s"You are 33 years old: ${age == 33}")**

&nbsp;&nbsp;&nbsp;&nbsp;You are 33 years old: true

在打印对象字段时也需要使用大括号：

```
case class Student(name: String, score: Int) 
val hannah = Student("Hannah", 95)

scala> println(s"${hannah.name} has a score of ${hannah.score}") 
Hannah has a score of 95
```

注意，如果不使用大括号去打印对象的字段，打印出的信息会与所预期不相符：

```
// error: this is intentionally wrong 
scala> println(s"$hannah.name has a score of $hannah.score") 
Student(Hannah,95).name has a score of Student(Hannah,95).score
```

### 讨论

放在字符串前面的 **s** 实际上是一个方法。虽然这似乎比直接把变量放在字符串里要显得不是那么方便，但这么做只少有两个好处：

- Scala提供了其他插值函数，这让你有更多的掌控力
- 任何人都可以定义自己的字符串插值函数。如，Scala的SQL库就利用了这种能力，可以写出像 **sql "SELECT * FROM USERS "** 的查询。

我们来看看另外两个Scala内置的插值函数。

#### 字符串插值f(printf 格式化)

在解决方法的例子中， **weight** 打印为 **200.0** 。 这完全正确，但如果想在 weight上多打印几位小数，或者完全删除它们，该怎么做呢？

这个简单的需求产生了“f字符串插值“，一个可以通过 **printf** 格式化内部字符串的方法。接下来的例子会说明如何打印保留两位小数的 **weight** ：

&nbsp;&nbsp;&nbsp;&nbsp;scala> **println(f"$name is $age years old and weighs $weight%.2f pounds.")**

&nbsp;&nbsp;&nbsp;&nbsp;Fred is 33 years old and weighs 200.00 pounds.

不保留小数：


&nbsp;&nbsp;&nbsp;&nbsp;scala> **println(f"$name is $age years old and weighs $weight%.0f pounds.")**

&nbsp;&nbsp;&nbsp;&nbsp;Fred is 33 years old and weighs 200 pounds.

如上所述，用这种方法只需要做到如下两步：

1. 在字符串前加 **f**
2. 在变量后使用printf风格的格式化指定符

（小鸟图）

#### printf 格式化指定符

最常用的 **printf** 格式化指定符会在2.5节中被列举

虽然这些例子使用了**println**方法，但需要注意的是，完全可以将变量替换的结果赋给一个新的变量，类似于在其他语言中使用**sprintf** ：

&nbsp;&nbsp;&nbsp;&nbsp;scala> val s = f"$name, you weigh $weight%.0f pounds."

&nbsp;&nbsp;&nbsp;&nbsp;s: String = Fred, you weigh 200 pounds.

现在 **s** 只是一个普通的字符串，可以用在任何需要字符串的地方。

#### raw插入符

除了 **s** 和 **f** 字符串插入符之外，Scala还包含另一个叫做 **raw** 的插入符。使用 **raw** 插入符不会对字符串里的任何转义字符进行转义。下面这个例子是对 **raw** 与 **s** 插入符进行比较：

```
scala> s"foo\nbar" 
val res0: String = foo 
bar

scala> raw"foo\nbar" 
res1: String = foo\nbar
```



如上所示， **s** 会对 **\n** 转义成换行符而 **raw** 不对其做任何转义，只是将其当作普通字符处理。

（松鼠图）

#### 创建自定义插值器

除了 **s** ， **f** 和 **raw** 插值器，还可以定义自己的插值器。2.11 小节给出了如何创建自己的插值器的例子。

### 另见

- 2.5小节列举了许多常用的字符串格式化的字符。
- [Oracle Formatter class documentation](https://oreil.ly/gEAsi)有完整的字符串格式化字符的列表。
- [The official Scala string interpolation page](https://docs.scala-lang.org/overviews/core/string-interpolation.html)有更多关于插值器的细节
- 2.11 小节给出了如何创建自己的插值器的例子。

