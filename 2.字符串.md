#  字符串

作为程序员，我们经常和字符串打交道，如名字，地址，电话号码等等。Scala的字符串非常棒，因为它们不仅拥有Java字符串的全部功能，还有一些额外的功能。在本章中，将会在其中一些小节中展示与字符串格式化和正则模式相同的功能，而其他的小节则展示了Scala字符串独有的功能。

Scala与Java语法一个最大的区别是字符串的声明方式。所有的Scala变量都是以 **val** 或 **var** 的形式声明的，因此一个字符串变量通常是这样创建的：

```scala
val s = "Hello, world"
```

这个表达式与下面的Java代码等价：

```java
final String s = "Hello, world"
```

在Scala中，一般来说总是将变量声明为 **val** ，除非有充分的理由使用 **var** （纯函数式编程要求则更严格，禁止使用 **var**）

也可以 *显示* 声明成 **字符串** 类型：

```scala
val s: String = "Hello, world" // 不要这么做
       ______
```

这么做只会让代码变得冗长，所以并不推荐这么做。因为Scala的 *类型推断* 非常强大，使用第一个例子中的隐式语法已经是首选方式了。在实际情况下，我其实只有在调用一个方法并且不确定其返回类型时，才会在创建变量时明确声明其类型，如：

```scala
val s: String = someObject.someMethod(42)
```

## Scala 字符串特性

赋予Scala字符串力量（超级力量！）的特性有：

- 能使用==来比较字符串的相等
- 多行字符串
- 字符串插值，可以写出类似 **println(s"Name: $name")** 的代码
- 数十种额外的函数方法可以将字符串当作字符序列来处理

本章中的小节展示了所有这些功能

### 字符串是字符序列

上面提到的一个重要观点是，Scala的字符串可以被当作字符序列来看待，也就是当作 **Seq[Char]** 。因此在以下例子中的字符串：

```scala
val s = "Big Belly Burger"
```

下面是一些“序列”常用的方法，可以在字符串上进行调用：

```scala
s.count(_ == 'B') // 3
s.dropRight(3) // "Big Belly Bur"
s.dropWhile(_ != ' ') // " Belly Burger"
s.filter(_ != ' ') // "BigBellyBurger"
s.sortWith(_ < _) // " BBBeeggillrruy"
s.take(3) // "Big"
s.takeRight(3) // "ger"
s.takeWhile(_ != 'r') // "Big Belly Bu"
```

这些方法都是 **Seq** 的标准方法，将在第11章中深入介绍。

## 链式方法调用

**Seq** 上所有的方法都是“函数式”的，这意味着它们不会改变现有的序列，而是在调用时返回一个新的序列，除了 **foreach** 它返回 **Unit** 。由于这种函数式特点，可以在字符串上使用链式调用。

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"scala".drop(2).take(2).capitalize**

&nbsp;&nbsp;&nbsp;&nbsp;res0: String = Al

如果之前没有见过这种写法，这里简单介绍一下这个例子的工作原理：**drop** 是集合的一个方法，它从集合的开头丢弃指定数量的元素，保留剩余的元素。当这里调用 **drop(2)** 时，它从字符串( **scala** )中丢掉前两个字符( **sc** )，并返回剩余的元素。

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"scala".drop(2)**

&nbsp;&nbsp;&nbsp;&nbsp;res0: String = ala

然后， **take(2)** 方法 *保留* 它所给的字符串"ala"中的前2个字符，并丢弃其他字符：

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"scala".drop(2).take(2)**

&nbsp;&nbsp;&nbsp;&nbsp;res1: String = al

最后，调用 **capitalize** 得到最终结果

&nbsp;&nbsp;&nbsp;&nbsp;scala> **"scala".drop(2).take(2).capitalize**

&nbsp;&nbsp;&nbsp;&nbsp;res2: String = Al

如果不熟悉这样的链式调用，它被称为流式编程风格。参见小节 8.8 "对流式编程风格的支持"以了解更多的信息。函数式编程中这种代码非常常见，每个函数都是纯函数并返回一个值。这种风格同样在RxJava和RxScala等Rx技术中很流行，也被大量用于Spark中。

### 这些方法从哪来？

熟悉Java的人都知道Java的 **字符串** 类并没有 **capitalize** 方法，所以Scala上有这个方法可能会让人惊讶。Scala字符串在Java字符串的基础上扩充了几十个额外的方法，而这些方法可以通过Eclipse或者IntelliJ IDEA等IDE的“代码辅助”功能看到。

而当通过这种方式看到这些可用的方法并且得知Scala没有字符串类时，会不会觉得很神奇。如果没有字符串类，字符串是如何拥有这些方法的？

其工作原理是Scala通过隐式转换和扩展方法“继承”了Java的字符串类，而完成向其添加方法的功能。*隐式转换* 是Scala 2中向封闭类添加方法的方式，而 *扩展方法* 则是Scala3 添加的方式。关于如何创建扩展方法的细节，参见8.9小节，“用扩展方法向封闭类添加新方法”。

虽然这可能会随着时间的推移而改变，但在Scala3.0中，Scala **字符串** 许多额外方法是定义在 **StringOps** 类中，定义在 **StringOps** 类中的方法会随着 **scala.Predef** 自动导入到代码中，在 Scala 2.13的 **Predef** 对象中（它也被Scala3所使用）可以找到这个隐式转换以及相关文档。

```scala
/** The `String` type in Scala has all the methods of the underlying 
* `java.lang.String`, of which it is just an alias ... In addition, 
* extension methods in scala.collection.StringOps 
* are added implicitly through the conversion augmentString.
*/ 
@inline implicit def augmentString(x: String): StringOps = new StringOps(x)
```

**augmentString** 将一个 **字符串** 转换成一个 **StringOps** 。这样做会将 **StringOps** 中的方法添加到所有的Scala **字符串** 实例中。这其中包括像 **drop** 、 **take** 和 **filter** 这些能把字符串当作字符序列处理的方法。

（松鼠图）

#### 阅读Predef源代码

我强烈建议Scala的初学者看一下Scala 2.13的 [scala.Predef](https://www.scala-lang.org/api/current/scala/Predef$.html) 的源码，可以在前面的Scaladoc页面上找到源代码链接，它提供了许多和Scala编程特性相关的例子。可以看到它时如何引入其他像 **StringOps** 和 **WrappedString** 这样的类型的

## 字符串相等

### 问题

如何比较两个字符串是否相等，即它们所包含的字符序列是否相同

### 解决方法

在Scala中可以通过 == 运算符来比较两个 **字符串** 。对于下面这些字符串：

```scala
val s1 = "Hello"
val s2 = "Hello"
val s3 = "H" + "ello"
```

可以像下面这样来测试它们是否相等：

```scala
s1 == s2 //true
s2 == s3 //true
```

使用==方法的好处在于即使一个字符串是null，在测试的过程中也不会抛出 **NullPointerException** 

```scala
val s4: String = null // String = null
s3 == s4 // false
s4 == s3 // false
```

如果想不区分大小写的比较两个字符串，一种方法是将两个字符串都转成大写或者小写然后通过==进行比较：

```scala
val s1 = "Hello" // Hello
val s2 = "hello" // hello
s1.toUpperCase == s2.toUpperCase // true
```

同样也可以使用Java **字符串** 提供的 **equalsIgnoreCase** 方法：

```scala
val a = "Kimberly"
val b = "kimberly"
a.equalsIgnoreCase(b) // true
```

注意，虽然对 null 字符串进行相等测试不会抛异常，但对null 字符串调用方法则会抛出 **NullPointerException**

```scala
val s1: String = null 
val s2: String = null

scala> s1.toUpperCase == s2.toUpperCase 
java.lang.NullPointerException // more output here ...
```

### 讨论

在Scala中使用==来判断两个对象是否相等，这和Java使用 **equals** 来判断两个对象相等是不一样的。

==方法是定义在所有引用类型的基类 **AnyRef** 上的，它会先检查是否是 **null** 值，然后对第一个对象调用 **equals** 来测试这两个对象是否相等。因此，当比较字符串相等时不需要检查 **null** 

方框：

#### 最好不要使用Null

在日常使用Scala中，*从来不* 需要使用 **null** 值。本节中的讨论旨在帮助理解当使用Java库或者其他库在遇到 **null** 值时 == 是如何工作的。

如果想像Java那样的语言使用 **null** 值，建议使用 **Option** 来代替。我发现假设Scala 没有 **null** 去写代码是很有帮助的。参见 24.6节“ 使用 Scala的错误处理类型(Option, Try 和 Either)来获取更多的例子与信息。

在Scala3中甚至可以改变类型系统，将那些继承自 **AnyRef** 的类型如 **String,List,Option** 等等 设置成 *不可空*

 。使用实验性的编译器选项 **-Yexplicit-nulls** 通过改变Scala的类型继承关系使得下面这段代码无法通过编译：

```scala
val s: String = null 
// won’t compile with '-Yexplicit-nulls'
```

参见Scala[显示使用null](https://docs.scala-lang.org/scala3/reference/other-new-features/explicit-nulls.html)获取更多信息。

### 另见

更多关于 == 和 **equals** 方法定义的信息见小节5.9 “定义相等方法(对象相等)“

## 2.2 创建多行字符串

### 问题

在Scala源代码中创建多行字符串，就像用其他语言的 *heredoc* 语法一样。

### 解决方法

在Scala中，可以通过使用三个引号将想创建成多行字符串的文本引起来即可：

```scala
val foo = """This is 
    a multiline 
    String"""
```

虽然这样能运行，但是这个例子中，第二行和第三行会在行首出现空白。打印这个字符串会看起来像这样：

```
This is
    a multiline 
    String
```

有好几种方法可以解决这个问题，最好的解决方式是在多行字符串的末尾加上 **stripMargin** 方法，并使用管道符号(|)作为第二行以及之后所有行的开头：

```scala
val speech = """Four score and 
               |seven years ago""".stripMargin
```

如果不喜欢使用|符号，则只需要在调用 **stripMargin** 指定想要的字符即可：

```scala
val speech = """Four score and 
               #seven years ago""".stripMargin('#')
```

当然也可以对第二行开始所有的行进行左对齐：

```scala
val foo = """Four score and 
seven years ago"""
```

所有以上方法都会产生一个同样的结果，即一个多行字符串，其中每一行都是左对齐的。

```
Four score and 
seven years ago
```

这些方法生成的结果是一个真正的多行字符串，每一行的末尾都有一个隐藏的 **\n** 字符。如果想把这个多行字符串转换成一个连续的行，可以在 **stripMargin** 后调用 **replaceAll** 方法，将所有的换行符替换成空格。

```scala
val speech = """Four score and
               |seven years ago 
               |our fathers...""".stripMargin.replaceAll("\n", " ")
```

这会生成：

```
Four score and seven years ago our fathers...
```

### 讨论

Scala多行字符串的另一大特性是，可以在字符串中直接使用单引号和双引号而不用转义：

```scala
val s = """This is known as a
          |"multiline" string 
          |or 'heredoc' syntax.""". stripMargin.replaceAll("\n", " ")
```

结果为：

```
This is known as a "multiline" string or 'heredoc' syntax.
```

