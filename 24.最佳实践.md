# 24. 最佳实践

2010年时，当我第一次从Java来到Scala时，我对这些小事很开心，比如删除了很多**；**，**()**，和**{}**字符，使用不啰嗦的语言让我想起了Ruby。我不太了解编程语言的历史，我认为Scala是“具有类型的Ruby”，所有的这些小进步，从而创造了“更好的Java”。

随着时间的推移，我在剧目中加入了更多的内容，并且按照Scala的方式来使用它。正如Ward Cunningham在Robert C. Martin（Prentice Hall）的 *Clean Code* 一书中所引用的那样，我想写出 “让它看起来像是为问题而生的语言”的代码，所以我学习了集合类及其方法、for表达式、match表达式和模块化开发。这就是本章的内容：尝试分享Scala编程的一些最佳实践，以便你能以 “Scala方式” 编写代码。

在学习本章每个小节之前，先对Scala最佳实践做些简短总结：

在应用层：

- 正如Martin Odersky所说，为逻辑编写函数，为模块化创建对象。
- 当你写函数时，尽量把它们写成纯函数。按照80/20法则，把80%的应用程序写成纯函数，在这些函数之上再加一层薄薄的其他代码，如I/O。就像有人说的那样，这就像在纯FP蛋糕上放了一层薄薄的不纯的糖衣（尽管也有处理这些 ”不纯“代码的方法）。
- 将行为从类中移到粒度（granular）特质中。我在第六章中描述了这种方法。
- 使用Scala **Future**类和Akka（ *https://akka.io/* ）来实现并发。
- 当你更加深入FP时，使用像Cats（ *https://oreil.ly/fg5pO* ）、Monix（ *https://monix.io/* ）和ZIO（ *https://oreil.ly/TawQ6* ）这样的库（它们也支持并发）。

在日常编程层：

- 学习如何编写纯函数（24.1小节）。至少它们简化了要思考的问题。
- 与第一点有关，不要写抛出异常的函数。用**Option**、**Try**或**Either**等类型来代替返回。
- 同样地，不要使用像**head**、**tail**和**last**这类抛出异常的方法。
- 学习如何将函数作为变量来传递（见第10章）。
- 学习如何使用Scala集合API。了解最常见的类和方法。了解这些方法将使你不至于编写冗长的自定义for循环。
- 优先考虑不可变代码。首先使用**val**字段和不可变的集合（24.2小节）。
- 学习面向表达式编程（24.3小节）
- 函数式编程语言是模式匹配语言，所以要成为**match**表达式的专家（24.4小节）。
- 从你的词汇表中删除**null**关键字（24.5小节）。使用**Option**、**Try**和**Either**类型代替（24.6小节）。
- 模块化组织代码（24.7小节）。
- 使用测试驱动开发或行为驱动开发的测试工具，如ScalaTest（ *https://www.scalatest.org* ）和MUnit（ *https://scalameta.org/munit/* ），以及ScalaCheck（ *https://scalacheck.org/* ）这种基于属性的测试工具。
- 随着你对Scala越来越熟练，在处理**Option**、**Try**和**Either**类型时，学会使用高阶函数来取代**match**表达式，（24.8小节）。

代码之外：

- 学习如何使用sbt（如第17章所述）或其他自动构建工具。
- 在编码时可以把**REPL**打开，以便根据需要运行小型测试（1.1小节“Scala REPL入门”），或者使用Scastie（ *https://scastie.scala-lang.org/* ）或ScalaFiddle（ *https://scalafiddle.io/* ）等在线工具。

## 其他资源

除了本章分享的实践之外，Twitter的“Effective Scala”（ *https://oreil.ly/fCBTt* ）是一个很棒的资源。Twitter团队一直是Scala的忠实用户和支持者，这份文档总结了其使用经验。

Scala编程风格指南（ *https://docs.scala-lang.org/style* ）也是一个很棒的资源，它包含了使用Scala风格写代码的例子。



## 24.1 编写纯函数

### 问题

你想编写纯函数，同时也想了解纯函数的好处。

### 解决方案

令人惊讶的是，很难找到一个关于纯函数的一致定义，所以我将给你一个我在*Functional Programming, Simplified*一书中使用的总结定义：

纯函数是一个只依赖其声明的输入参数和其算法来产生输出的函数。它不从 "外部世界"--即函数范围之外的世界--读取任何其他值，也不修改外部世界的任何值。一个纯函数是完全的，这意味着它的结果对每一个可能的输入都有定义，而且它是确定的，这意味着它对一个给定的输入总是返回相同的值。

为了说明如何编写纯函数及其好处，在这个配方中，我将把一个面向对象编程风格的类中的方法转换成纯函数。

#### 面向对象方式

为了简化这个解决方案，下面这个OOP风格的类故意有一些缺陷。它不仅能够存储股票的信息，而且能够访问互联网以获得当前的股票价格，并进一步维护股票的历史价格列表：

```
    // a poorly written OOP-style class
    class Stock (
        var symbol: String,
        var company: String,
        var price: BigDecimal,
        var volume: Long
    ):
        var html: String = _ // null
        // create a url based on the stock symbol
        def buildUrl(stockSymbol: String): String = ...
        // this method calls out to the internet to get the url content,
        // such as getting a page from yahoo finance or a similar site
        def getUrlContent(url: String): String = ...
        def setPriceFromHtml(html: String): Unit =
        this.price = ...
        def setVolumeFromHtml(html: String): Unit =
        this.volume = ...
        def setHighFromHtml(html: String): Unit =
        this.high = ...
        def setLowFromHtml(html: String): Unit =
        this.low = ...
        
        // some DAO-like functionality
        private val _history: ArrayBuffer[Stock] = ...
        def getHistory = _history
```

除了试图做太多的事情，从FP的角度来看，它还有这些问题：

- 所有字段都是可变的。
- 所有**set*** 方法都会修改类字段。
- **getHistory**方法返回一个可变的数据结构。

**getHistory**方法很容易解决，在共享**ArrayBuffer**之前将其转换为像**Vector**那样的不可变的序列，但这个类有更深的问题。让我们来修复它们。

#### 修复问题

第一个解决方法是把耦合在类中的两个概念分开。首先，应该有一个股票的概念，一个股票只包括一个符号和公司名称。你可以把它变成一个样例类：

```
    case class Stock(symbol: String, company: String)
```

这方面的例子有 **Stock("AAPL", "Apple")** 和 **Stock("GOOG", "Google")** 。

其次，在任何时刻都有与股票在股市上的表现有关的信息。你可以把这个数据结构称为**StockInstance**，也可以把它定义为一个样例类。

```
    case class StockInstance(
        symbol: String,
        datetime: String,
        price: BigDecimal,
        volume: Long
    )
```

一个StockInstance的例子看起来像这样：

```
    StockInstance("AAPL", "Mar. 1, 2021 5:00pm", 127.79, 107_183_333)
```

这涵盖了解决方案的数据部分。现在让我们来看看如何处理这些行为：

#### 行为

回到原来的类，getUrlContent方法并不是专门针对股票的，应该移到一个不同的对象中，比如一个通用的**NetworkUtils**对象：

```
    object NetworkUtils:
        def getUrlContent(url: String): String = ???
```

这个方法接受一个URL作为参数，并返回该URL的HTML内容。

同样地，从股票符号建立一个URL的能力应该被移到一个对象中。因为这种行为是针对股票的，所以把它放在一个名为StockUtils的对象中：

```
    object StockUtils:
        def buildUrl(stockSymbol: String): String = ???
```

从HTML中提取股票价格的能力（即屏幕抓取）也可以写成一个纯函数，应该移到同一个对象中去：

```
    object StockUtils:
        def buildUrl(stockSymbol: String): String = ???
        def getPrice(html: String): String = ???
```

事实上，前一个类中所有名为 *set* *  的方法都应该是**StockUtils**中的 *get* * 方法:

```
    object StockUtils:
        def buildUrl(stockSymbol: String): String = ???
        def getPrice(symbol: String, html: String): String = ???
        def getVolume(symbol: String, html: String): String = ???
        def getHigh(symbol: String, html: String): String = ???
        def getLow(symbol: String, html: String): String = ???
```

**getPrice**、**getVolume**、**getHigh**和**getLow**等方法都是纯函数：给定相同的HTML字符串和股票符号，它们总是返回相同的值，而且它们没有副作用。

按照这个思考过程，代码将需要日期和时间函数，所以我把它们放在一个DateUtils对象中：

```
    object DateUtils:
    def currentDate: String = ???
    def currentTime: String = ???
```

这些并不是纯函数，但至少它们在一个合理的位置。

通过这个新的设计，你为当前日期和时间创建一个股票的实例，作为一系列简单的表达式。首先，从一个网页上检索描述股票的HTML：

```
    val stock = Stock("AAPL", "Apple")
    val url = StockUtils.buildUrl(stock.symbol)
    val html = NetworkUtils.getUrlContent(url)
```

一旦你有了HTML，提取所需的股票信息，获得日期，并创建股票实例：

```
    val price = StockUtils.getPrice(html)
    val volume = StockUtils.getVolume(html)
    val high = StockUtils.getHigh(html)
    val low = StockUtils.getLow(html)
    val date = DateUtils.currentDate
    val stockInstance = StockInstance(symbol, date, price, volume, high, low)
```

注意，所有的变量都是不可变的，每一行都是一个表达式。事实上，现在的代码非常简单，如果需要的话，你可以取消所有的中间变量：

```
    val html = NetworkUtils.getUrlContent(url)
    val stockInstance = StockInstance(
        symbol,
        DateUtils.currentDate,
        StockUtils.getPrice(html),
        StockUtils.getVolume(html),
        StockUtils.getHigh(html),
        StockUtils.getLow(html)
    )
```

这种简单性是使用纯函数的一大好处。"输出只取决于输入，没有副作用 "是纯函数的一个简单咒语。

如前所述，**getPrice**、**getVolume**、**getHigh**、**getLow**等方法都是纯函数。但是像**getDate**这样的方法呢？它不是一个纯函数，但事实是，你需要日期和时间来解决这个问题。这就是对纯函数有一个健康、平衡的态度的部分含义。

#### 鸽子栏TODO

有一些更强大的方法来处理不纯函数，这些方法将返回Option、Try或Either，或者使用外部库，如Cats或ZIO。然而，这些方法需要很长的时间来介绍。请参阅《函数式编程，简化版》以了解其中一些方法的细节。



作为对这个例子的最后说明，股票类不需要维护一个可变的股票实例的列表。假设股票信息存储在一个数据库中，你可以创建一个StockDao（"数据访问对象"）来查询数据：

```
    object StockDao:
        def getStockInstances(symbol: String): Seq[StockInstance] = ???
        // other code ...
```

虽然**getStockInstances**不是一个纯函数，但产生的**Seq**类是不可改变的，所以你可以放心地分享它，而不必担心它可能在你的应用程序中被修改。

#### 鸽子栏TODO

虽然我在许多方法的名称中使用了get前缀，但没有必要（也不常见）遵循类似JavaBeans的命名惯例。事实上，部分原因是你在Scala中写**setter**方法时不以**set**开头，部分原因是为了遵循统一访问原则（ *https://oreil.ly/THte4* ），许多Scala API根本不使用**get**或**set**。

比如说，想想Scala类。他们的accessor和mutator不使用get或set：

```
    class Person(var name: String)
    val p = Person("William")
    p.name // accessor
    p.name = "Bill" // mutator
```

#### StockUtils或者Stock对象

在前面的例子中被移到**StockUtils**类中的方法也可以放在**Stock**类的伴生对象中。也就是说，你可以把股票类和对象放在一个名为Stock.scala的文件中：

```
    case class Stock(symbol: String, company: String)
    
    object Stock:
        def buildUrl(stockSymbol: String): String = ???
        def getPrice(symbol: String, html: String): String = ???
        def getVolume(symbol: String, html: String): String = ???
        def getHigh(symbol: String, html: String): String = ???
        def getLow(symbol: String, html: String): String = ???
```

在这个例子中，我把这些方法放在**StockUtils**类中，以便清楚地把Stock类和对象的关注点分开。在你自己的实践中，使用你喜欢的任何方法。参见7.5小节了解更多关于伴生对象的细节。

### 讨论

如果你是从纯OOP背景来到Scala的，那么编写纯函数可能会出乎意料的困难。就我自己而言，在2010年之前，我的代码一直遵循着将数据和行为封装在类中的OOP范式，因此，我的方法几乎总是会改变对象的内部状态。转而使用纯函数和不可变的值需要一段时间来适应。

但编写纯函数的一个主要好处是，它自然而然地引导你进入函数式编程风格，你把代码写成代数表达式，然后组合这些表达式来解决更大的问题。这种编码风格的一个好处是，纯函数更容易测试。

例如，试图测试原始代码中的集合方法会很难。对于每个字段（价格、成交量、高点和低点），你必须遵循这些步骤：

1. 设置对象中的**html**字段。
2. 调用当前的**set**方法，如**setPriceFromHtml**。
3. 在内部，该方法读取私有的**html**类字段。
4. 当该方法执行时，它改变了类中的一个字段（**price**）。
5. 你必须得到那个字段来验证它是否被改变。
6. 在更复杂的类中，**html**和**price**字段有可能被类中的其他方法所修改

原始类的测试代码看起来是这样的：

```
    val stock = Stock("AAPL", "Apple", 0, 0)
    stock.buildUrl
    val html = stock.getUrlContent
    stock.getPriceFromHtml(html)
    assert(stock.getPrice == 200.0)
```

这是一个测试一个有副作用的方法的简单例子，当然，在一个大型的应用程序中，这可能会变得更加复杂。

相比之下，测试一个纯函数更容易：

1. 调用函数，传入一个已知值。
2. 从函数中获取一个结果。
3. 验证结果是否符合你的预期。

函数式方法的结果是测试代码是这样的：

```
    val url = NetworkUtils.buildUrl("AAPL")
    val html = NetworkUtils.getUrlContent(url)
    val price = StockUtils.getPrice(html)
    assert(price == 200.0)
```

虽然所显示的代码并没有短多少，但却简单多了。而且正如本书其他例子所示，由于纯函数是表达式，如果你愿意，它们也可以被简化为这种形式：

```
    val price = getPrice(getUrlContent(buildUrl("AAPL")))
    assert(price == 200.0)
```

在许多其他情况下，如果你有一系列不依赖于以特定顺序运行的纯表达式，你和编译器都可以自由地并行运行它们。

### 另见

## 24.2 使用不可变变量和集合

### 问题

### 解决方案

### 讨论

### 另见

## 24.3 编写表达式（而不是语句）

### 问题

### 解决方案

### 讨论

### 另见

## 24.4 使用match表达式和模式匹配

### 问题

### 解决方案

### 讨论

### 另见

## 24.5 消除代码中的空值

### 问题

### 解决方案

### 讨论

### 另见

## 24.6 使用Scala的错误处理类型（Option、Try和Either）

### 问题

### 解决方案

### 讨论

### 另见

## 24.7 构建模块化系统

### 问题

### 解决方案

### 讨论

### 另见

## 24.8 用高阶函数处理Option值

### 问题

### 解决方案

### 讨论

### 另见

