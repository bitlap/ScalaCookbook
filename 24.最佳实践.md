# 24. 最佳实践

2010年时，当我第一次从Java来到Scala时，我对这些小事很开心，比如删除了很多**；**，**()**，和**{}**字符，使用不啰嗦的语言让我想起了Ruby。我不太了解编程语言的历史，我认为Scala是“具有类型的Ruby”，所有的这些小进步，从而创造了“更好的Java”。

随着时间的推移，我在剧目中加入了更多的内容，并且按照Scala的方式来使用它。正如Ward Cunningham在Robert C. Martin（Prentice Hall）的 *Clean Code* 一书中所引用的那样，我想写出 “让它看起来像是为问题而生的语言”的代码，所以我学习了集合类及其方法、for表达式、match表达式和模块化开发。这就是本章的内容：尝试分享Scala编程的一些最佳实践，以便你能以 “Scala方式” 编写代码。

在学习本章每个小节之前，先对Scala最佳实践做些简短总结：

在应用层：

- 正如Martin Odersky所说，为逻辑编写函数，为模块化创建对象。
- 当你写函数时，尽量把它们写成纯函数。按照80/20法则，把80%的应用程序写成纯函数，在这些函数之上再加一层薄薄的其他代码，如I/O。就像有人说的那样，这就像在纯FP蛋糕上放了一层薄薄的不纯的糖衣（尽管也有处理这些 ”不纯“代码的方法）。
- 将行为从类中移到粒度（granular）特质中。我在第六章中描述了这种方法。
- 使用Scala **Future**类和Akka（ *https://akka.io/* ）来实现并发。
- 当你更加深入FP时，使用像Cats（ *https://oreil.ly/fg5pO* ）、Monix（ *https://monix.io/* ）和ZIO（ *https://oreil.ly/TawQ6* ）这样的库（它们也支持并发）。

在日常编程层：

- 学习如何编写纯函数（24.1小节）。至少它们简化了要思考的问题。
- 与第一点有关，不要写抛出异常的函数。用**Option**、**Try**或**Either**等类型来代替返回。
- 同样地，不要使用像**head**、**tail**和**last**这类抛出异常的方法。
- 学习如何将函数作为变量来传递（见第10章）。
- 学习如何使用Scala集合API。了解最常见的类和方法。了解这些方法将使你不至于编写冗长的自定义for循环。
- 优先考虑不可变代码。首先使用**val**字段和不可变的集合（24.2小节）。
- 学习面向表达式编程（24.3小节）
- 函数式编程语言是模式匹配语言，所以要成为**match**表达式的专家（24.4小节）。
- 从你的词汇表中删除**null**关键字（24.5小节）。使用**Option**、**Try**和**Either**类型代替（24.6小节）。
- 模块化组织代码（24.7小节）。
- 使用测试驱动开发或行为驱动开发的测试工具，如ScalaTest（ *https://www.scalatest.org* ）和MUnit（ *https://scalameta.org/munit/* ），以及ScalaCheck（ *https://scalacheck.org/* ）这种基于属性的测试工具。
- 随着你对Scala越来越熟练，在处理**Option**、**Try**和**Either**类型时，学会使用高阶函数来取代**match**表达式，（24.8小节）。

代码之外：

- 学习如何使用sbt（如第17章所述）或其他自动构建工具。
- 在编码时可以把**REPL**打开，以便根据需要运行小型测试（1.1小节“Scala REPL入门”），或者使用Scastie（ *https://scastie.scala-lang.org/* ）或ScalaFiddle（ *https://scalafiddle.io/* ）等在线工具。

## 其他资源

除了本章分享的实践之外，Twitter的“Effective Scala”（ *https://oreil.ly/fCBTt* ）是一个很棒的资源。Twitter团队一直是Scala的忠实用户和支持者，这份文档总结了其使用经验。

Scala编程风格指南（ *https://docs.scala-lang.org/style* ）也是一个很棒的资源，它包含了使用Scala风格写代码的例子。



## 24.1 编写纯函数

### 问题

### 解决方案

### 讨论

### 另见

## 24.2 使用不可变变量和集合

### 问题

### 解决方案

### 讨论

### 另见

## 24.3 编写表达式（而不是语句）

### 问题

### 解决方案

### 讨论

### 另见

## 24.4 使用match表达式和模式匹配

### 问题

### 解决方案

### 讨论

### 另见

## 24.5 消除代码中的空值

### 问题

### 解决方案

### 讨论

### 另见

## 24.6 使用Scala的错误处理类型（Option、Try和Either）

### 问题

### 解决方案

### 讨论

### 另见

## 24.7 构建模块化系统

### 问题

### 解决方案

### 讨论

### 另见

## 24.8 用高阶函数处理Option值

### 问题

### 解决方案

### 讨论

### 另见

