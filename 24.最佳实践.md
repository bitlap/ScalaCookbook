# 24. 最佳实践

2010年时，当我第一次从Java来到Scala时，我对这些小事很开心，比如删除了很多**；**，**()**，和**{}**字符，使用不啰嗦的语言让我想起了Ruby。我不太了解编程语言的历史，我认为Scala是“具有类型的Ruby”，所有的这些小进步，从而创造了“更好的Java”。

随着时间的推移，我在剧目中加入了更多的内容，并且按照Scala的方式来使用它。正如Ward Cunningham在Robert C. Martin（Prentice Hall）的 *Clean Code* 一书中所引用的那样，我想写出 “让它看起来像是为问题而生的语言”的代码，所以我学习了集合类及其方法、for表达式、match表达式和模块化开发。这就是本章的内容：尝试分享Scala编程的一些最佳实践，以便你能以 “Scala方式” 编写代码。

在学习本章每个小节之前，先对Scala最佳实践做些简短总结：

在应用层：

- 正如Martin Odersky所说，为逻辑编写函数，为模块化创建对象。
- 当你写函数时，尽量把它们写成纯函数。按照80/20法则，把80%的应用程序写成纯函数，在这些函数之上再加一层薄薄的其他代码，如I/O。就像有人说的那样，这就像在纯FP蛋糕上放了一层薄薄的不纯的糖衣（尽管也有处理这些 ”不纯“代码的方法）。
- 将行为从类中移到粒度（granular）特质中。我在第六章中描述了这种方法。
- 使用Scala **Future**类和Akka（ *https://akka.io/* ）来实现并发。
- 当你更加深入FP时，使用像Cats（ *https://oreil.ly/fg5pO* ）、Monix（ *https://monix.io/* ）和ZIO（ *https://oreil.ly/TawQ6* ）这样的库（它们也支持并发）。

在日常编程层：

- 学习如何编写纯函数（24.1小节）。至少它们简化了要思考的问题。
- 与第一点有关，不要写抛出异常的函数。用**Option**、**Try**或**Either**等类型来代替返回。
- 同样地，不要使用像**head**、**tail**和**last**这类抛出异常的方法。
- 学习如何将函数作为变量来传递（见第10章）。
- 学习如何使用Scala集合API。了解最常见的类和方法。了解这些方法将使你不至于编写冗长的自定义for循环。
- 优先考虑不可变代码。首先使用**val**字段和不可变的集合（24.2小节）。
- 学习面向表达式编程（24.3小节）
- 函数式编程语言是模式匹配语言，所以要成为**match**表达式的专家（24.4小节）。
- 从你的词汇表中删除**null**关键字（24.5小节）。使用**Option**、**Try**和**Either**类型代替（24.6小节）。
- 模块化组织代码（24.7小节）。
- 使用测试驱动开发或行为驱动开发的测试工具，如ScalaTest（ *https://www.scalatest.org* ）和MUnit（ *https://scalameta.org/munit/* ），以及ScalaCheck（ *https://scalacheck.org/* ）这种基于属性的测试工具。
- 随着你对Scala越来越熟练，在处理**Option**、**Try**和**Either**类型时，学会使用高阶函数来取代**match**表达式，（24.8小节）。

代码之外：

- 学习如何使用sbt（如第17章所述）或其他自动构建工具。
- 在编码时可以把**REPL**打开，以便根据需要运行小型测试（1.1小节“Scala REPL入门”），或者使用Scastie（ *https://scastie.scala-lang.org/* ）或ScalaFiddle（ *https://scalafiddle.io/* ）等在线工具。

## 其他资源

除了本章分享的实践之外，Twitter的“Effective Scala”（ *https://oreil.ly/fCBTt* ）是一个很棒的资源。Twitter团队一直是Scala的忠实用户和支持者，这份文档总结了其使用经验。

Scala编程风格指南（ *https://docs.scala-lang.org/style* ）也是一个很棒的资源，它包含了使用Scala风格写代码的例子。



## 24.1 编写纯函数

### 问题

你想编写纯函数，同时也想了解纯函数的好处。

### 解决方案

令人惊讶的是，很难找到一个关于纯函数的一致定义，所以我将给你一个我在*Functional Programming, Simplified*一书中使用的总结定义：

纯函数是一个只依赖其声明的输入参数和其算法来产生输出的函数。它不从 "外部世界"--即函数范围之外的世界--读取任何其他值，也不修改外部世界的任何值。一个纯函数是完全的，这意味着它的结果对每一个可能的输入都有定义，而且它是确定的，这意味着它对一个给定的输入总是返回相同的值。

为了说明如何编写纯函数及其好处，在这个配方中，我将把一个面向对象编程风格的类中的方法转换成纯函数。

#### 面向对象方式

为了简化这个解决方案，下面这个OOP风格的类故意有一些缺陷。它不仅能够存储股票的信息，而且能够访问互联网以获得当前的股票价格，并进一步维护股票的历史价格列表：

```
    // a poorly written OOP-style class
    class Stock (
        var symbol: String,
        var company: String,
        var price: BigDecimal,
        var volume: Long
    ):
        var html: String = _ // null
        // create a url based on the stock symbol
        def buildUrl(stockSymbol: String): String = ...
        // this method calls out to the internet to get the url content,
        // such as getting a page from yahoo finance or a similar site
        def getUrlContent(url: String): String = ...
        def setPriceFromHtml(html: String): Unit =
        this.price = ...
        def setVolumeFromHtml(html: String): Unit =
        this.volume = ...
        def setHighFromHtml(html: String): Unit =
        this.high = ...
        def setLowFromHtml(html: String): Unit =
        this.low = ...
        
        // some DAO-like functionality
        private val _history: ArrayBuffer[Stock] = ...
        def getHistory = _history
```

除了试图做太多的事情，从FP的角度来看，它还有这些问题：

- 所有字段都是可变的。
- 所有**set*** 方法都会修改类字段。
- **getHistory**方法返回一个可变的数据结构。

**getHistory**方法很容易解决，在共享**ArrayBuffer**之前将其转换为像**Vector**那样的不可变的序列，但这个类有更深的问题。让我们来修复它们。

#### 修复问题

第一个解决方法是把耦合在类中的两个概念分开。首先，应该有一个股票的概念，一个股票只包括一个符号和公司名称。你可以把它变成一个样例类：

```
    case class Stock(symbol: String, company: String)
```

这方面的例子有 **Stock("AAPL", "Apple")** 和 **Stock("GOOG", "Google")** 。

其次，在任何时刻都有与股票在股市上的表现有关的信息。你可以把这个数据结构称为**StockInstance**，也可以把它定义为一个样例类。

```
    case class StockInstance(
        symbol: String,
        datetime: String,
        price: BigDecimal,
        volume: Long
    )
```

一个StockInstance的例子看起来像这样：

```
    StockInstance("AAPL", "Mar. 1, 2021 5:00pm", 127.79, 107_183_333)
```

这涵盖了解决方案的数据部分。现在让我们来看看如何处理这些行为：

#### 行为

回到原来的类，getUrlContent方法并不是专门针对股票的，应该移到一个不同的对象中，比如一个通用的**NetworkUtils**对象：

```
    object NetworkUtils:
        def getUrlContent(url: String): String = ???
```

这个方法接受一个URL作为参数，并返回该URL的HTML内容。

同样地，从股票符号建立一个URL的能力应该被移到一个对象中。因为这种行为是针对股票的，所以把它放在一个名为StockUtils的对象中：

```
    object StockUtils:
        def buildUrl(stockSymbol: String): String = ???
```

从HTML中提取股票价格的能力（即屏幕抓取）也可以写成一个纯函数，应该移到同一个对象中去：

```
    object StockUtils:
        def buildUrl(stockSymbol: String): String = ???
        def getPrice(html: String): String = ???
```

事实上，前一个类中所有名为 *set* *  的方法都应该是**StockUtils**中的 *get* * 方法:

```
    object StockUtils:
        def buildUrl(stockSymbol: String): String = ???
        def getPrice(symbol: String, html: String): String = ???
        def getVolume(symbol: String, html: String): String = ???
        def getHigh(symbol: String, html: String): String = ???
        def getLow(symbol: String, html: String): String = ???
```

**getPrice**、**getVolume**、**getHigh**和**getLow**等方法都是纯函数：给定相同的HTML字符串和股票符号，它们总是返回相同的值，而且它们没有副作用。

按照这个思考过程，代码将需要日期和时间函数，所以我把它们放在一个DateUtils对象中：

```
    object DateUtils:
    def currentDate: String = ???
    def currentTime: String = ???
```

这些并不是纯函数，但至少它们在一个合理的位置。

通过这个新的设计，你为当前日期和时间创建一个股票的实例，作为一系列简单的表达式。首先，从一个网页上检索描述股票的HTML：

```
    val stock = Stock("AAPL", "Apple")
    val url = StockUtils.buildUrl(stock.symbol)
    val html = NetworkUtils.getUrlContent(url)
```

一旦你有了HTML，提取所需的股票信息，获得日期，并创建股票实例：

```
    val price = StockUtils.getPrice(html)
    val volume = StockUtils.getVolume(html)
    val high = StockUtils.getHigh(html)
    val low = StockUtils.getLow(html)
    val date = DateUtils.currentDate
    val stockInstance = StockInstance(symbol, date, price, volume, high, low)
```

注意，所有的变量都是不可变的，每一行都是一个表达式。事实上，现在的代码非常简单，如果需要的话，你可以取消所有的中间变量：

```
    val html = NetworkUtils.getUrlContent(url)
    val stockInstance = StockInstance(
        symbol,
        DateUtils.currentDate,
        StockUtils.getPrice(html),
        StockUtils.getVolume(html),
        StockUtils.getHigh(html),
        StockUtils.getLow(html)
    )
```

这种简单性是使用纯函数的一大好处。"输出只取决于输入，没有副作用 "是纯函数的一个简单咒语。

如前所述，**getPrice**、**getVolume**、**getHigh**、**getLow**等方法都是纯函数。但是像**getDate**这样的方法呢？它不是一个纯函数，但事实是，你需要日期和时间来解决这个问题。这就是对纯函数有一个健康、平衡的态度的部分含义。

#### 鸽子栏TODO

有一些更强大的方法来处理不纯函数，这些方法将返回Option、Try或Either，或者使用外部库，如Cats或ZIO。然而，这些方法需要很长的时间来介绍。请参阅《函数式编程，简化版》以了解其中一些方法的细节。



作为对这个例子的最后说明，股票类不需要维护一个可变的股票实例的列表。假设股票信息存储在一个数据库中，你可以创建一个StockDao（"数据访问对象"）来查询数据：

```
    object StockDao:
        def getStockInstances(symbol: String): Seq[StockInstance] = ???
        // other code ...
```

虽然**getStockInstances**不是一个纯函数，但产生的**Seq**类是不可改变的，所以你可以放心地分享它，而不必担心它可能在你的应用程序中被修改。

#### 鸽子栏TODO

虽然我在许多方法的名称中使用了get前缀，但没有必要（也不常见）遵循类似JavaBeans的命名惯例。事实上，部分原因是你在Scala中写**setter**方法时不以**set**开头，部分原因是为了遵循统一访问原则（ *https://oreil.ly/THte4* ），许多Scala API根本不使用**get**或**set**。

比如说，想想Scala类。他们的accessor和mutator不使用get或set：

```
    class Person(var name: String)
    val p = Person("William")
    p.name // accessor
    p.name = "Bill" // mutator
```

#### StockUtils或者Stock对象

在前面的例子中被移到**StockUtils**类中的方法也可以放在**Stock**类的伴生对象中。也就是说，你可以把股票类和对象放在一个名为Stock.scala的文件中：

```
    case class Stock(symbol: String, company: String)
    
    object Stock:
        def buildUrl(stockSymbol: String): String = ???
        def getPrice(symbol: String, html: String): String = ???
        def getVolume(symbol: String, html: String): String = ???
        def getHigh(symbol: String, html: String): String = ???
        def getLow(symbol: String, html: String): String = ???
```

在这个例子中，我把这些方法放在**StockUtils**类中，以便清楚地把Stock类和对象的关注点分开。在你自己的实践中，使用你喜欢的任何方法。参见7.5小节了解更多关于伴生对象的细节。

### 讨论

如果你是从纯OOP背景来到Scala的，那么编写纯函数可能会出乎意料的困难。就我自己而言，在2010年之前，我的代码一直遵循着将数据和行为封装在类中的OOP范式，因此，我的方法几乎总是会改变对象的内部状态。转而使用纯函数和不可变的值需要一段时间来适应。

但编写纯函数的一个主要好处是，它自然而然地引导你进入函数式编程风格，你把代码写成代数表达式，然后组合这些表达式来解决更大的问题。这种编码风格的一个好处是，纯函数更容易测试。

例如，试图测试原始代码中的集合方法会很难。对于每个字段（价格、成交量、高点和低点），你必须遵循这些步骤：

1. 设置对象中的**html**字段。
2. 调用当前的**set**方法，如**setPriceFromHtml**。
3. 在内部，该方法读取私有的**html**类字段。
4. 当该方法执行时，它改变了类中的一个字段（**price**）。
5. 你必须得到那个字段来验证它是否被改变。
6. 在更复杂的类中，**html**和**price**字段有可能被类中的其他方法所修改

原始类的测试代码看起来是这样的：

```
    val stock = Stock("AAPL", "Apple", 0, 0)
    stock.buildUrl
    val html = stock.getUrlContent
    stock.getPriceFromHtml(html)
    assert(stock.getPrice == 200.0)
```

这是一个测试一个有副作用的方法的简单例子，当然，在一个大型的应用程序中，这可能会变得更加复杂。

相比之下，测试一个纯函数更容易：

1. 调用函数，传入一个已知值。
2. 从函数中获取一个结果。
3. 验证结果是否符合你的预期。

函数式方法的结果是测试代码是这样的：

```
    val url = NetworkUtils.buildUrl("AAPL")
    val html = NetworkUtils.getUrlContent(url)
    val price = StockUtils.getPrice(html)
    assert(price == 200.0)
```

虽然所显示的代码并没有短多少，但却简单多了。而且正如本书其他例子所示，由于纯函数是表达式，如果你愿意，它们也可以被简化为这种形式：

```
    val price = getPrice(getUrlContent(buildUrl("AAPL")))
    assert(price == 200.0)
```

在许多其他情况下，如果你有一系列不依赖于以特定顺序运行的纯表达式，你和编译器都可以自由地并行运行它们。

### 另见

## 24.2 使用不可变变量和集合

### 问题

### 解决方案

### 讨论

### 另见

## 24.3 编写表达式（而不是语句）

### 问题

### 解决方案

### 讨论

### 另见

## 24.4 使用match表达式和模式匹配

### 问题

### 解决方案

### 讨论

### 另见

## 24.5 消除代码中的空值

### 问题

### 解决方案

### 讨论

### 另见

## 24.6 使用Scala的错误处理类型（Option、Try和Either）

### 问题

出于各种原因，包括从你的代码中移除**null**值，你想有效地使用**Option/Some/None**、**Try/Success/Failure**和**Either/Left/Right**类。

### 解决方案

本小节与24.5小节有一些重叠。本小节展示了在以下情况下，使用**Option**而不是**null**：

- 在函数和构造函数参数中使用**Option**。
- 使用**Option**来初始化类的字段（而不是使用**null**）。
- 将其他代码（如Java代码）中的**null**结果转换为**Option**。
- 从方法中返回**Option**。

24.5小节展示了在特定场景下如何使用**Option**。本节新加了这些解决方案：

- 从**Option**中提取值。
- 在集合中使用**Option**。
- 在框架中使用**Option**。
- 需要处理异常消息时，使用**Try/Success/Failure**。
- 需要处理异常消息时，使用**Either/Left/Right**。

#### 从**Option**中提取值

这里有两种方法来定义**makeInt**函数，它可以捕获到**toInt**可能抛出的异常并返回一个**Option**：

```
    import scala.util.control.Exception.allCatch
    def makeInt(s: String): Option[Int] = allCatch.opt(s.trim.toInt)

    import scala.util.{Try, Success, Failure}
    def makeInt(s: String): Option[Int] = Try(s.trim.toInt).toOption
```

作为一个返回 **Option** 的方法的消费者，有几种很好的方法来调用它并访问其结果：

- 使用**match**表达式。
- 使用**forEach**。
- 使用**getOrElse**。
- 使用高阶函数（HOF）。

根据你的需要，一个好的方式访问**makeInt**结果是使用**match**表达式。可以从**match**表达式中返回一个值：

```
    makeInt(aString) match
        case Some(i) => println(i)
        case None => println(0)
```

因为你可以把**Option**看成是有零个或一个元素的集合，所以**foreach**方法在这种情况下使用，把结果作为副作用来处理：

```
    makeInt(aString).foreach{ i =>
    	println(s"Got an int: $i")
    }
```

如果**makeInt**返回的是**Some**，这个例子就会打印这个值，但如果**makeInt**返回的是**None**，就会绕过**println**语句。

要（**a**）在方法成功时提取值，或（**b**）在方法失败时使用一个默认值，使用**getOrElse**：

```
    val x = makeInt("1").getOrElse(0) // 1
    val y = makeInt("A").getOrElse(0) // 0
```

你也可以使用**Option**中提供的**HOF**，如24.8小节所示。

#### 在Scala集合中使用**Option**

**Option**的另一大特点是它在Scala集合中经常被使用。例如，从一个字符串列表开始：

```
    val possibleNums = List("1", "2", "foo", "3", "bar")
```

试想你要从该字符串列表中转换所有整数的列表。通过将**makeInt**方法传递给**map**方法，你可以把集合中的每个元素转换为一个**Some**或**None**值：

```
    scala> possibleNums.map(makeInt)
    res0: List[Option[Int]] = List(Some(1), Some(2), None, Some(3), None)
```

这是个不错的开始。正如“flatten Seq[Option] ”所示，由于 **Option** 可以被认为包含零个或一个元素的集合，你可以通过在 **map** 后面添加 **flatten** 来将这个 **List[Option[Int]]** 值转换为 **List[Int]**：

```
    val a = possibleNums.map(makeInt).flatten // a: List[Int] = List(1, 2, 3)
```

如13.6小节“用flatten对列表进行扁平化处理”所示，这与使用**flatMap**类似：

```
    val a = possibleNums.flatMap(makeInt) // a: List[Int] = List(1, 2, 3)
```

**collect**方法提供了另一种方法来实现同样的结果：

```
    scala> possibleNums.map(makeInt).collect{case Some(i) => i}
    res0: List[Int] = List(1, 2, 3)
```

这个例子是有效的，因为**collect**方法需要一个偏函数，在这种情况下，我传入的匿名函数只为**Some**值定义，它忽略了**None**值。(参见10.7小节，“创建偏函数”，了解更多关于**collect**方法的细节）。

这些例子都是有效的，有几个原因：

- **makeInt**被定义为返回一个**Option**，尤其是一个**Option[Int]**。
- **flatten**、**flatMap**和**collect**这些集合方法都是为了处理**Option**值而建立的。
- 你可以将方法、函数和匿名函数传入到集合类的方法中。

#### 在框架中使用Option

当你想使用**Option/Some/None**方法，但又想写个在失败情况下返回错误信息的方法，有两套类似的错误处理类：

- **Try**、**Success**和**Failure**。
- **Either**、**Left**和**Right**。

在本节中，我将展示**Try/Success/Failure**类。

**Try**与**Option**类似，但它在一个**Failure**对象中返回异常信息，而**None**不会给你这些信息。用**Try**包装的计算结果将是下面一个类的子类：

- **Success** （类似于**Some**）。
- **Failure**（类似于**None**）。

如果计算成功，将返回**Success**实例，并包含想要的结果。如果抛出了异常，将返回**Failure**，并包含关于失败的信息。

为了说明这点，首先导入这些类然后创建一个测试函数：

```
    import scala.util.{Try,Success,Failure}
    def divideXByY(x: Int, y: Int): Try[Int] = Try(x/y)
```

只要**y**不为零，这个函数就会返回成功的结果。当**y**为零时，会抛出一个**ArithmeticException**异常。然而这个异常并没有在方法上抛出，而是被**Try**捕获，**Try**从方法中返回一个**Failure**对象。**REPL**展示了成功和失败案例是如何运行的：

```
    scala> divideXByY(1,1)
    res0: scala.util.Try[Int] = Success(1)

    scala> divideXByY(1,0)
    res1: scala.util.Try[Int] = Failure(java.lang.ArithmeticException: / by zero)
```

和**Option**一样，你可以使用**match**表达式、**foreach**、**getOrElse**或者24.8小节中的**HOF**来访问**Try**结果。例如，获取**Failure**中信息的一种方法是使用**match**表达式：

```
    divideXByY(1, 1) match
        case Success(i) => println(s"Success, value is: $i")
        case Failure(s) => println(s"Failed, message is: $s")
```

和**Option**一样，**foreach**可以很好地处理打印等副作用：

```
    divideXByY(1, 1).foreach(println) // prints 1
    divideXByY(1, 0).foreach(println) // no output is printed
```

如果你不关心错误信息，只想得到结果，可以使用**getOrElse**：

```
    val x = divideXByY(1, 1).getOrElse(0) // x: 1
    val y = divideXByY(1, 0).getOrElse(0) // y: 0
```

有了**Try**类，你可以把各种操作连在一起，在操作过程中捕捉异常。例如，下面的代码不会抛出异常，无论**x**和**y**的实际值是什么：

```
    // 'x' and 'y' are String values
    val z = for
        a <- Try(x.toInt)
        b <- Try(y.toInt)
    yield
    	a * b
    	
    val answer = z.getOrElse(0) * 2
```

如果**x**和**y**是 **"1"** 和 **"2"** 这样的**String**值，这段代码按预期工作，**answer**是一个**Int**值。如果**x**或**y**是一个不能转换为**Int**的字符串，**z**将会是一个**Failure**值：

```
    z: scala.util.Try[Int] =
    	Failure(java.lang.NumberFormatException: For input string: "one")
```

如果**x**或**y**为**null**，**z**将是这个值：

```
    z: scala.util.Try[Int] = Failure(java.lang.NumberFormatException: null)
```

无论是哪种**Failure**的情况，代码都会优雅地处理这些情况。

### 讨论

你也可以使用**Either**、**Left**和**Right**类来代替**Option**或**Try**。这段代码显示了两种编写**divideXByY**的方法，同时返回一个**Either**类型：

```
    // 1st approach
    import scala.util.control.Exception.allCatch
    def divideXByY(x: Int, y: Int): Either[Throwable, Int] = allCatch.either(x/y)
    
    // 2nd approach
    import scala.util.{Try,Success,Failure}
    def divideXByY(x: Int, y: Int): Either[Throwable, Int] = Try(x/y).toEither
```

如**Either**的类型签名所示，声明了方法返回的两种类型。按照惯例，**Left**类型包含你想返回的失败信息，而**Right**类型包含成功值。

**Either**比**Try**更灵活，因为它更通用。它实际上只是包含两种可能类型之一的值（技术上称为*disjoint union*）。你可以从它的类型签名中看到，它是一个包含两种可能类型的容器，**A**或**B**：

```
    Either[+A, +B]
```

当用于错误处理时，**Left**通常包含一个表示错误的**Throwable**或**String**，但由于**Either**实际上只是两个类型的容器，它可以用于任何东西。这段代码显示了使用**Either**编写**makeInt**方法的一种方式，其中左边的值现在是一个**String**：

```
    def makeInt(s: String): Either[String, Int] =
        try
            Right(s.trim.toInt)
        catch
            case e: Exception => Left(e.getMessage)
```

这些例子展示了调用**makeInt**可能产生的两种结果：

```
    makeInt("1") // Right(1)
    makeInt("a") // Left(For input string: "a")
```

**Either**是*right-biased*，这意味着**Right**是默认情况下的操作，所以像**map**这样的方法在默认情况下工作：

```
    makeInt("1").map(_ * 2) // Right(2)
    makeInt("a").map(_ * 2) // Left(For input string: "a")
```

正因为如此，**Either**在**for**表达式中工作地很好：

```
    val x =
        for
            a <- makeInt("1")
            b <- makeInt("2")
        yield
            a + b
    // result: x == Right(3)
```

**match**表达式的使用方式就像在**Option**和**Try**一样：

```
    makeInt(aString) match
        case Right(x) => println(s"Success, x = $x")
        case Left(s) => println(s"Failure, message = $s")
```

####  耗子栏TODO   使用Either是为使用FP库做准备

在审阅本章时，Hermann Hueck指出，使用**Either**的两个好处是：（**a**）它比**Try**更灵活，因为可以控制错误类型，（**b**）它可以让你提前准备好使用Cats（ *https://typelevel.org/cats/* ）和ZIO（ *https://zio.dev/* ）等FP库，它们大量使用了**Either**和类似的方法。

#### 不要使用get方法

当你第一次接触Scala时，你可能会用**get**方法来获取结果：

```
    val x = makeInt("5").get // x: 5
```

但不要这样做。这并不比**NullPointerException**好：

```
    val x = makeInt("foo").get // java.util.NoSuchElementException: None.get
```

最好的做法是不要对一个**Option**调用**get**。最好的方法是使用**match**表达式、**foreach**、**getOrElse** 或者24.8小节中的**HOF**。和**null**值一样，我发现最好是想象**get**方法不存在。

#### 其他方法

这些类型的另一个明显特点是它们所支持的方法。例如**Option**、**Try**和**Either**有这些共同的方法：

- 类似集合的方法，如**flatMap**、**flatten**、**fold**、**foreach**和**map**。
- 访问封闭值的方法，如**getOrElse**和**orElse**。

**Option**和**Try**有这些额外的共同方法：

- **collect**、**filter**

**Option**有这些额外的类似集合的方法：

- **contains**、**empty**、**exists**、**forall**、**isDefined**、**isEmpty**、**nonEmpty**、**reduce**、**take**和**takeWhile**

**Try**有额外的方法来帮助从错误中恢复：

- **recover**、**recoverWith**和**transform**，它们让你优雅地处理**Success**和**Failure**的结果。

**Either**有这些额外方法：

- **contains**、**filterOrElse**、**forall**以及更普遍的，额外的**left/right**操作方法，如**joinLeft**、**joinRight**、**left**和**swap**。

### 另见

- 更多信息参考**Option**（ *https://oreil.ly/BCTY1* ）、**Try**（ *https://oreil.ly/0nUE9* ）和**Either**（ *https://oreil.ly/3rQlz* ）类的Scaladoc。

## 24.7 构建模块化系统

### 问题

### 解决方案

### 讨论

### 另见

## 24.8 用高阶函数处理Option值

### 问题

使用**match**表达式来处理**Option**值很不错，但有些冗长。可以使用高阶函数处理**Option**值，这是更高级和简洁的方式。

### 解决方案

这个小节展示了在不同情况下处理**Option**值的高级方法，特别是如何使用高阶函数来取代**match**表达式，后者非常易读，但可能很冗长。其中的一些例子也适用于**Try**和**Either**类型。

#### 样例数据

表24-1中展示了高级的**HOF**（Higher Order Function）技术。这个表格表达的是：与其使用第二列中**match**表达式，不如使用第三列中的更简洁的**HOF**。

该表按照每个**match**表达式的结果类型进行排序，这就是你在试图解决问题时的想法，例如，“我需要打印**Some**中的值，我知道这是一个带副作用返回的**Unit**，我该怎么做？“ 在这种情况下，可以查看表格，并在第一行找到解决方案。所以你可以使用第二列中的**match**表达式，或者第三列中的选项。同样，当你想从**Some**中提取值时，使用第二行和第三行所示的解决方案，或者使用**default**值；在这两种解决方案中，结果的类型均为**A**。

作为这些解决方案的开始，这里有一些将在表格中使用的函数和值：

```
    // functions
    def p(i: Int): Boolean = i == 1           // type: A => Boolean (a predicate)
    def f(i: Int): Int = i * 2                // type: A => A
    def fo(i: Int): Option[Int] = Some(i * 2) // type: A => Option[A]
    
    // values
    val option: Option[Int] = Some(1)
    val none: Option[Int] = None
    
    val default = 0
    val defaultSome = Some(0)
    val stringOption = Option("foo")
```

在这个代码中：

- **p**是 **Int => Boolean** 类型的谓词（或者更一般地说，**A => Boolean**）。
- **f**是 **Int => Int** 类型的函数（或者更一般地说，**A => A**）。
- **fo**是返回一个**Option**的函数（所以**fo**的类型签名是**A => Option[A]**）。

关于表24-1中的例子：

- 因为你知道在特定情况下使用**Option**时需要的结果类型，所以表格是按照表达式的返回类型进行排序的，在第一列有所展示。
- 虽然我的代码使用的是**Int**值，但除了一个例子之外，你可以把表达式看成是使用了一个通用类型**A**。

考虑到这些背景，表24-1展示了一些例子，其中有相对较长的**match**表达和其对应的**HOFs**。

**表24-1** **Match表达式和它们等价的HOFs**

| 结果类型  | 匹配表达式                                                   | HOF                                                          |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Unit      | // use match for a side effect<br/>option match<br/>    case Some(i) => println(i)<br/>    case None => () | option.foreach(println)<br/><br />// or this:<br/>for o <- option do println(o) |
| A         | option match<br/>    case Some(i) => i<br/>    case None => default | option.getOrElse(default)<br/><br />option.fold(default)(x => x) |
| A         | // apply a function to the<br/>// option value<br/>option match<br/>    case Some(i) => f(i)<br/>    case None => default | option.map(f)<br/>.getOrElse(default)<br/><br />option.fold(default)(f) |
| Option[A] | option match<br/>    case Some(i) => fo(i)<br/>    case None => None | option.map(f)<br/><br />option.flatMap(i => fo(i))<br/><br />for i <- option yield f(i) |
| Option[A] | option match<br/>    case Some(x) => Some(x)<br/>    case None => defaultSome | option.orElse(defaultSome)                                   |
| Option[A] | option match<br/>    case Some(x) if p(x) =><br/>             Some(x)<br/>    case _ => None | option.filter(p)<br/>option.find(p)                          |
| Option[A] | option match<br/>    case Some(x) if !p(x) =><br/>              Some(x)<br/>    case None => None | option.filterNot(p)                                          |
| Boolean   | option match<br/>    case Some(x) => p(x)<br/>    case None => true | option.forall(p)                                             |
| Boolean   | option match<br/>    case Some(x) => p(x)<br/>    case None => false | option.exists(p)                                             |
| Boolean   | option match<br/>    case Some(a) => false<br/>    case None => true | option.isEmpty                                               |
| Boolean   | option match<br/>    case Some(x) => true<br/>    case None => false | option.isDefined<br/>option.nonEmpty                         |





| 结果类型                | 匹配表达式                                                   | HOF                                                          |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Boolean                 | // the example uses 'x == 1'<br/>// because I use Option[Int]<br/>option match<br/>    case Some(x) => x == 1<br/>    case None => false | option.contains(1)                                           |
| Int                     | option match<br/>    case Some(x) => 1<br/>    case None => 0 | option.size                                                  |
| Int                     | option match<br/>case Some(x) if p(x) => 1<br/>case _ => 0   | option.count(p)                                              |
| Seq, List, etc.         | option match<br/>case Some(x) => Seq(x)<br/>case None => Nil | option.toSeq<br/>option.toList<br/>(also toVector, toArray,<br/>toSet, etc.) |
| Either[Int,Int] = Right | option match<br/>case Some(x) => Right(x)<br/>case None => Left(default) | option.toRight(default)                                      |
| Either[Int,Int] = Left  | option match<br/>case Some(x) => Left(x)<br/>case None => Right(default) | option.toLeft(default)                                       |
| A or null               | stringOption match<br/>case Some(x) => x<br/>case None => null | // only use this for Java APIs<br/>// that need it<br/>stringOption.orNull |

注意，我把**null**的例子放在最后一行，因为你永远不该使用它。除非与一个需要它的Java API进行交互。

### 讨论

下面是一些例子，说明表24-1第三列的**HOF**是如何工作的：

```
    option.fold(default)(f)             // 2
    none.fold(default)(f)               // 0

    option.map(f).getOrElse(default)    // 2
    none.map(f).getOrElse(default)      // 0

    option.flatMap(i => fo(i))          // Some(2)
    none.flatMap(i => fo(i))            // None

    option.orElse(defaultSome)          // Some(1)
    none.orElse(defaultSome)            // Some(0)

    option.forall(p)                    // true

    option.find(p)                      // Some(1)
    option.filter(p)                    // Some(1)

    option.toSeq                        // Seq[Int] = List(1)
    none.toSeq                          // Seq[Int] = List()
```

有些例子如**fold**，乍一看可能有点难以理解，但是如果你仔细想想，它的使用与序列是一样的，**fold**需要一个初始种子值和一个**fold**函数。因为一个 **Option** 可以被认为是零个元素或一个元素的集合，种子值在 **Option** 为 **None** 的情况下作为默认值，而你提供的函数在 **Option** 为 **Some** 的情况下被使用。我认为代码在以后也能读懂。代码的可维护性——是非常重要的，所以我建议只使用你认为合适的代码。

### 另见

- 关于这些技术的更多例子，请观看Marconi Lanna在LambdaConf 2015视频（ *https://oreil.ly/AScOC* ），它有助于更好理解表格中的最后几个例子。

