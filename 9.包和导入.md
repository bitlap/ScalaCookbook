# 包和导入

包用于构建代码关联的模块，并且避免命名空间冲突。在最常见的形式中，可以用和Java相同的格式创建Scala的包.所以大部分Scala源代码文件以**package**声明开头，如下：

```scala
package com.alvinalexander.myapp.model
class Person ...`
```

然而Scala更加灵活，除了这种方法，还可以使用花括号的包风格，类似于C++和C#的命名空间。 9.1节展示了该语法。

Scala导入成员的方法与Java类似，而且更灵活。 在Scala里可以：

- 随处使用import语句。
- 导入类，包或者对象。
- 导入成员时隐藏和重命名成员。

本章演示了这些所有的方法。

在深入了解这些小节之前，有两个包被隐式导入到所有源代码文件的作用域中:

- **java.lang.***
- **scala.***

在Scala 3中，**import**语句中的 ***** 字符类似于 Java 中的 ***** 字符，因此这些语句表示“导入包中的每个成员”。

## Predef对象

除了这两个包之外，来自 **scala.Predef** 对象的所有成员也被隐式导入到源码文件中。

如果想了解Scala的工作原理，强烈建议花点时间深入研究**Predef** 对象的源码。 代码不长，但展示了Scala语言的很多特性。

正如我在第23页讨论“这些方法从何而来?” ，隐式转换被**Predef**对象引入到作用域中，在Scala 2.13的Predef对象——Scala 3.0仍在使用——代码如下所示：

```scala
implicit def long2Long(x: Long): java.lang.Long = x.asInstanceOf[java.lang.Long]
implicit def Long2long(x: java.lang.Long): Long = x.asInstanceOf[Long]
// more implicit conversions ...
```

同样，如果想知道为什么可以在不需要 **import** 语句的情况下调用 **Map**、**Set** 和 **println** 的代码，也可以在 **Predef** 中找到这些代码：

```scala
type Map[A, +B] = immutable.Map[A, B]
type Set[A] = immutable.Set[A]
def println(x: Any) = Console.println(x)
def printf(text: String, xs: Any*) = Console.print(text.format(xs: _*))
def assert(assertion: Boolean) { ... }
def require(requirement: Boolean) { ... }
```

# 9.1 花括号风格的包记号法

## 问题

使用嵌套风格的包表示法，类似于 C++ 和 C# 中的命名空间表示法。

## 解决方法

提供包名的同时，将一个或多个类包装在一对花括号内，如下所示：

```scala
package com.acme.store {
    class Foo:
    override def toString = "I am com.acme.store.Foo"
}
```

这个类的规范名称是**com.acme.store.Foo**。 和这样声明代码是一样的:

```scala
package com.acme.store
class Foo:
	override def toString = "I am com.acme.store.Foo"
```

### 好处

使用这种方法，可以将多个包放在一个文件中，也可以创建嵌套包。 为了演示这两种方法，以下例子创建了三个**Foo**类，都位于不同的包中：

```scala
package orderentry {
  class Foo:
  	override def toString = "I am orderentry.Foo"
}

package customers {
  class Foo:
 	 override def toString = "I am customers.Foo"
  
    package database {
    class Foo:
    	override def toString = "I am customers.database.Foo"
  }
}

// the output is shown after the comment tags.
@main def packageTests =
    println(orderentry.Foo()) // I am orderentry.Foo
    println(customers.Foo()) // I am customers.Foo
    println(customers.database.Foo()) // I am customers.database.Foo
```

这表明每个**Foo** 类都在不同的包中，并且**database**包嵌套在**customers**包中。

## 讨论

我看过很多Scala代码，据我所知，在文件顶部声明包名是最流行的包风格。

```scala
package foo.bar.baz

class Foo:
	override def toString = "I'm foo.bar.baz.Foo"
```

但是，由于Scala代码可以非常简洁，如果想在一个文件中声明多个类和包时，另一种花括号打包的语法会很方便。 比如在本书的源码仓库中，会看到我经常使用这种风格。

### 链式包子句

有时查看Scala程序时，会在源码文件的顶部看到多个包声明，如下所示：

```scala
package com.alvinalexander
package tests
...
```

这和编写两个嵌套的包的代码完全相同，如下所示：

```scala
package com.alvinalexander {
    package tests {
    ...
    }
}
```

使用第一种形式的原因是Scala程序员通常不喜欢使用花括号样式缩进代码，特别是在大文件中。所以他们用第一种形式。

使用两个包子句而不是一个，和每种方式在当前作用域中的可用性有关。如果只使用一条包语句：

```scala
package com.alvinalexander.tests
```

然而只有**com.alvinalexander.tests**的成员被引入作用域。但如果使用两个包声明：

```scala
package com.alvinalexander
package tests
...
```

**com.alvinalexander** 和 **com.alvinalexander.tests** 的成员都被引入作用域。

这种方式的原因和Scala 2.7中发现在Scala 2.8中解决的情况有关。详细信息可参考Martin Odersky文章 **chained package clauses**。

# 9.2 导入一个或多个成员

## 问题

将一个或多个成员导入当前代码的作用域。

## 解决方法

用这样语法导入一个类：

```scala
import java.io.File
```

还可以像这样导入多个类：

```scala
import java.io.File
import java.io.IOException
import java.io.FileNotFoundException
```

更简洁的像这样：

```scala
import java.io.{File, IOException, FileNotFoundException}
```

我将其称为花括号语法，但更正式地称为导入选择子句。

这样导入**java.io** 包中所有内容：

```scala
import java.io.* 
```

## 讨论

Scala非常灵活，你可以：

- 将 **import** 语句放在任何地方，包括类的顶部、类或对象内、方法内或代码块内。 9.6节展示了该技术。
- 导入包、类、对象和方法。
- 导入成员时隐藏和重命名成员。 9.3节和9.4节中展示这些技术。


# 9.3 导入时重命名成员

## 问题

在导入时重命成员，可以避免命名空间冲突或混淆。

## 解决方法

使用以下语法导入时，为导入的类指定一个新名字：

```scala
import java.awt.{List as AwtList}
```

然后在代码中，通过别名来引用这个类：

```scala
scala> val alist = AwtList(1, false)
val alist: java.awt.List = java.awt.List[list0,0,0,0x0,invalid,selected=null]
```

通过**AwtList**来使用**java.awt.List**类，也可以通过惯用名使用Scala **List**类：

```scala
scala> val x = List(1, 2, 3)
val x: List[Int] = List(1, 2, 3)
```

可以在导入的时候重命名多个类：

```scala
import java.util.{Date as JDate, HashMap as JHashMap}
```

还可以在导入的最后位置使用 ***** 字符从而导入其他所有内容（无需重命名其他成员）：

```scala
import java.util.{Date as JDate, HashMap as JHashMap, *}
```

在导入的时候创建了别名，所以不能在代码中使用类的原始（真实）名字。 在使用最后一个 **import** 语句后，下面代码将失败，编译器找不到 **java.util.HashMap** 类，因为被重命名：

```scala
scala> val map = HashMap[String, String]()
<console>:12: error: not found: type HashMap
	val map = HashMap[String, String]
```

正如预期的那样失败了，但是可以用别名来引用这个类：

```scala
scala> val map = JHashMap[String, String]()
map: java.util.HashMap[String,String] = {}
```

由于 **import** 语句末尾的 ***** 从 java.util 包中导入了其余所有内容，所以别的 **java.util** 类的代码可以使用：

```scala
scala> val x = ArrayList[String]()
x: java.util.ArrayList[String] = []

scala> val y = LinkedList[String]()
y: java.util.LinkedList[String] = []
```

## 讨论

如上所示，在导入时为类创建新名字，在用新名字或别名来引用类。 *Programming in Scala* 将这种做法称为重命名子句。

这样做有助于避免命名空间冲突和混淆。如Listener、Message、Handler、Client、Server 这些类的名字很常见，在导入时重命名会很有帮助。

Scala 3 的语法已改变。以下代码展示Scala3 与Scala 2的区别：

```scala
// scala 2
import java.util.{Date => JDate, HashMap => JHashMap, _}

// scala 3
import java.util.{Date as JDate, HashMap as JHashMap, *}
```

在编写本章时，仍可以在 Scala 3 代码中使用 Scala 2 语法，但下划线的语法最终会被淘汰，所以优先新语法。

这些有趣的技巧组合，不仅可以在导入时重命名类，也可以重命名类的成员和Java静态成员，在下面的脚本中，println被重命名为更短的名字，如REPL中所示：

```scala
scala> import System.out.{println as p}

scala> p("hello")
hello
```

因为**out**是**PrintStream**，**java.lang.System**中一个的**static final**实例，而**println**是**PrintStream**的方法。最后p是**println**方法的别名。

# 9.4 导入时隐藏类

## 问题

为避免命名冲突或混淆，在引入来自同一个包的其他成员时，隐藏一个或多个类。

## 解决方法

导入时隐藏类可以使用9.3节重命名的语法，但需要把类名指向字符 **_**，以下例子在导入**java.util**包中所有成员时隐藏了**Random**类：

```scala
import java.util.{Random => _, *}
```

在REPL中运行验证：

```scala
scala> import java.util.{Random => _, *}
import java.util.{Random=>_, _}
// can’t access Random
scala> val r = Random()
1 	|val r = Random()
    | ^^
    | Not found: Random

// can access other members
scala> val x = ArrayList()
val x: java.util.ArrayList[Nothing] = []
```

## 讨论

在这个例子中，下面代码隐藏了**Random**类：

```scala
import java.util.{Random => _}
```

之后，花括号中的字符 ***** 等价于导入包中所有内容，如下:

注意导入通配符 * 必须在最后一个位置。 在其他位置会出错：

```
scala> import java.util.{*, Random => _}
1   |import java.util.{*, Random => _}
    | ^^
    | named imports cannot follow wildcard imports
```

这是因为导入中要隐藏多个成员，得先列出它们。

导入时，在最后的通配符前列出要隐藏的成员：

```scala
import java.util.{List => _, Map => _, Set => _, *}
```

在这个导入语句之后，可以使用 **java.util** 中的其他类：

```scala
scala> val x = ArrayList[String]()
val x: java.util.ArrayList[String] = []
```

仍可以使用Scala的 **List**、**Set** 和 **Map** 类，而不会和同名的**java.util**中的类发生命名冲突：

```scala
// these are all Scala classes

scala> val a = List(1, 2, 3)
val a: List[Int] = List(1, 2, 3)

scala> val b = Set(1, 2, 3)
val b: Set[Int] = Set(1, 2, 3)

scala> val c = Map(1 -> 1, 2 -> 2)
val c: Map[Int, Int] = Map(1 -> 1, 2 -> 2)
```

当使用*****通配符导入包的多个成员时，但因为命名冲突，需要隐藏一个或多个成员时，这种方式很有用。

# 9.5 导入静态成员

## 问题

## 解决方法

## 讨论

# 

# 9.6 在任何地方使用导入语句

## 问题

## 解决方法

## 讨论

# 

# 9.7 导入Given

## 问题

## 解决方法

## 讨论

# 