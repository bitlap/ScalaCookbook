# 包和导入

包用于构建代码关联的模块，并且避免命名空间冲突。在最常见的形式中，可以用和Java相同的格式创建Scala的包.所以大部分Scala源代码文件以**package**声明开头，如下：

```scala
package com.alvinalexander.myapp.model
class Person ...`
```

然而Scala更加灵活，除了这种方法，还可以使用花括号的包风格，类似于C++和C#的命名空间。 9.1节展示了该语法。

Scala导入成员的方法与Java类似，而且更灵活。 在Scala里可以：

- 随处使用import语句。
- 导入类，包或者对象。
- 导入成员时隐藏和重命名成员。

本章演示了这些所有的方法。

在深入了解这些小节之前，有两个包被隐式导入到所有源代码文件的作用域中:

- **java.lang.***
- **scala.***

在Scala 3中，**import**语句中的 ***** 字符类似于 Java 中的 ***** 字符，因此这些语句表示“导入包中的每个成员”。

## Predef对象

除了这两个包之外，来自 **scala.Predef** 对象的所有成员也被隐式导入到源码文件中。

如果想了解Scala的工作原理，强烈建议花点时间深入研究**Predef** 对象的源码。 代码不长，但展示了Scala语言的很多特性。

正如我在第23页讨论“这些方法从何而来?” ，隐式转换被**Predef**对象引入到作用域中，在Scala 2.13的Predef对象——Scala 3.0仍在使用——代码如下所示：

```scala
implicit def long2Long(x: Long): java.lang.Long = x.asInstanceOf[java.lang.Long]
implicit def Long2long(x: java.lang.Long): Long = x.asInstanceOf[Long]
// more implicit conversions ...
```

同样，如果想知道为什么可以在不需要 **import** 语句的情况下调用 **Map**、**Set** 和 **println** 的代码，也可以在 **Predef** 中找到这些代码：

```scala
type Map[A, +B] = immutable.Map[A, B]
type Set[A] = immutable.Set[A]
def println(x: Any) = Console.println(x)
def printf(text: String, xs: Any*) = Console.print(text.format(xs: _*))
def assert(assertion: Boolean) { ... }
def require(requirement: Boolean) { ... }
```

# 9.1 花括号风格的包记号法

## 问题

使用嵌套风格的包表示法，类似于 C++ 和 C# 中的命名空间表示法。

## 解决方法

提供包名的同时，将一个或多个类包装在一对花括号内，如下所示：

```scala
package com.acme.store {
    class Foo:
    override def toString = "I am com.acme.store.Foo"
}
```

这个类的规范名称是**com.acme.store.Foo**。 和这样声明代码是一样的:

```scala
package com.acme.store
class Foo:
	override def toString = "I am com.acme.store.Foo"
```

### 好处

使用这种方法，可以将多个包放在一个文件中，也可以创建嵌套包。 为了演示这两种方法，以下例子创建了三个**Foo**类，都位于不同的包中：

```scala
package orderentry {
  class Foo:
  	override def toString = "I am orderentry.Foo"
}

package customers {
  class Foo:
 	 override def toString = "I am customers.Foo"
  
    package database {
    class Foo:
    	override def toString = "I am customers.database.Foo"
  }
}

// the output is shown after the comment tags.
@main def packageTests =
    println(orderentry.Foo()) // I am orderentry.Foo
    println(customers.Foo()) // I am customers.Foo
    println(customers.database.Foo()) // I am customers.database.Foo
```

这表明每个**Foo** 类都在不同的包中，并且**database**包嵌套在**customers**包中。

## 讨论

我看过很多Scala代码，据我所知，在文件顶部声明包名是最流行的包风格。

```scala
package foo.bar.baz

class Foo:
	override def toString = "I'm foo.bar.baz.Foo"
```

但是，由于Scala代码可以非常简洁，如果想在一个文件中声明多个类和包时，另一种花括号打包的语法会很方便。 比如在本书的源码仓库中，会看到我经常使用这种风格。

### 链式包子句

有时查看Scala程序时，会在源码文件的顶部看到多个包声明，如下所示：

```scala
package com.alvinalexander
package tests
...
```

这和编写两个嵌套的包的代码完全相同，如下所示：

```scala
package com.alvinalexander {
    package tests {
    ...
    }
}
```

使用第一种形式的原因是Scala程序员通常不喜欢使用花括号样式缩进代码，特别是在大文件中。所以他们用第一种形式。

使用两个包子句而不是一个，和每种方式在当前作用域中的可用性有关。如果只使用一条包语句：

```scala
package com.alvinalexander.tests
```

然而只有**com.alvinalexander.tests**的成员被引入作用域。但如果使用两个包声明：

```scala
package com.alvinalexander
package tests
...
```

**com.alvinalexander** 和 **com.alvinalexander.tests** 的成员都被引入作用域。

这种方式的原因和Scala 2.7中发现在Scala 2.8中解决的情况有关。详细信息可参考Martin Odersky文章 **chained package clauses**。

# 9.2 导入一个或多个成员

## 问题

将一个或多个成员导入当前代码的作用域。

## 解决方法

用这样语法导入一个类：

```scala
import java.io.File
```

还可以像这样导入多个类：

```scala
import java.io.File
import java.io.IOException
import java.io.FileNotFoundException
```

或者更简洁，像这样：

```scala
import java.io.{File, IOException, FileNotFoundException}
```



## 讨论


# 9.3 导入时重命名成员

## 问题

## 解决方法

## 讨论

# 9.4 导入过程中隐藏类

## 问题

## 解决方法

## 讨论

# 

# 9.5 导入静态成员

## 问题

## 解决方法

## 讨论

# 

# 9.6 在任何地方使用导入语句

## 问题

## 解决方法

## 讨论

# 

# 9.7 导入Given

## 问题

## 解决方法

## 讨论

# 