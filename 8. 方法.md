# 8. 方法

本章是领域建模的最后一个章节，主要介绍了*方法*相关的内容，方法可以定义在类、样例类、特质、枚举和对象中。值得注意的是，Scala 3中有一个重大的变化是方法也定义在这些结构之外。因此，一个完整的Scala 3应用程序如下所示：

```scala
    def printHello(name: String) = println(s"Hello, $name")
    def printString(s: String) = println(s)

    @main def hiMom =
        printHello("mom")
        printString("Look mom, no classes or objects required!")
```

Scala中的方法与其他编程语言中的方法类似。在Scala中，方法使用**def**关键字定义，通常携带一个或多个参数，然后执行算法，并返回某种结果。比如，一个最基本的不包含泛型以及**using**参数的方法定义如下：

```scala
    def methodName(paramName1: type1, paramName2: type2, ...): ReturnType =
        // the method body
        // goes here
```

声明方法的返回类型是可选的，但我发现，对于维护一个几个月或几年没有看过的项目，然后现在花一些时间来声明类型，可以在几天、几个月、甚至几年后回过头来查看时，也能更容易地理解其中的基本情况。当方法没有添加类型或使用其他动态类型语言时，我必须在将来花费相当长的时间来查看方法体，以确定其返回类型是什么，并且方法越长，所需的时间就越长。因此，大多数开发者都认为最好对方法的返回类型进行声明。正如我在《Scala/FP: Pure Function Signatures Tell All》（ *https://oreil.ly/oaXZg* ）文中所写，当进行函数式编程时，就会发现纯函数签名非常有意义。

**def**关键字的前面还可以使用一些其他关键字。比如，如果不希望方法被子类继承重写，可以被申明为**final**类型：

```scala
    class Foo:
        final def foo = "foo"        // FINAL

    class FooFoo extends Foo:
        override def foo = "foo foo" // ERROR, won’t compile
```

其他像**protected**和**private**等关键字，本章也会进行演示，以说明如何控制方法的作用范围。

Scala被认为是一种面向表达式的编程语言，这意味着每一行代码都是一个表达式：它返回一个值，且通常没有副作用。因此，方法可以非常简洁，像**if**、**for/yield**、**match**和**try**这样的结构都是含有返回值的表达式。简洁易读的代码称为*表达式（expressive）*，为了表现这一点，我将展示一些使用这些结构的表达式方法。

首先，下面展示了一些只使用等值测试或**if**表达式作为方法体的例子：

```scala
    // with return type
    def isBetween(a: Int, x: Int, y: Int): Boolean = a >= x && a <= y
    def max(a: Int, b: Int): Int = if a > b then a else b

    // without return type
    def isBetween(a: Int, x: Int, y: Int) = a >= x && a <= y
    def max(a: Int, b: Int) = if a > b then a else b
```

如果觉得更容易阅读，也可以将方法主体放在单独的一行上：

```scala
    def isBetween(a: Int, x: Int, y: Int): Boolean =
        a >= x && a <= y
    def max(a: Int, b: Int): Int =
        if a > b then a else b
```

然后，下面展示了使用**match**表达式作为方法体的例子：

```scala
    def sum(xs: List[Int]): Int = xs match
        case Nil => 0
        case x :: tail => x + sum(tail)
```

最后，对于**for**表达式，结合**for/yield**也可以作为方法体：

```scala
    def allThoseBetween3and10(xs: List[Int]): List[Int] =
        for
            x <- xs
            if x >= 3 
            if x <= 10
        yield
            x

    println(allThoseBetween3and10(List(1,3,7,11))) // List(3, 7)
```

类似的，也可以在很多其他结构上使用类似的技术，比如**try/catch**表达式。

上面介绍的例子展示了Scala方法的几个特性，但远不止如此。接下来的下节将进行详细地介绍：

* 指定方法的访问控制，即方法的可见性（8.1小节）

* 调用父类或者特质中的方法（8.2小节）

* 调用方法时指定参数名传参（8.3小节）

* 给方法参数定义缺省值（8.4小节）

* 使用可变参数（8.5小节）

* 强制调用方不使用括号调用方法（8.6小节）

* 声明方法可能抛出的异常（8.7小节）

* 使用特殊的技术支持方法链式调用的编码风格（8.8小节）

* 使用Scala 3新引入的扩展方法语法（8.9小节）

最后，除了方法的定义，在Scala中也可以使用**val**关键词进行函数（**function**）的定义。函数将在第10章进行详细讨论，并且我在《Scala: The Differences Between val and def When Creating Functions》（ *https://oreil.ly/7yTLg* ）一文中详细描述了这些差异。



## 8.1 控制方法作用域（访问修饰符）



















- [ ]  8.2 Calling a Method on a Superclass or Trait 239
- [ ]  8.3 Using Parameter Names When Calling a Method 242
- [ ]  8.4 Setting Default Values for Method Parameters 244
- [ ]  8.5 Creating Methods That Take Variable-Argument Fields 245
- [ ]  8.6 Forcing Callers to Leave Parentheses Off Accessor Methods 247
- [ ]  8.7 Declaring That a Method Can Throw an Exception 248
- [ ]  8.8 Supporting a Fluent Style of Programming 250
- [ ]  8.9 Adding New Methods to Closed Classes with Extension Methods 254
