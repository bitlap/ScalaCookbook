# 8. 方法

本章是领域建模的最后一个章节，主要介绍了*方法*相关的内容，方法可以定义在类、样例类、特质、枚举和对象中。值得注意的是，Scala 3中有一个重大的变化是方法也定义在这些结构之外。因此，一个完整的Scala 3应用程序如下所示：

```scala
    def printHello(name: String) = println(s"Hello, $name")
    def printString(s: String) = println(s)

    @main def hiMom =
        printHello("mom")
        printString("Look mom, no classes or objects required!")
```

Scala中的方法与其他编程语言中的方法类似。在Scala中，方法使用**def**关键字定义，通常携带一个或多个参数，然后执行算法，并返回某种结果。比如，一个最基本的不包含泛型以及**using**参数的方法定义如下：

```scala
    def methodName(paramName1: type1, paramName2: type2, ...): ReturnType =
        // the method body
        // goes here
```

声明方法的返回类型是可选的，但我发现，对于维护一个几个月或几年没有看过的项目，然后现在花一些时间来声明类型，可以在几天、几个月、甚至几年后回过头来查看时，也能更容易地理解其中的基本情况。当方法没有添加类型或使用其他动态类型语言时，我必须在将来花费相当长的时间来查看方法体，以确定其返回类型是什么，并且方法越长，所需的时间就越长。因此，大多数开发者都认为最好对方法的返回类型进行声明。正如我在《Scala/FP: Pure Function Signatures Tell All》（ *https://oreil.ly/oaXZg* ）文中所写，当进行函数式编程时，就会发现纯函数签名非常有意义。

**def**关键字的前面还可以使用一些其他关键字。比如，如果不希望方法被子类继承重写，可以被申明为**final**类型：

```scala
    class Foo:
        final def foo = "foo"        // FINAL

    class FooFoo extends Foo:
        override def foo = "foo foo" // ERROR, won’t compile
```

其他像**protected**和**private**等关键字，本章也会进行演示，以说明如何控制方法的作用范围。

Scala被认为是一种面向表达式的编程语言，这意味着每一行代码都是一个表达式：它返回一个值，且通常没有副作用。因此，方法可以非常简洁，像**if**、**for/yield**、**match**和**try**这样的结构都是含有返回值的表达式。简洁易读的代码称为*表达式（expressive）*，为了表现这一点，我将展示一些使用这些结构的表达式方法。

首先，下面展示了一些只使用等值测试或**if**表达式作为方法体的例子：

```scala
    // with return type
    def isBetween(a: Int, x: Int, y: Int): Boolean = a >= x && a <= y
    def max(a: Int, b: Int): Int = if a > b then a else b

    // without return type
    def isBetween(a: Int, x: Int, y: Int) = a >= x && a <= y
    def max(a: Int, b: Int) = if a > b then a else b
```

如果觉得更容易阅读，也可以将方法主体放在单独的一行上：

```scala
    def isBetween(a: Int, x: Int, y: Int): Boolean =
        a >= x && a <= y
    def max(a: Int, b: Int): Int =
        if a > b then a else b
```

然后，下面展示了使用**match**表达式作为方法体的例子：

```scala
    def sum(xs: List[Int]): Int = xs match
        case Nil => 0
        case x :: tail => x + sum(tail)
```

最后，对于**for**表达式，结合**for/yield**也可以作为方法体：

```scala
    def allThoseBetween3and10(xs: List[Int]): List[Int] =
        for
            x <- xs
            if x >= 3 
            if x <= 10
        yield
            x

    println(allThoseBetween3and10(List(1,3,7,11))) // List(3, 7)
```

类似的，也可以在很多其他结构上使用类似的技术，比如**try/catch**表达式。

上面介绍的例子展示了Scala方法的几个特性，但远不止如此。接下来的下节将进行详细地介绍：

* 指定方法的访问控制，即方法的可见性（8.1小节）

* 调用父类或者特质中的方法（8.2小节）

* 调用方法时指定参数名传参（8.3小节）

* 给方法参数定义缺省值（8.4小节）

* 使用可变参数（8.5小节）

* 强制调用方不使用括号调用方法（8.6小节）

* 声明方法可能抛出的异常（8.7小节）

* 使用特殊的技术支持方法链式调用的编码风格（8.8小节）

* 使用Scala 3新引入的扩展方法语法（8.9小节）

最后，除了方法的定义，在Scala中也可以使用**val**关键词进行函数（**function**）的定义。函数将在第10章进行详细讨论，并且我在《Scala: The Differences Between val and def When Creating Functions》（ *https://oreil.ly/7yTLg* ）一文中详细描述了这些差异。

## 8.1 控制方法作用域（访问修饰符）

### 问题

Scala中的方法缺省的访问修饰符是public，想要像Java那样控制方法的作用域。

### 解决方案

Scala允许更细粒度地控制方法的可见性。按照”最严格“到”最开放“的顺序，Scala提供以下的作用域级别：

* 私有作用域（Private）

* 保护作用域（Protected）

* 包内可见的作用域（Package）

* 指定包内可见的作用域（Package specific）

* 公开的作用域（Public）

下面的例子分别展示了这些作用域的级别。

TODO（鸽子图）

#### private[this] 和 protected[this]

Scala 2提供了 **private[this]** 和 **protected[this]** 范围限定符的概念，但这些已经被废弃了。详情参阅Scala 3页面（ *https://oreil.ly/aRAfJ* ）中的有关讨论。

#### 私有作用域

最严格的访问是将访问设置为**私有（private）**，一个私有方法对（a）一个类中的当前实例和（b）该类的其他实例可见。下面的例子展示了如何将一个方法变成**私有**，并且如何被用一个类的其他实例调用：

```scala
    class Cat:
        private def isFriendlyCat = true
        def sampleMethod(other: Cat) =
            if other.isFriendlyCat then
                println("Can access other.isFriendlyCat")
                // ...
            end if
        end sampleMethod
    end Cat
```

类的**私有**方法对于其子类是不可见的。下面的代码会编译失败，因为**heartBeat**是**Animal**类的私有方法：

```scala
    class Animal:
        private def heartBeat() = println("Animal heart is beating")

    class Dog extends Animal:
        heartBeat() // ERROR: Not found: heartBeat
```

想要使方法可以被**Dog**类方法，可以使用保护作用域。

#### 保护作用域

标记为**protected**的方法可以（a）对相同类的其他实例可见，（b）在当前包中不可见，（c）对子类可见。下面的例子展示了这些要点：

```scala
    class Cat:
        protected def isFriendlyCat = true
        def catFoo(otherCat: Cat) =
            if otherCat.isFriendlyCat then // this compiles
                println("Can access 'otherCat.isFriendlyCat'") 
                // ...
            end if

    // CatHouse
    @main def catTests =
        val c1 = Cat()
        val c2 = Cat()
        c1.catFoo(c2) // this works

        // this code can’t access this method:
        // c1.isFriendlyCat // does not compile
```

在上面的代码中：

* **catFoo**方法中的 **if otherCat.isFriendlyCat** 表达式展示了在一个**Cat**类实例中，**Cat**的其他实例也能访问**isFriendlyCat**方法。

* **c1.catFoo(c2)** 表达式展示了一个**Cat**实例可以在另一个**Cat**实例上调用**catFoo**方法，并且**catFoo**方法内也可以调用另一个实例的**isFriendlyCat**方法。

* 注释掉的代码 **c1.isFriendlyCat** 展示了一个**Cat**实例不能直接调用**isFriendlyCat**方法；**protected**方法不允许这样做，尽管**CatHouse**和**Cat**在同一个包中。

由于**protected**可以被子类访问，所以下面的代码可以编译：

```scala
    class Animal:
        protected def heartBeat() = println("Animal heart is beating")

    class Dog extends Animal:
        heartBeat() // this
```

#### 包作用域

为了使一个方法对包内所有成员可见，可以使用 **private[packageName]** 将方法标记为对当前包私有。

下面的例子中，方法**privateModelMethod**对同一个包下的其他类可见（**model**包），但方法 **privateMethod** 和 **protected** 不可见。

```scala
    package com.devdaily.coolapp.model:
        class Foo:
            // this is in “package scope”
            private[model] def privateModelMethod = ??? // can be accessed by
                                                        // classes in
                                                        // com.devdaily.coolapp.model

            private def privateMethod = ???
            protected def protectedMethod = ??? 

    class Bar:
        val f = Foo()
        f.privateModelMethod // compiles
        // f.privateMethod   // won’t compile
        // f.protectedMethod // won’t compile
```

#### 指定包作用域

除了控制方法对当前包下的类可见之外，Scala还提供了更多的控制级别，可以控制一个方法对不同包级别下的类的可见性。下面的例子展示了方法**doUnderModel**、**doUnderCoolapp**、和**doUnderAcme**对不同包级别的可见性：

```scala
    package com.devdaily.coolapp.model:
        class Foo:
            // available under com.devdaily.coolapp.model
            private[model] def doUnderModel = ???

            // available under com.devdaily.coolapp
            private[coolapp] def doUnderCoolapp = ???

            // available under com.devdaily
            private[devdaily] def doUnderAcme = ???

    import com.devdaily.coolapp.model.Foo

    package com.devdaily.coolapp.view:
        class Bar:
            val f = Foo()
            // f.doUnderModel // won’t compile
            f.doUnderCoolapp
            f.doUnderAcme

    package com.devdaily.common:
        class Bar:
            val f = Foo()
            // f.doUnderModel // won’t compile
            // f.doUnderCoolapp // won’t compile
            f.doUnderAcme
```

例子中出现的方法可以这样理解：

* **doUnderModel** 方法对**model**包（**com.devdaily.coolapp.model**）下的其他类是可见的。

* **doUnderCoolapp** 方法对**coolapp**包（**com.devdaily.coolapp**）下的其他类是可见的。

* **doUnderAcme** 方法对所有**com.devdaily**包下的类是可见的。

#### 公开作用域

如果方法声明上没有访问修饰符，方法就是公开级别的，表示任何包中的代码都可以访问这个方法。在下面的例子中，任何包下的任何类都可以访问**doPublic**方法：

```scala
    package com.devdaily.coolapp.model:
        class Foo:
            def doPublic = ???

    package some.other.scope:
        class Bar:
            val f = com.devdaily.coolapp.model.Foo()
            f.doPublic
```

### 讨论

Scala的访问控制机制和Java是不同的。Scala的方法默认是公开的，当需要灵活地提供方法控制时，Scala也有对应的解决方案。

作为总结，表8-1描述了Scala中各种级别的访问控制。

*表8-1：Scala可见性控制符*

| 修饰符               | 描述                                     |
| ----------------- | -------------------------------------- |
| private           | 对类中的当前实例和同一个类的其他实例可见。                  |
| protected         | 对当前类及其子类的实例可见。                         |
| private[model]    | 对*com.devdaily.coolapp.model*包下的所有类可见。 |
| private[coolapp]  | 对*com.devdaily.coolapp*包下的所有类可见。       |
| private[devdaily] | 对*com.devdaily*包下的所有类可见。               |
| （无修饰符）            | 公开方法。                                  |

## 8.2 调用父类或特质的方法

#### 问题

为了减少重复代码，希望调用一个父类或者特质中的方法。

#### 解决方案

需要考虑几种可能出现的情况：

* 一个类中的方法与父类方法的名称不同，并且希望调用该父类的方法。

* 一个类中的方法与父类方法的名称相同，并且希望调用该父类的方法。

* 一个类中的方法与多个特质中方法的名称相同，并且希望调用指定trait的方法。

这些问题的解决方案如下所示。

#### walkThenRun调用walk和run方法

当想要调用父类中的方法，并且方法名与父类的方法不同，可以不用**super**关键字直接调用：

```scala
    class AnimalWithLegs:
        def walk() = println("I’m walking")
        def run() = println("I’m running")

    class Dog extends AnimalWithLegs:
        def walkThenRun() =
            walk()
            run()
```

在该例子中，**Dog**中的**walkThenRun**方法调用父类**AnimalWithLegs**中的**walk**和**run**方法。由于方法名不一样，可以不使用**super**引用父类。这也是面向对象编程中常规的方法继承。

虽然在这个例子中展示的是父类继承，但如果**AnimalWithLegs**是一个特质，那么使用也是类似。

#### walk方法调用super.walk方法

当一个类中的方法与父类的方法名称相同，并且想要调用父类的方法时，可以使用**override**定义该方法，然后使用**super**关键字调用父类方法：

```scala
    class AnimalWithLegs:
        // the superclass 'walk' method.
        def walk() = println("Animal is walking")

    class Dog extends AnimalWithLegs:
        // the subclass 'walk' method. 
        override def walk() =
            super.walk() // invoke the superclass method.
            println("Dog is walking") // add your own body.
```

在该例子中，**Dog**的**walk**方法与父类的名称一样，所以需要使用**super.walk**来调用父类的**walk**方法。

然后创建一个**Dog**的实例，接着调用**walk**方法，可以得到如下输出：

```scala
    val d = Dog()
    d.walk() 

    // 输出
    Animal is walking
    Dog is walking
```

在这种情况，如果不希望调用父类的方法，可以简单进行重写，然后定义自己的方法实现：

```scala
    class Dog extends AnimalWithLegs:
        override def walk() =
            println("Dog is walking")
```

此时，创建一个**Dog**的实例，接着调用**walk**方法，可以得到如下输出：

```scala
    Dog is walking
```

跟之前的例子一样，如果**AnimalWithLegs**是特质，那么使用方式也类似。

#### 控制调用方法所属的特质

如果类继承了多个特质，并且这些特质实现了同样的方法，在使用**super**调用父类方法时，不仅要选择调用的方法，还可以选择要调用的特质。比如下面的类继承结构：

```scala
    trait Human:
        def yo = "Human"

    trait Mother extends Human:
        override def yo = "Mother"

    trait Father extends Human:
        override def yo = "Father"
```

下面的例子展示**Child**类中调用不同特质的**yo**方法：

```scala
    class Child extends Human, Mother, Father:
        def printSuper = super.yo
        def printMother = super[Mother].yo
        def printFather = super[Father].yo
        def printHuman = super[Human].yo
```

当创建一个**Child**的实例，然后调用其中的方法，可以得到如下输出：

```scala
    val c = Child()
    println(c.printSuper)  // Father
    println(c.printMother) // Mother
    println(c.printFather) // Father
    println(c.printHuman)  // Human
```

如上所示，当一个类继承了多个特质，这些特质都有一个同名的方法，可以通过super[traitName].methodName来指定调用哪个特质上的方法。注意 **c.printSuper** 输出的是 **Father**，因为特质的初始化是从左向右的，而**Father**是最后一个混入**Child**的特质：

```scala
    class Child extends Human, Mother, Father:
                                       ------
```

当时也这种方法时，目标特质必须被当前类通过**extends**关键字集成，否则无法访问对应特质的方法。例如，下面的代码会编译失败，是因为**Child**类没有直接继承**Human**特质：

```scala
    class Child extends Mother, Father:     // removed `Human`
        def printSuper = super.yo
        def printMother = super[Mother].yo
        def printFather = super[Father].yo
        def printHuman = super[Human].yo    // won’t compile
```

当尝试编译此代码时，会得到“Human不是Child的父类”的错误。

## 8.3 使用方法参数名

### 问题

偏向于在调用方法时指定方法参数名称的编码风格。

### 解决方案

### 讨论

- [ ]  8.4 Setting Default Values for Method Parameters 244
- [ ]  8.5 Creating Methods That Take Variable-Argument Fields 245
- [ ]  8.6 Forcing Callers to Leave Parentheses Off Accessor Methods 247
- [ ]  8.7 Declaring That a Method Can Throw an Exception 248
- [ ]  8.8 Supporting a Fluent Style of Programming 250
- [ ]  8.9 Adding New Methods to Closed Classes with Extension Methods 254
